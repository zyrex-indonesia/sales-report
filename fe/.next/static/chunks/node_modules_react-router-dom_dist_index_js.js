"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_react-router-dom_dist_index_js"],{

/***/ "./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),\n/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),\n/* harmony export */   UNSAFE_DEFERRED_SYMBOL: () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),\n/* harmony export */   UNSAFE_DeferredData: () => (/* binding */ DeferredData),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   UNSAFE_convertRouteMatchToUiMatch: () => (/* binding */ convertRouteMatchToUiMatch),\n/* harmony export */   UNSAFE_convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),\n/* harmony export */   UNSAFE_decodePath: () => (/* binding */ decodePath),\n/* harmony export */   UNSAFE_getResolveToMatches: () => (/* binding */ getResolveToMatches),\n/* harmony export */   UNSAFE_invariant: () => (/* binding */ invariant),\n/* harmony export */   UNSAFE_warning: () => (/* binding */ warning),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler),\n/* harmony export */   data: () => (/* binding */ data),\n/* harmony export */   defer: () => (/* binding */ defer),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),\n/* harmony export */   getToPathname: () => (/* binding */ getToPathname),\n/* harmony export */   isDataWithResponseInit: () => (/* binding */ isDataWithResponseInit),\n/* harmony export */   isDeferredData: () => (/* binding */ isDeferredData),\n/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   joinPaths: () => (/* binding */ joinPaths),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   normalizePathname: () => (/* binding */ normalizePathname),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   redirect: () => (/* binding */ redirect),\n/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   resolveTo: () => (/* binding */ resolveTo),\n/* harmony export */   stripBasename: () => (/* binding */ stripBasename)\n/* harmony export */ });\n/**\r\n * @remix-run/router v1.20.0\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\r\nfunction _extends() {\r\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n    return target;\r\n  };\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region Types and Constants\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Actions represent the type of change to a location value.\r\n */\r\nvar Action;\r\n(function (Action) {\r\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\r\n  Action[\"Pop\"] = \"POP\";\r\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\r\n  Action[\"Push\"] = \"PUSH\";\r\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\r\n  Action[\"Replace\"] = \"REPLACE\";\r\n})(Action || (Action = {}));\r\nconst PopStateEventType = \"popstate\";\r\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n */\r\nfunction createMemoryHistory(options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  let {\r\n    initialEntries = [\"/\"],\r\n    initialIndex,\r\n    v5Compat = false\r\n  } = options;\r\n  let entries; // Declare so we can access from createMemoryLocation\r\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\r\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\r\n  let action = Action.Pop;\r\n  let listener = null;\r\n  function clampIndex(n) {\r\n    return Math.min(Math.max(n, 0), entries.length - 1);\r\n  }\r\n  function getCurrentLocation() {\r\n    return entries[index];\r\n  }\r\n  function createMemoryLocation(to, state, key) {\r\n    if (state === void 0) {\r\n      state = null;\r\n    }\r\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\r\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\r\n    return location;\r\n  }\r\n  function createHref(to) {\r\n    return typeof to === \"string\" ? to : createPath(to);\r\n  }\r\n  let history = {\r\n    get index() {\r\n      return index;\r\n    },\r\n    get action() {\r\n      return action;\r\n    },\r\n    get location() {\r\n      return getCurrentLocation();\r\n    },\r\n    createHref,\r\n    createURL(to) {\r\n      return new URL(createHref(to), \"http://localhost\");\r\n    },\r\n    encodeLocation(to) {\r\n      let path = typeof to === \"string\" ? parsePath(to) : to;\r\n      return {\r\n        pathname: path.pathname || \"\",\r\n        search: path.search || \"\",\r\n        hash: path.hash || \"\"\r\n      };\r\n    },\r\n    push(to, state) {\r\n      action = Action.Push;\r\n      let nextLocation = createMemoryLocation(to, state);\r\n      index += 1;\r\n      entries.splice(index, entries.length, nextLocation);\r\n      if (v5Compat && listener) {\r\n        listener({\r\n          action,\r\n          location: nextLocation,\r\n          delta: 1\r\n        });\r\n      }\r\n    },\r\n    replace(to, state) {\r\n      action = Action.Replace;\r\n      let nextLocation = createMemoryLocation(to, state);\r\n      entries[index] = nextLocation;\r\n      if (v5Compat && listener) {\r\n        listener({\r\n          action,\r\n          location: nextLocation,\r\n          delta: 0\r\n        });\r\n      }\r\n    },\r\n    go(delta) {\r\n      action = Action.Pop;\r\n      let nextIndex = clampIndex(index + delta);\r\n      let nextLocation = entries[nextIndex];\r\n      index = nextIndex;\r\n      if (listener) {\r\n        listener({\r\n          action,\r\n          location: nextLocation,\r\n          delta\r\n        });\r\n      }\r\n    },\r\n    listen(fn) {\r\n      listener = fn;\r\n      return () => {\r\n        listener = null;\r\n      };\r\n    }\r\n  };\r\n  return history;\r\n}\r\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\r\nfunction createBrowserHistory(options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  function createBrowserLocation(window, globalHistory) {\r\n    let {\r\n      pathname,\r\n      search,\r\n      hash\r\n    } = window.location;\r\n    return createLocation(\"\", {\r\n      pathname,\r\n      search,\r\n      hash\r\n    },\r\n    // state defaults to `null` because `window.history.state` does\r\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\r\n  }\r\n  function createBrowserHref(window, to) {\r\n    return typeof to === \"string\" ? to : createPath(to);\r\n  }\r\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\r\n}\r\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\r\nfunction createHashHistory(options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  function createHashLocation(window, globalHistory) {\r\n    let {\r\n      pathname = \"/\",\r\n      search = \"\",\r\n      hash = \"\"\r\n    } = parsePath(window.location.hash.substr(1));\r\n    // Hash URL should always have a leading / just like window.location.pathname\r\n    // does, so if an app ends up at a route like /#something then we add a\r\n    // leading slash so all of our path-matching behaves the same as if it would\r\n    // in a browser router.  This is particularly important when there exists a\r\n    // root splat route (<Route path=\"*\">) since that matches internally against\r\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\r\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\r\n      pathname = \"/\" + pathname;\r\n    }\r\n    return createLocation(\"\", {\r\n      pathname,\r\n      search,\r\n      hash\r\n    },\r\n    // state defaults to `null` because `window.history.state` does\r\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\r\n  }\r\n  function createHashHref(window, to) {\r\n    let base = window.document.querySelector(\"base\");\r\n    let href = \"\";\r\n    if (base && base.getAttribute(\"href\")) {\r\n      let url = window.location.href;\r\n      let hashIndex = url.indexOf(\"#\");\r\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\r\n    }\r\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\r\n  }\r\n  function validateHashLocation(location, to) {\r\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\r\n  }\r\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\r\n}\r\nfunction invariant(value, message) {\r\n  if (value === false || value === null || typeof value === \"undefined\") {\r\n    throw new Error(message);\r\n  }\r\n}\r\nfunction warning(cond, message) {\r\n  if (!cond) {\r\n    // eslint-disable-next-line no-console\r\n    if (typeof console !== \"undefined\") console.warn(message);\r\n    try {\r\n      // Welcome to debugging history!\r\n      //\r\n      // This error is thrown as a convenience, so you can more easily\r\n      // find the source for a warning that appears in the console by\r\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\r\n      throw new Error(message);\r\n      // eslint-disable-next-line no-empty\r\n    } catch (e) {}\r\n  }\r\n}\r\nfunction createKey() {\r\n  return Math.random().toString(36).substr(2, 8);\r\n}\r\n/**\r\n * For browser-based histories, we combine the state and key into an object\r\n */\r\nfunction getHistoryState(location, index) {\r\n  return {\r\n    usr: location.state,\r\n    key: location.key,\r\n    idx: index\r\n  };\r\n}\r\n/**\r\n * Creates a Location object with a unique key from the given Path\r\n */\r\nfunction createLocation(current, to, state, key) {\r\n  if (state === void 0) {\r\n    state = null;\r\n  }\r\n  let location = _extends({\r\n    pathname: typeof current === \"string\" ? current : current.pathname,\r\n    search: \"\",\r\n    hash: \"\"\r\n  }, typeof to === \"string\" ? parsePath(to) : to, {\r\n    state,\r\n    // TODO: This could be cleaned up.  push/replace should probably just take\r\n    // full Locations now and avoid the need to run through this flow at all\r\n    // But that's a pretty big refactor to the current test suite so going to\r\n    // keep as is for the time being and just let any incoming keys take precedence\r\n    key: to && to.key || key || createKey()\r\n  });\r\n  return location;\r\n}\r\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n */\r\nfunction createPath(_ref) {\r\n  let {\r\n    pathname = \"/\",\r\n    search = \"\",\r\n    hash = \"\"\r\n  } = _ref;\r\n  if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\r\n  if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\r\n  return pathname;\r\n}\r\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n */\r\nfunction parsePath(path) {\r\n  let parsedPath = {};\r\n  if (path) {\r\n    let hashIndex = path.indexOf(\"#\");\r\n    if (hashIndex >= 0) {\r\n      parsedPath.hash = path.substr(hashIndex);\r\n      path = path.substr(0, hashIndex);\r\n    }\r\n    let searchIndex = path.indexOf(\"?\");\r\n    if (searchIndex >= 0) {\r\n      parsedPath.search = path.substr(searchIndex);\r\n      path = path.substr(0, searchIndex);\r\n    }\r\n    if (path) {\r\n      parsedPath.pathname = path;\r\n    }\r\n  }\r\n  return parsedPath;\r\n}\r\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  let {\r\n    window = document.defaultView,\r\n    v5Compat = false\r\n  } = options;\r\n  let globalHistory = window.history;\r\n  let action = Action.Pop;\r\n  let listener = null;\r\n  let index = getIndex();\r\n  // Index should only be null when we initialize. If not, it's because the\r\n  // user called history.pushState or history.replaceState directly, in which\r\n  // case we should log a warning as it will result in bugs.\r\n  if (index == null) {\r\n    index = 0;\r\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\r\n      idx: index\r\n    }), \"\");\r\n  }\r\n  function getIndex() {\r\n    let state = globalHistory.state || {\r\n      idx: null\r\n    };\r\n    return state.idx;\r\n  }\r\n  function handlePop() {\r\n    action = Action.Pop;\r\n    let nextIndex = getIndex();\r\n    let delta = nextIndex == null ? null : nextIndex - index;\r\n    index = nextIndex;\r\n    if (listener) {\r\n      listener({\r\n        action,\r\n        location: history.location,\r\n        delta\r\n      });\r\n    }\r\n  }\r\n  function push(to, state) {\r\n    action = Action.Push;\r\n    let location = createLocation(history.location, to, state);\r\n    if (validateLocation) validateLocation(location, to);\r\n    index = getIndex() + 1;\r\n    let historyState = getHistoryState(location, index);\r\n    let url = history.createHref(location);\r\n    // try...catch because iOS limits us to 100 pushState calls :/\r\n    try {\r\n      globalHistory.pushState(historyState, \"\", url);\r\n    } catch (error) {\r\n      // If the exception is because `state` can't be serialized, let that throw\r\n      // outwards just like a replace call would so the dev knows the cause\r\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\r\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\r\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\r\n        throw error;\r\n      }\r\n      // They are going to lose state here, but there is no real\r\n      // way to warn them about it since the page will refresh...\r\n      window.location.assign(url);\r\n    }\r\n    if (v5Compat && listener) {\r\n      listener({\r\n        action,\r\n        location: history.location,\r\n        delta: 1\r\n      });\r\n    }\r\n  }\r\n  function replace(to, state) {\r\n    action = Action.Replace;\r\n    let location = createLocation(history.location, to, state);\r\n    if (validateLocation) validateLocation(location, to);\r\n    index = getIndex();\r\n    let historyState = getHistoryState(location, index);\r\n    let url = history.createHref(location);\r\n    globalHistory.replaceState(historyState, \"\", url);\r\n    if (v5Compat && listener) {\r\n      listener({\r\n        action,\r\n        location: history.location,\r\n        delta: 0\r\n      });\r\n    }\r\n  }\r\n  function createURL(to) {\r\n    // window.location.origin is \"null\" (the literal string value) in Firefox\r\n    // under certain conditions, notably when serving from a local HTML file\r\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\r\n    let base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\r\n    let href = typeof to === \"string\" ? to : createPath(to);\r\n    // Treating this as a full URL will strip any trailing spaces so we need to\r\n    // pre-encode them since they might be part of a matching splat param from\r\n    // an ancestor route\r\n    href = href.replace(/ $/, \"%20\");\r\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\r\n    return new URL(href, base);\r\n  }\r\n  let history = {\r\n    get action() {\r\n      return action;\r\n    },\r\n    get location() {\r\n      return getLocation(window, globalHistory);\r\n    },\r\n    listen(fn) {\r\n      if (listener) {\r\n        throw new Error(\"A history only accepts one active listener\");\r\n      }\r\n      window.addEventListener(PopStateEventType, handlePop);\r\n      listener = fn;\r\n      return () => {\r\n        window.removeEventListener(PopStateEventType, handlePop);\r\n        listener = null;\r\n      };\r\n    },\r\n    createHref(to) {\r\n      return createHref(window, to);\r\n    },\r\n    createURL,\r\n    encodeLocation(to) {\r\n      // Encode a Location the same way window.location would\r\n      let url = createURL(to);\r\n      return {\r\n        pathname: url.pathname,\r\n        search: url.search,\r\n        hash: url.hash\r\n      };\r\n    },\r\n    push,\r\n    replace,\r\n    go(n) {\r\n      return globalHistory.go(n);\r\n    }\r\n  };\r\n  return history;\r\n}\r\n//#endregion\r\n\r\nvar ResultType;\r\n(function (ResultType) {\r\n  ResultType[\"data\"] = \"data\";\r\n  ResultType[\"deferred\"] = \"deferred\";\r\n  ResultType[\"redirect\"] = \"redirect\";\r\n  ResultType[\"error\"] = \"error\";\r\n})(ResultType || (ResultType = {}));\r\nconst immutableRouteKeys = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\r\nfunction isIndexRoute(route) {\r\n  return route.index === true;\r\n}\r\n// Walk the route tree generating unique IDs where necessary, so we are working\r\n// solely with AgnosticDataRouteObject's within the Router\r\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\r\n  if (parentPath === void 0) {\r\n    parentPath = [];\r\n  }\r\n  if (manifest === void 0) {\r\n    manifest = {};\r\n  }\r\n  return routes.map((route, index) => {\r\n    let treePath = [...parentPath, String(index)];\r\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\r\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\r\n    invariant(!manifest[id], \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\r\n    if (isIndexRoute(route)) {\r\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\r\n        id\r\n      });\r\n      manifest[id] = indexRoute;\r\n      return indexRoute;\r\n    } else {\r\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\r\n        id,\r\n        children: undefined\r\n      });\r\n      manifest[id] = pathOrLayoutRoute;\r\n      if (route.children) {\r\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\r\n      }\r\n      return pathOrLayoutRoute;\r\n    }\r\n  });\r\n}\r\n/**\r\n * Matches the given routes to a location and returns the match data.\r\n *\r\n * @see https://reactrouter.com/utils/match-routes\r\n */\r\nfunction matchRoutes(routes, locationArg, basename) {\r\n  if (basename === void 0) {\r\n    basename = \"/\";\r\n  }\r\n  return matchRoutesImpl(routes, locationArg, basename, false);\r\n}\r\nfunction matchRoutesImpl(routes, locationArg, basename, allowPartial) {\r\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\r\n  let pathname = stripBasename(location.pathname || \"/\", basename);\r\n  if (pathname == null) {\r\n    return null;\r\n  }\r\n  let branches = flattenRoutes(routes);\r\n  rankRouteBranches(branches);\r\n  let matches = null;\r\n  for (let i = 0; matches == null && i < branches.length; ++i) {\r\n    // Incoming pathnames are generally encoded from either window.location\r\n    // or from router.navigate, but we want to match against the unencoded\r\n    // paths in the route definitions.  Memory router locations won't be\r\n    // encoded here but there also shouldn't be anything to decode so this\r\n    // should be a safe operation.  This avoids needing matchRoutes to be\r\n    // history-aware.\r\n    let decoded = decodePath(pathname);\r\n    matches = matchRouteBranch(branches[i], decoded, allowPartial);\r\n  }\r\n  return matches;\r\n}\r\nfunction convertRouteMatchToUiMatch(match, loaderData) {\r\n  let {\r\n    route,\r\n    pathname,\r\n    params\r\n  } = match;\r\n  return {\r\n    id: route.id,\r\n    pathname,\r\n    params,\r\n    data: loaderData[route.id],\r\n    handle: route.handle\r\n  };\r\n}\r\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\r\n  if (branches === void 0) {\r\n    branches = [];\r\n  }\r\n  if (parentsMeta === void 0) {\r\n    parentsMeta = [];\r\n  }\r\n  if (parentPath === void 0) {\r\n    parentPath = \"\";\r\n  }\r\n  let flattenRoute = (route, index, relativePath) => {\r\n    let meta = {\r\n      relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\r\n      caseSensitive: route.caseSensitive === true,\r\n      childrenIndex: index,\r\n      route\r\n    };\r\n    if (meta.relativePath.startsWith(\"/\")) {\r\n      invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\r\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\r\n    }\r\n    let path = joinPaths([parentPath, meta.relativePath]);\r\n    let routesMeta = parentsMeta.concat(meta);\r\n    // Add the children before adding this route to the array, so we traverse the\r\n    // route tree depth-first and child routes appear before their parents in\r\n    // the \"flattened\" version.\r\n    if (route.children && route.children.length > 0) {\r\n      invariant(\r\n      // Our types know better, but runtime JS may not!\r\n      // @ts-expect-error\r\n      route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\r\n      flattenRoutes(route.children, branches, routesMeta, path);\r\n    }\r\n    // Routes without a path shouldn't ever match by themselves unless they are\r\n    // index routes, so don't add them to the list of possible branches.\r\n    if (route.path == null && !route.index) {\r\n      return;\r\n    }\r\n    branches.push({\r\n      path,\r\n      score: computeScore(path, route.index),\r\n      routesMeta\r\n    });\r\n  };\r\n  routes.forEach((route, index) => {\r\n    var _route$path;\r\n    // coarse-grain check for optional params\r\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\r\n      flattenRoute(route, index);\r\n    } else {\r\n      for (let exploded of explodeOptionalSegments(route.path)) {\r\n        flattenRoute(route, index, exploded);\r\n      }\r\n    }\r\n  });\r\n  return branches;\r\n}\r\n/**\r\n * Computes all combinations of optional path segments for a given path,\r\n * excluding combinations that are ambiguous and of lower priority.\r\n *\r\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\r\n * - `/one/three`\r\n * - `/one/:two/three`\r\n * - `/one/three/:four`\r\n * - `/one/three/:five`\r\n * - `/one/:two/three/:four`\r\n * - `/one/:two/three/:five`\r\n * - `/one/three/:four/:five`\r\n * - `/one/:two/three/:four/:five`\r\n */\r\nfunction explodeOptionalSegments(path) {\r\n  let segments = path.split(\"/\");\r\n  if (segments.length === 0) return [];\r\n  let [first, ...rest] = segments;\r\n  // Optional path segments are denoted by a trailing `?`\r\n  let isOptional = first.endsWith(\"?\");\r\n  // Compute the corresponding required segment: `foo?` -> `foo`\r\n  let required = first.replace(/\\?$/, \"\");\r\n  if (rest.length === 0) {\r\n    // Intepret empty string as omitting an optional segment\r\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\r\n    return isOptional ? [required, \"\"] : [required];\r\n  }\r\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\r\n  let result = [];\r\n  // All child paths with the prefix.  Do this for all children before the\r\n  // optional version for all children, so we get consistent ordering where the\r\n  // parent optional aspect is preferred as required.  Otherwise, we can get\r\n  // child sections interspersed where deeper optional segments are higher than\r\n  // parent optional segments, where for example, /:two would explode _earlier_\r\n  // then /:one.  By always including the parent as required _for all children_\r\n  // first, we avoid this issue\r\n  result.push(...restExploded.map(subpath => subpath === \"\" ? required : [required, subpath].join(\"/\")));\r\n  // Then, if this is an optional value, add all child versions without\r\n  if (isOptional) {\r\n    result.push(...restExploded);\r\n  }\r\n  // for absolute paths, ensure `/` instead of empty segment\r\n  return result.map(exploded => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\r\n}\r\nfunction rankRouteBranches(branches) {\r\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\r\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\r\n}\r\nconst paramRe = /^:[\\w-]+$/;\r\nconst dynamicSegmentValue = 3;\r\nconst indexRouteValue = 2;\r\nconst emptySegmentValue = 1;\r\nconst staticSegmentValue = 10;\r\nconst splatPenalty = -2;\r\nconst isSplat = s => s === \"*\";\r\nfunction computeScore(path, index) {\r\n  let segments = path.split(\"/\");\r\n  let initialScore = segments.length;\r\n  if (segments.some(isSplat)) {\r\n    initialScore += splatPenalty;\r\n  }\r\n  if (index) {\r\n    initialScore += indexRouteValue;\r\n  }\r\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\r\n}\r\nfunction compareIndexes(a, b) {\r\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\r\n  return siblings ?\r\n  // If two routes are siblings, we should try to match the earlier sibling\r\n  // first. This allows people to have fine-grained control over the matching\r\n  // behavior by simply putting routes with identical paths in the order they\r\n  // want them tried.\r\n  a[a.length - 1] - b[b.length - 1] :\r\n  // Otherwise, it doesn't really make sense to rank non-siblings by index,\r\n  // so they sort equally.\r\n  0;\r\n}\r\nfunction matchRouteBranch(branch, pathname, allowPartial) {\r\n  if (allowPartial === void 0) {\r\n    allowPartial = false;\r\n  }\r\n  let {\r\n    routesMeta\r\n  } = branch;\r\n  let matchedParams = {};\r\n  let matchedPathname = \"/\";\r\n  let matches = [];\r\n  for (let i = 0; i < routesMeta.length; ++i) {\r\n    let meta = routesMeta[i];\r\n    let end = i === routesMeta.length - 1;\r\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\r\n    let match = matchPath({\r\n      path: meta.relativePath,\r\n      caseSensitive: meta.caseSensitive,\r\n      end\r\n    }, remainingPathname);\r\n    let route = meta.route;\r\n    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {\r\n      match = matchPath({\r\n        path: meta.relativePath,\r\n        caseSensitive: meta.caseSensitive,\r\n        end: false\r\n      }, remainingPathname);\r\n    }\r\n    if (!match) {\r\n      return null;\r\n    }\r\n    Object.assign(matchedParams, match.params);\r\n    matches.push({\r\n      // TODO: Can this as be avoided?\r\n      params: matchedParams,\r\n      pathname: joinPaths([matchedPathname, match.pathname]),\r\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\r\n      route\r\n    });\r\n    if (match.pathnameBase !== \"/\") {\r\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\r\n    }\r\n  }\r\n  return matches;\r\n}\r\n/**\r\n * Returns a path with params interpolated.\r\n *\r\n * @see https://reactrouter.com/utils/generate-path\r\n */\r\nfunction generatePath(originalPath, params) {\r\n  if (params === void 0) {\r\n    params = {};\r\n  }\r\n  let path = originalPath;\r\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\r\n    warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\r\n    path = path.replace(/\\*$/, \"/*\");\r\n  }\r\n  // ensure `/` is added at the beginning if the path is absolute\r\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\r\n  const stringify = p => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\r\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\r\n    const isLastSegment = index === array.length - 1;\r\n    // only apply the splat if it's the last segment\r\n    if (isLastSegment && segment === \"*\") {\r\n      const star = \"*\";\r\n      // Apply the splat\r\n      return stringify(params[star]);\r\n    }\r\n    const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\r\n    if (keyMatch) {\r\n      const [, key, optional] = keyMatch;\r\n      let param = params[key];\r\n      invariant(optional === \"?\" || param != null, \"Missing \\\":\" + key + \"\\\" param\");\r\n      return stringify(param);\r\n    }\r\n    // Remove any optional markers from optional static segments\r\n    return segment.replace(/\\?$/g, \"\");\r\n  })\r\n  // Remove empty segments\r\n  .filter(segment => !!segment);\r\n  return prefix + segments.join(\"/\");\r\n}\r\n/**\r\n * Performs pattern matching on a URL pathname and returns information about\r\n * the match.\r\n *\r\n * @see https://reactrouter.com/utils/match-path\r\n */\r\nfunction matchPath(pattern, pathname) {\r\n  if (typeof pattern === \"string\") {\r\n    pattern = {\r\n      path: pattern,\r\n      caseSensitive: false,\r\n      end: true\r\n    };\r\n  }\r\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\r\n  let match = pathname.match(matcher);\r\n  if (!match) return null;\r\n  let matchedPathname = match[0];\r\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\r\n  let captureGroups = match.slice(1);\r\n  let params = compiledParams.reduce((memo, _ref, index) => {\r\n    let {\r\n      paramName,\r\n      isOptional\r\n    } = _ref;\r\n    // We need to compute the pathnameBase here using the raw splat value\r\n    // instead of using params[\"*\"] later because it will be decoded then\r\n    if (paramName === \"*\") {\r\n      let splatValue = captureGroups[index] || \"\";\r\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\r\n    }\r\n    const value = captureGroups[index];\r\n    if (isOptional && !value) {\r\n      memo[paramName] = undefined;\r\n    } else {\r\n      memo[paramName] = (value || \"\").replace(/%2F/g, \"/\");\r\n    }\r\n    return memo;\r\n  }, {});\r\n  return {\r\n    params,\r\n    pathname: matchedPathname,\r\n    pathnameBase,\r\n    pattern\r\n  };\r\n}\r\nfunction compilePath(path, caseSensitive, end) {\r\n  if (caseSensitive === void 0) {\r\n    caseSensitive = false;\r\n  }\r\n  if (end === void 0) {\r\n    end = true;\r\n  }\r\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\r\n  let params = [];\r\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\r\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\r\n  .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\r\n  .replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional) => {\r\n    params.push({\r\n      paramName,\r\n      isOptional: isOptional != null\r\n    });\r\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\r\n  });\r\n  if (path.endsWith(\"*\")) {\r\n    params.push({\r\n      paramName: \"*\"\r\n    });\r\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\r\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\r\n  } else if (end) {\r\n    // When matching to the end, ignore trailing slashes\r\n    regexpSource += \"\\\\/*$\";\r\n  } else if (path !== \"\" && path !== \"/\") {\r\n    // If our path is non-empty and contains anything beyond an initial slash,\r\n    // then we have _some_ form of path in our regex, so we should expect to\r\n    // match only if we find the end of this path segment.  Look for an optional\r\n    // non-captured trailing slash (to match a portion of the URL) or the end\r\n    // of the path (if we've matched to the end).  We used to do this with a\r\n    // word boundary but that gives false positives on routes like\r\n    // /user-preferences since `-` counts as a word boundary.\r\n    regexpSource += \"(?:(?=\\\\/|$))\";\r\n  } else ;\r\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\r\n  return [matcher, params];\r\n}\r\nfunction decodePath(value) {\r\n  try {\r\n    return value.split(\"/\").map(v => decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\r\n  } catch (error) {\r\n    warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\r\n    return value;\r\n  }\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction stripBasename(pathname, basename) {\r\n  if (basename === \"/\") return pathname;\r\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\r\n    return null;\r\n  }\r\n  // We want to leave trailing slash behavior in the user's control, so if they\r\n  // specify a basename with a trailing slash, we should support it\r\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\r\n  let nextChar = pathname.charAt(startIndex);\r\n  if (nextChar && nextChar !== \"/\") {\r\n    // pathname does not start with basename/\r\n    return null;\r\n  }\r\n  return pathname.slice(startIndex) || \"/\";\r\n}\r\n/**\r\n * Returns a resolved path object relative to the given pathname.\r\n *\r\n * @see https://reactrouter.com/utils/resolve-path\r\n */\r\nfunction resolvePath(to, fromPathname) {\r\n  if (fromPathname === void 0) {\r\n    fromPathname = \"/\";\r\n  }\r\n  let {\r\n    pathname: toPathname,\r\n    search = \"\",\r\n    hash = \"\"\r\n  } = typeof to === \"string\" ? parsePath(to) : to;\r\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\r\n  return {\r\n    pathname,\r\n    search: normalizeSearch(search),\r\n    hash: normalizeHash(hash)\r\n  };\r\n}\r\nfunction resolvePathname(relativePath, fromPathname) {\r\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\r\n  let relativeSegments = relativePath.split(\"/\");\r\n  relativeSegments.forEach(segment => {\r\n    if (segment === \"..\") {\r\n      // Keep the root \"\" segment so the pathname starts at /\r\n      if (segments.length > 1) segments.pop();\r\n    } else if (segment !== \".\") {\r\n      segments.push(segment);\r\n    }\r\n  });\r\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\r\n}\r\nfunction getInvalidPathError(char, field, dest, path) {\r\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\r\n}\r\n/**\r\n * @private\r\n *\r\n * When processing relative navigation we want to ignore ancestor routes that\r\n * do not contribute to the path, such that index/pathless layout routes don't\r\n * interfere.\r\n *\r\n * For example, when moving a route element into an index route and/or a\r\n * pathless layout route, relative link behavior contained within should stay\r\n * the same.  Both of the following examples should link back to the root:\r\n *\r\n *   <Route path=\"/\">\r\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\r\n *   </Route>\r\n *\r\n *   <Route path=\"/\">\r\n *     <Route path=\"accounts\">\r\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\r\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\r\n *       </Route\r\n *     </Route>\r\n *   </Route>\r\n */\r\nfunction getPathContributingMatches(matches) {\r\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\r\n}\r\n// Return the array of pathnames for the current route matches - used to\r\n// generate the routePathnames input for resolveTo()\r\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\r\n  let pathMatches = getPathContributingMatches(matches);\r\n  // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\r\n  // match so we include splat values for \".\" links.  See:\r\n  // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\r\n  if (v7_relativeSplatPath) {\r\n    return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);\r\n  }\r\n  return pathMatches.map(match => match.pathnameBase);\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\r\n  if (isPathRelative === void 0) {\r\n    isPathRelative = false;\r\n  }\r\n  let to;\r\n  if (typeof toArg === \"string\") {\r\n    to = parsePath(toArg);\r\n  } else {\r\n    to = _extends({}, toArg);\r\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\r\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\r\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\r\n  }\r\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\r\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\r\n  let from;\r\n  // Routing is relative to the current pathname if explicitly requested.\r\n  //\r\n  // If a pathname is explicitly provided in `to`, it should be relative to the\r\n  // route context. This is explained in `Note on `<Link to>` values` in our\r\n  // migration guide from v5 as a means of disambiguation between `to` values\r\n  // that begin with `/` and those that do not. However, this is problematic for\r\n  // `to` values that do not provide a pathname. `to` can simply be a search or\r\n  // hash string, in which case we should assume that the navigation is relative\r\n  // to the current location's pathname and *not* the route pathname.\r\n  if (toPathname == null) {\r\n    from = locationPathname;\r\n  } else {\r\n    let routePathnameIndex = routePathnames.length - 1;\r\n    // With relative=\"route\" (the default), each leading .. segment means\r\n    // \"go up one route\" instead of \"go up one URL segment\".  This is a key\r\n    // difference from how <a href> works and a major reason we call this a\r\n    // \"to\" value instead of a \"href\".\r\n    if (!isPathRelative && toPathname.startsWith(\"..\")) {\r\n      let toSegments = toPathname.split(\"/\");\r\n      while (toSegments[0] === \"..\") {\r\n        toSegments.shift();\r\n        routePathnameIndex -= 1;\r\n      }\r\n      to.pathname = toSegments.join(\"/\");\r\n    }\r\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\r\n  }\r\n  let path = resolvePath(to, from);\r\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\r\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\r\n  // Or if this was a link to the current path which has a trailing slash\r\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\r\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\r\n    path.pathname += \"/\";\r\n  }\r\n  return path;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction getToPathname(to) {\r\n  // Empty strings should be treated the same as / paths\r\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\r\n}\r\n/**\r\n * @private\r\n */\r\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\r\n/**\r\n * @private\r\n */\r\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\r\n/**\r\n * @private\r\n */\r\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\r\n/**\r\n * @private\r\n */\r\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\r\n/**\r\n * This is a shortcut for creating `application/json` responses. Converts `data`\r\n * to JSON and sets the `Content-Type` header.\r\n */\r\nconst json = function json(data, init) {\r\n  if (init === void 0) {\r\n    init = {};\r\n  }\r\n  let responseInit = typeof init === \"number\" ? {\r\n    status: init\r\n  } : init;\r\n  let headers = new Headers(responseInit.headers);\r\n  if (!headers.has(\"Content-Type\")) {\r\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\r\n  }\r\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\r\n    headers\r\n  }));\r\n};\r\nclass DataWithResponseInit {\r\n  constructor(data, init) {\r\n    this.type = \"DataWithResponseInit\";\r\n    this.data = data;\r\n    this.init = init || null;\r\n  }\r\n}\r\n/**\r\n * Create \"responses\" that contain `status`/`headers` without forcing\r\n * serialization into an actual `Response` - used by Remix single fetch\r\n */\r\nfunction data(data, init) {\r\n  return new DataWithResponseInit(data, typeof init === \"number\" ? {\r\n    status: init\r\n  } : init);\r\n}\r\nclass AbortedDeferredError extends Error {}\r\nclass DeferredData {\r\n  constructor(data, responseInit) {\r\n    this.pendingKeysSet = new Set();\r\n    this.subscribers = new Set();\r\n    this.deferredKeys = [];\r\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\r\n    // Set up an AbortController + Promise we can race against to exit early\r\n    // cancellation\r\n    let reject;\r\n    this.abortPromise = new Promise((_, r) => reject = r);\r\n    this.controller = new AbortController();\r\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\r\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\r\n    this.controller.signal.addEventListener(\"abort\", onAbort);\r\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\r\n      let [key, value] = _ref2;\r\n      return Object.assign(acc, {\r\n        [key]: this.trackPromise(key, value)\r\n      });\r\n    }, {});\r\n    if (this.done) {\r\n      // All incoming values were resolved\r\n      this.unlistenAbortSignal();\r\n    }\r\n    this.init = responseInit;\r\n  }\r\n  trackPromise(key, value) {\r\n    if (!(value instanceof Promise)) {\r\n      return value;\r\n    }\r\n    this.deferredKeys.push(key);\r\n    this.pendingKeysSet.add(key);\r\n    // We store a little wrapper promise that will be extended with\r\n    // _data/_error props upon resolve/reject\r\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\r\n    // Register rejection listeners to avoid uncaught promise rejections on\r\n    // errors or aborted deferred values\r\n    promise.catch(() => {});\r\n    Object.defineProperty(promise, \"_tracked\", {\r\n      get: () => true\r\n    });\r\n    return promise;\r\n  }\r\n  onSettle(promise, key, error, data) {\r\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\r\n      this.unlistenAbortSignal();\r\n      Object.defineProperty(promise, \"_error\", {\r\n        get: () => error\r\n      });\r\n      return Promise.reject(error);\r\n    }\r\n    this.pendingKeysSet.delete(key);\r\n    if (this.done) {\r\n      // Nothing left to abort!\r\n      this.unlistenAbortSignal();\r\n    }\r\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\r\n    // should always resolve with a value or null\r\n    if (error === undefined && data === undefined) {\r\n      let undefinedError = new Error(\"Deferred data for key \\\"\" + key + \"\\\" resolved/rejected with `undefined`, \" + \"you must resolve/reject with a value or `null`.\");\r\n      Object.defineProperty(promise, \"_error\", {\r\n        get: () => undefinedError\r\n      });\r\n      this.emit(false, key);\r\n      return Promise.reject(undefinedError);\r\n    }\r\n    if (data === undefined) {\r\n      Object.defineProperty(promise, \"_error\", {\r\n        get: () => error\r\n      });\r\n      this.emit(false, key);\r\n      return Promise.reject(error);\r\n    }\r\n    Object.defineProperty(promise, \"_data\", {\r\n      get: () => data\r\n    });\r\n    this.emit(false, key);\r\n    return data;\r\n  }\r\n  emit(aborted, settledKey) {\r\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\r\n  }\r\n  subscribe(fn) {\r\n    this.subscribers.add(fn);\r\n    return () => this.subscribers.delete(fn);\r\n  }\r\n  cancel() {\r\n    this.controller.abort();\r\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\r\n    this.emit(true);\r\n  }\r\n  async resolveData(signal) {\r\n    let aborted = false;\r\n    if (!this.done) {\r\n      let onAbort = () => this.cancel();\r\n      signal.addEventListener(\"abort\", onAbort);\r\n      aborted = await new Promise(resolve => {\r\n        this.subscribe(aborted => {\r\n          signal.removeEventListener(\"abort\", onAbort);\r\n          if (aborted || this.done) {\r\n            resolve(aborted);\r\n          }\r\n        });\r\n      });\r\n    }\r\n    return aborted;\r\n  }\r\n  get done() {\r\n    return this.pendingKeysSet.size === 0;\r\n  }\r\n  get unwrappedData() {\r\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\r\n    return Object.entries(this.data).reduce((acc, _ref3) => {\r\n      let [key, value] = _ref3;\r\n      return Object.assign(acc, {\r\n        [key]: unwrapTrackedPromise(value)\r\n      });\r\n    }, {});\r\n  }\r\n  get pendingKeys() {\r\n    return Array.from(this.pendingKeysSet);\r\n  }\r\n}\r\nfunction isTrackedPromise(value) {\r\n  return value instanceof Promise && value._tracked === true;\r\n}\r\nfunction unwrapTrackedPromise(value) {\r\n  if (!isTrackedPromise(value)) {\r\n    return value;\r\n  }\r\n  if (value._error) {\r\n    throw value._error;\r\n  }\r\n  return value._data;\r\n}\r\nconst defer = function defer(data, init) {\r\n  if (init === void 0) {\r\n    init = {};\r\n  }\r\n  let responseInit = typeof init === \"number\" ? {\r\n    status: init\r\n  } : init;\r\n  return new DeferredData(data, responseInit);\r\n};\r\n/**\r\n * A redirect response. Sets the status code and the `Location` header.\r\n * Defaults to \"302 Found\".\r\n */\r\nconst redirect = function redirect(url, init) {\r\n  if (init === void 0) {\r\n    init = 302;\r\n  }\r\n  let responseInit = init;\r\n  if (typeof responseInit === \"number\") {\r\n    responseInit = {\r\n      status: responseInit\r\n    };\r\n  } else if (typeof responseInit.status === \"undefined\") {\r\n    responseInit.status = 302;\r\n  }\r\n  let headers = new Headers(responseInit.headers);\r\n  headers.set(\"Location\", url);\r\n  return new Response(null, _extends({}, responseInit, {\r\n    headers\r\n  }));\r\n};\r\n/**\r\n * A redirect response that will force a document reload to the new location.\r\n * Sets the status code and the `Location` header.\r\n * Defaults to \"302 Found\".\r\n */\r\nconst redirectDocument = (url, init) => {\r\n  let response = redirect(url, init);\r\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\r\n  return response;\r\n};\r\n/**\r\n * A redirect response that will perform a `history.replaceState` instead of a\r\n * `history.pushState` for client-side navigation redirects.\r\n * Sets the status code and the `Location` header.\r\n * Defaults to \"302 Found\".\r\n */\r\nconst replace = (url, init) => {\r\n  let response = redirect(url, init);\r\n  response.headers.set(\"X-Remix-Replace\", \"true\");\r\n  return response;\r\n};\r\n/**\r\n * @private\r\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\r\n *\r\n * We don't export the class for public use since it's an implementation\r\n * detail, but we export the interface above so folks can build their own\r\n * abstractions around instances via isRouteErrorResponse()\r\n */\r\nclass ErrorResponseImpl {\r\n  constructor(status, statusText, data, internal) {\r\n    if (internal === void 0) {\r\n      internal = false;\r\n    }\r\n    this.status = status;\r\n    this.statusText = statusText || \"\";\r\n    this.internal = internal;\r\n    if (data instanceof Error) {\r\n      this.data = data.toString();\r\n      this.error = data;\r\n    } else {\r\n      this.data = data;\r\n    }\r\n  }\r\n}\r\n/**\r\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\r\n * Response thrown from an action/loader\r\n */\r\nfunction isRouteErrorResponse(error) {\r\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\r\n}\r\n\r\nconst validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\r\nconst validMutationMethods = new Set(validMutationMethodsArr);\r\nconst validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\r\nconst validRequestMethods = new Set(validRequestMethodsArr);\r\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\r\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\r\nconst IDLE_NAVIGATION = {\r\n  state: \"idle\",\r\n  location: undefined,\r\n  formMethod: undefined,\r\n  formAction: undefined,\r\n  formEncType: undefined,\r\n  formData: undefined,\r\n  json: undefined,\r\n  text: undefined\r\n};\r\nconst IDLE_FETCHER = {\r\n  state: \"idle\",\r\n  data: undefined,\r\n  formMethod: undefined,\r\n  formAction: undefined,\r\n  formEncType: undefined,\r\n  formData: undefined,\r\n  json: undefined,\r\n  text: undefined\r\n};\r\nconst IDLE_BLOCKER = {\r\n  state: \"unblocked\",\r\n  proceed: undefined,\r\n  reset: undefined,\r\n  location: undefined\r\n};\r\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\r\nconst defaultMapRouteProperties = route => ({\r\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\r\n});\r\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\r\n//#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region createRouter\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Create a router and listen to history POP navigations\r\n */\r\nfunction createRouter(init) {\r\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\r\n  const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\r\n  const isServer = !isBrowser;\r\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\r\n  let mapRouteProperties;\r\n  if (init.mapRouteProperties) {\r\n    mapRouteProperties = init.mapRouteProperties;\r\n  } else if (init.detectErrorBoundary) {\r\n    // If they are still using the deprecated version, wrap it with the new API\r\n    let detectErrorBoundary = init.detectErrorBoundary;\r\n    mapRouteProperties = route => ({\r\n      hasErrorBoundary: detectErrorBoundary(route)\r\n    });\r\n  } else {\r\n    mapRouteProperties = defaultMapRouteProperties;\r\n  }\r\n  // Routes keyed by ID\r\n  let manifest = {};\r\n  // Routes in tree format for matching\r\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\r\n  let inFlightDataRoutes;\r\n  let basename = init.basename || \"/\";\r\n  let dataStrategyImpl = init.dataStrategy || defaultDataStrategy;\r\n  let patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation;\r\n  // Config driven behavior flags\r\n  let future = _extends({\r\n    v7_fetcherPersist: false,\r\n    v7_normalizeFormMethod: false,\r\n    v7_partialHydration: false,\r\n    v7_prependBasename: false,\r\n    v7_relativeSplatPath: false,\r\n    v7_skipActionErrorRevalidation: false\r\n  }, init.future);\r\n  // Cleanup function for history\r\n  let unlistenHistory = null;\r\n  // Externally-provided functions to call on all state changes\r\n  let subscribers = new Set();\r\n  // Externally-provided object to hold scroll restoration locations during routing\r\n  let savedScrollPositions = null;\r\n  // Externally-provided function to get scroll restoration keys\r\n  let getScrollRestorationKey = null;\r\n  // Externally-provided function to get current scroll position\r\n  let getScrollPosition = null;\r\n  // One-time flag to control the initial hydration scroll restoration.  Because\r\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\r\n  // the initial render, we need to manually trigger a separate updateState to\r\n  // send along the restoreScrollPosition\r\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\r\n  // SSR did the initial scroll restoration.\r\n  let initialScrollRestored = init.hydrationData != null;\r\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\r\n  let initialErrors = null;\r\n  if (initialMatches == null && !patchRoutesOnNavigationImpl) {\r\n    // If we do not match a user-provided-route, fall back to the root\r\n    // to allow the error boundary to take over\r\n    let error = getInternalRouterError(404, {\r\n      pathname: init.history.location.pathname\r\n    });\r\n    let {\r\n      matches,\r\n      route\r\n    } = getShortCircuitMatches(dataRoutes);\r\n    initialMatches = matches;\r\n    initialErrors = {\r\n      [route.id]: error\r\n    };\r\n  }\r\n  // In SPA apps, if the user provided a patchRoutesOnNavigation implementation and\r\n  // our initial match is a splat route, clear them out so we run through lazy\r\n  // discovery on hydration in case there's a more accurate lazy route match.\r\n  // In SSR apps (with `hydrationData`), we expect that the server will send\r\n  // up the proper matched routes so we don't want to run lazy discovery on\r\n  // initial hydration and want to hydrate into the splat route.\r\n  if (initialMatches && !init.hydrationData) {\r\n    let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);\r\n    if (fogOfWar.active) {\r\n      initialMatches = null;\r\n    }\r\n  }\r\n  let initialized;\r\n  if (!initialMatches) {\r\n    initialized = false;\r\n    initialMatches = [];\r\n    // If partial hydration and fog of war is enabled, we will be running\r\n    // `patchRoutesOnNavigation` during hydration so include any partial matches as\r\n    // the initial matches so we can properly render `HydrateFallback`'s\r\n    if (future.v7_partialHydration) {\r\n      let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);\r\n      if (fogOfWar.active && fogOfWar.matches) {\r\n        initialMatches = fogOfWar.matches;\r\n      }\r\n    }\r\n  } else if (initialMatches.some(m => m.route.lazy)) {\r\n    // All initialMatches need to be loaded before we're ready.  If we have lazy\r\n    // functions around still then we'll need to run them in initialize()\r\n    initialized = false;\r\n  } else if (!initialMatches.some(m => m.route.loader)) {\r\n    // If we've got no loaders to run, then we're good to go\r\n    initialized = true;\r\n  } else if (future.v7_partialHydration) {\r\n    // If partial hydration is enabled, we're initialized so long as we were\r\n    // provided with hydrationData for every route with a loader, and no loaders\r\n    // were marked for explicit hydration\r\n    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\r\n    let errors = init.hydrationData ? init.hydrationData.errors : null;\r\n    // If errors exist, don't consider routes below the boundary\r\n    if (errors) {\r\n      let idx = initialMatches.findIndex(m => errors[m.route.id] !== undefined);\r\n      initialized = initialMatches.slice(0, idx + 1).every(m => !shouldLoadRouteOnHydration(m.route, loaderData, errors));\r\n    } else {\r\n      initialized = initialMatches.every(m => !shouldLoadRouteOnHydration(m.route, loaderData, errors));\r\n    }\r\n  } else {\r\n    // Without partial hydration - we're initialized if we were provided any\r\n    // hydrationData - which is expected to be complete\r\n    initialized = init.hydrationData != null;\r\n  }\r\n  let router;\r\n  let state = {\r\n    historyAction: init.history.action,\r\n    location: init.history.location,\r\n    matches: initialMatches,\r\n    initialized,\r\n    navigation: IDLE_NAVIGATION,\r\n    // Don't restore on initial updateState() if we were SSR'd\r\n    restoreScrollPosition: init.hydrationData != null ? false : null,\r\n    preventScrollReset: false,\r\n    revalidation: \"idle\",\r\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\r\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\r\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\r\n    fetchers: new Map(),\r\n    blockers: new Map()\r\n  };\r\n  // -- Stateful internal variables to manage navigations --\r\n  // Current navigation in progress (to be committed in completeNavigation)\r\n  let pendingAction = Action.Pop;\r\n  // Should the current navigation prevent the scroll reset if scroll cannot\r\n  // be restored?\r\n  let pendingPreventScrollReset = false;\r\n  // AbortController for the active navigation\r\n  let pendingNavigationController;\r\n  // Should the current navigation enable document.startViewTransition?\r\n  let pendingViewTransitionEnabled = false;\r\n  // Store applied view transitions so we can apply them on POP\r\n  let appliedViewTransitions = new Map();\r\n  // Cleanup function for persisting applied transitions to sessionStorage\r\n  let removePageHideEventListener = null;\r\n  // We use this to avoid touching history in completeNavigation if a\r\n  // revalidation is entirely uninterrupted\r\n  let isUninterruptedRevalidation = false;\r\n  // Use this internal flag to force revalidation of all loaders:\r\n  //  - submissions (completed or interrupted)\r\n  //  - useRevalidator()\r\n  //  - X-Remix-Revalidate (from redirect)\r\n  let isRevalidationRequired = false;\r\n  // Use this internal array to capture routes that require revalidation due\r\n  // to a cancelled deferred on action submission\r\n  let cancelledDeferredRoutes = [];\r\n  // Use this internal array to capture fetcher loads that were cancelled by an\r\n  // action navigation and require revalidation\r\n  let cancelledFetcherLoads = new Set();\r\n  // AbortControllers for any in-flight fetchers\r\n  let fetchControllers = new Map();\r\n  // Track loads based on the order in which they started\r\n  let incrementingLoadId = 0;\r\n  // Track the outstanding pending navigation data load to be compared against\r\n  // the globally incrementing load when a fetcher load lands after a completed\r\n  // navigation\r\n  let pendingNavigationLoadId = -1;\r\n  // Fetchers that triggered data reloads as a result of their actions\r\n  let fetchReloadIds = new Map();\r\n  // Fetchers that triggered redirect navigations\r\n  let fetchRedirectIds = new Set();\r\n  // Most recent href/match for fetcher.load calls for fetchers\r\n  let fetchLoadMatches = new Map();\r\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\r\n  let activeFetchers = new Map();\r\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\r\n  // they'll be officially removed after they return to idle\r\n  let deletedFetchers = new Set();\r\n  // Store DeferredData instances for active route matches.  When a\r\n  // route loader returns defer() we stick one in here.  Then, when a nested\r\n  // promise resolves we update loaderData.  If a new navigation starts we\r\n  // cancel active deferreds for eliminated routes.\r\n  let activeDeferreds = new Map();\r\n  // Store blocker functions in a separate Map outside of router state since\r\n  // we don't need to update UI state if they change\r\n  let blockerFunctions = new Map();\r\n  // Flag to ignore the next history update, so we can revert the URL change on\r\n  // a POP navigation that was blocked by the user without touching router state\r\n  let unblockBlockerHistoryUpdate = undefined;\r\n  // Initialize the router, all side effects should be kicked off from here.\r\n  // Implemented as a Fluent API for ease of:\r\n  //   let router = createRouter(init).initialize();\r\n  function initialize() {\r\n    // If history informs us of a POP navigation, start the navigation but do not update\r\n    // state.  We'll update our own state once the navigation completes\r\n    unlistenHistory = init.history.listen(_ref => {\r\n      let {\r\n        action: historyAction,\r\n        location,\r\n        delta\r\n      } = _ref;\r\n      // Ignore this event if it was just us resetting the URL from a\r\n      // blocked POP navigation\r\n      if (unblockBlockerHistoryUpdate) {\r\n        unblockBlockerHistoryUpdate();\r\n        unblockBlockerHistoryUpdate = undefined;\r\n        return;\r\n      }\r\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\r\n      let blockerKey = shouldBlockNavigation({\r\n        currentLocation: state.location,\r\n        nextLocation: location,\r\n        historyAction\r\n      });\r\n      if (blockerKey && delta != null) {\r\n        // Restore the URL to match the current UI, but don't update router state\r\n        let nextHistoryUpdatePromise = new Promise(resolve => {\r\n          unblockBlockerHistoryUpdate = resolve;\r\n        });\r\n        init.history.go(delta * -1);\r\n        // Put the blocker into a blocked state\r\n        updateBlocker(blockerKey, {\r\n          state: \"blocked\",\r\n          location,\r\n          proceed() {\r\n            updateBlocker(blockerKey, {\r\n              state: \"proceeding\",\r\n              proceed: undefined,\r\n              reset: undefined,\r\n              location\r\n            });\r\n            // Re-do the same POP navigation we just blocked, after the url\r\n            // restoration is also complete.  See:\r\n            // https://github.com/remix-run/react-router/issues/11613\r\n            nextHistoryUpdatePromise.then(() => init.history.go(delta));\r\n          },\r\n          reset() {\r\n            let blockers = new Map(state.blockers);\r\n            blockers.set(blockerKey, IDLE_BLOCKER);\r\n            updateState({\r\n              blockers\r\n            });\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      return startNavigation(historyAction, location);\r\n    });\r\n    if (isBrowser) {\r\n      // FIXME: This feels gross.  How can we cleanup the lines between\r\n      // scrollRestoration/appliedTransitions persistance?\r\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\r\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\r\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\r\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\r\n    }\r\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\r\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\r\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\r\n    // resolved prior to router creation since we can't go into a fallbackElement\r\n    // UI for SSR'd apps\r\n    if (!state.initialized) {\r\n      startNavigation(Action.Pop, state.location, {\r\n        initialHydration: true\r\n      });\r\n    }\r\n    return router;\r\n  }\r\n  // Clean up a router and it's side effects\r\n  function dispose() {\r\n    if (unlistenHistory) {\r\n      unlistenHistory();\r\n    }\r\n    if (removePageHideEventListener) {\r\n      removePageHideEventListener();\r\n    }\r\n    subscribers.clear();\r\n    pendingNavigationController && pendingNavigationController.abort();\r\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\r\n    state.blockers.forEach((_, key) => deleteBlocker(key));\r\n  }\r\n  // Subscribe to state updates for the router\r\n  function subscribe(fn) {\r\n    subscribers.add(fn);\r\n    return () => subscribers.delete(fn);\r\n  }\r\n  // Update our state and notify the calling context of the change\r\n  function updateState(newState, opts) {\r\n    if (opts === void 0) {\r\n      opts = {};\r\n    }\r\n    state = _extends({}, state, newState);\r\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\r\n    // can be removed\r\n    let completedFetchers = [];\r\n    let deletedFetchersKeys = [];\r\n    if (future.v7_fetcherPersist) {\r\n      state.fetchers.forEach((fetcher, key) => {\r\n        if (fetcher.state === \"idle\") {\r\n          if (deletedFetchers.has(key)) {\r\n            // Unmounted from the UI and can be totally removed\r\n            deletedFetchersKeys.push(key);\r\n          } else {\r\n            // Returned to idle but still mounted in the UI, so semi-remains for\r\n            // revalidations and such\r\n            completedFetchers.push(key);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // Iterate over a local copy so that if flushSync is used and we end up\r\n    // removing and adding a new subscriber due to the useCallback dependencies,\r\n    // we don't get ourselves into a loop calling the new subscriber immediately\r\n    [...subscribers].forEach(subscriber => subscriber(state, {\r\n      deletedFetchers: deletedFetchersKeys,\r\n      viewTransitionOpts: opts.viewTransitionOpts,\r\n      flushSync: opts.flushSync === true\r\n    }));\r\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\r\n    if (future.v7_fetcherPersist) {\r\n      completedFetchers.forEach(key => state.fetchers.delete(key));\r\n      deletedFetchersKeys.forEach(key => deleteFetcher(key));\r\n    }\r\n  }\r\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\r\n  // and setting state.[historyAction/location/matches] to the new route.\r\n  // - Location is a required param\r\n  // - Navigation will always be set to IDLE_NAVIGATION\r\n  // - Can pass any other state in newState\r\n  function completeNavigation(location, newState, _temp) {\r\n    var _location$state, _location$state2;\r\n    let {\r\n      flushSync\r\n    } = _temp === void 0 ? {} : _temp;\r\n    // Deduce if we're in a loading/actionReload state:\r\n    // - We have committed actionData in the store\r\n    // - The current navigation was a mutation submission\r\n    // - We're past the submitting state and into the loading state\r\n    // - The location being loaded is not the result of a redirect\r\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\r\n    let actionData;\r\n    if (newState.actionData) {\r\n      if (Object.keys(newState.actionData).length > 0) {\r\n        actionData = newState.actionData;\r\n      } else {\r\n        // Empty actionData -> clear prior actionData due to an action error\r\n        actionData = null;\r\n      }\r\n    } else if (isActionReload) {\r\n      // Keep the current data if we're wrapping up the action reload\r\n      actionData = state.actionData;\r\n    } else {\r\n      // Clear actionData on any other completed navigations\r\n      actionData = null;\r\n    }\r\n    // Always preserve any existing loaderData from re-used routes\r\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\r\n    // On a successful navigation we can assume we got through all blockers\r\n    // so we can start fresh\r\n    let blockers = state.blockers;\r\n    if (blockers.size > 0) {\r\n      blockers = new Map(blockers);\r\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\r\n    }\r\n    // Always respect the user flag.  Otherwise don't reset on mutation\r\n    // submission navigations unless they redirect\r\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\r\n    // Commit any in-flight routes at the end of the HMR revalidation \"navigation\"\r\n    if (inFlightDataRoutes) {\r\n      dataRoutes = inFlightDataRoutes;\r\n      inFlightDataRoutes = undefined;\r\n    }\r\n    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {\r\n      init.history.push(location, location.state);\r\n    } else if (pendingAction === Action.Replace) {\r\n      init.history.replace(location, location.state);\r\n    }\r\n    let viewTransitionOpts;\r\n    // On POP, enable transitions if they were enabled on the original navigation\r\n    if (pendingAction === Action.Pop) {\r\n      // Forward takes precedence so they behave like the original navigation\r\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\r\n      if (priorPaths && priorPaths.has(location.pathname)) {\r\n        viewTransitionOpts = {\r\n          currentLocation: state.location,\r\n          nextLocation: location\r\n        };\r\n      } else if (appliedViewTransitions.has(location.pathname)) {\r\n        // If we don't have a previous forward nav, assume we're popping back to\r\n        // the new location and enable if that location previously enabled\r\n        viewTransitionOpts = {\r\n          currentLocation: location,\r\n          nextLocation: state.location\r\n        };\r\n      }\r\n    } else if (pendingViewTransitionEnabled) {\r\n      // Store the applied transition on PUSH/REPLACE\r\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\r\n      if (toPaths) {\r\n        toPaths.add(location.pathname);\r\n      } else {\r\n        toPaths = new Set([location.pathname]);\r\n        appliedViewTransitions.set(state.location.pathname, toPaths);\r\n      }\r\n      viewTransitionOpts = {\r\n        currentLocation: state.location,\r\n        nextLocation: location\r\n      };\r\n    }\r\n    updateState(_extends({}, newState, {\r\n      actionData,\r\n      loaderData,\r\n      historyAction: pendingAction,\r\n      location,\r\n      initialized: true,\r\n      navigation: IDLE_NAVIGATION,\r\n      revalidation: \"idle\",\r\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\r\n      preventScrollReset,\r\n      blockers\r\n    }), {\r\n      viewTransitionOpts,\r\n      flushSync: flushSync === true\r\n    });\r\n    // Reset stateful navigation vars\r\n    pendingAction = Action.Pop;\r\n    pendingPreventScrollReset = false;\r\n    pendingViewTransitionEnabled = false;\r\n    isUninterruptedRevalidation = false;\r\n    isRevalidationRequired = false;\r\n    cancelledDeferredRoutes = [];\r\n  }\r\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\r\n  // replace with an optional submission\r\n  async function navigate(to, opts) {\r\n    if (typeof to === \"number\") {\r\n      init.history.go(to);\r\n      return;\r\n    }\r\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\r\n    let {\r\n      path,\r\n      submission,\r\n      error\r\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\r\n    let currentLocation = state.location;\r\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\r\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\r\n    // URL from window.location, so we need to encode it here so the behavior\r\n    // remains the same as POP and non-data-router usages.  new URL() does all\r\n    // the same encoding we'd get from a history.pushState/window.location read\r\n    // without having to touch history\r\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\r\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\r\n    let historyAction = Action.Push;\r\n    if (userReplace === true) {\r\n      historyAction = Action.Replace;\r\n    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\r\n      // By default on submissions to the current location we REPLACE so that\r\n      // users don't have to double-click the back button to get to the prior\r\n      // location.  If the user redirects to a different location from the\r\n      // action/loader this will be ignored and the redirect will be a PUSH\r\n      historyAction = Action.Replace;\r\n    }\r\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\r\n    let flushSync = (opts && opts.flushSync) === true;\r\n    let blockerKey = shouldBlockNavigation({\r\n      currentLocation,\r\n      nextLocation,\r\n      historyAction\r\n    });\r\n    if (blockerKey) {\r\n      // Put the blocker into a blocked state\r\n      updateBlocker(blockerKey, {\r\n        state: \"blocked\",\r\n        location: nextLocation,\r\n        proceed() {\r\n          updateBlocker(blockerKey, {\r\n            state: \"proceeding\",\r\n            proceed: undefined,\r\n            reset: undefined,\r\n            location: nextLocation\r\n          });\r\n          // Send the same navigation through\r\n          navigate(to, opts);\r\n        },\r\n        reset() {\r\n          let blockers = new Map(state.blockers);\r\n          blockers.set(blockerKey, IDLE_BLOCKER);\r\n          updateState({\r\n            blockers\r\n          });\r\n        }\r\n      });\r\n      return;\r\n    }\r\n    return await startNavigation(historyAction, nextLocation, {\r\n      submission,\r\n      // Send through the formData serialization error if we have one so we can\r\n      // render at the right error boundary after we match routes\r\n      pendingError: error,\r\n      preventScrollReset,\r\n      replace: opts && opts.replace,\r\n      enableViewTransition: opts && opts.viewTransition,\r\n      flushSync\r\n    });\r\n  }\r\n  // Revalidate all current loaders.  If a navigation is in progress or if this\r\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\r\n  // loaders during the next loader round\r\n  function revalidate() {\r\n    interruptActiveLoads();\r\n    updateState({\r\n      revalidation: \"loading\"\r\n    });\r\n    // If we're currently submitting an action, we don't need to start a new\r\n    // navigation, we'll just let the follow up loader execution call all loaders\r\n    if (state.navigation.state === \"submitting\") {\r\n      return;\r\n    }\r\n    // If we're currently in an idle state, start a new navigation for the current\r\n    // action/location and mark it as uninterrupted, which will skip the history\r\n    // update in completeNavigation\r\n    if (state.navigation.state === \"idle\") {\r\n      startNavigation(state.historyAction, state.location, {\r\n        startUninterruptedRevalidation: true\r\n      });\r\n      return;\r\n    }\r\n    // Otherwise, if we're currently in a loading state, just start a new\r\n    // navigation to the navigation.location but do not trigger an uninterrupted\r\n    // revalidation so that history correctly updates once the navigation completes\r\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\r\n      overrideNavigation: state.navigation,\r\n      // Proxy through any rending view transition\r\n      enableViewTransition: pendingViewTransitionEnabled === true\r\n    });\r\n  }\r\n  // Start a navigation to the given action/location.  Can optionally provide a\r\n  // overrideNavigation which will override the normalLoad in the case of a redirect\r\n  // navigation\r\n  async function startNavigation(historyAction, location, opts) {\r\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\r\n    // uninterrupted revalidations unless told otherwise, since we want this\r\n    // new navigation to update history normally\r\n    pendingNavigationController && pendingNavigationController.abort();\r\n    pendingNavigationController = null;\r\n    pendingAction = historyAction;\r\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\r\n    // Save the current scroll position every time we start a new navigation,\r\n    // and track whether we should reset scroll on completion\r\n    saveScrollPosition(state.location, state.matches);\r\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\r\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\r\n    let routesToUse = inFlightDataRoutes || dataRoutes;\r\n    let loadingNavigation = opts && opts.overrideNavigation;\r\n    let matches = matchRoutes(routesToUse, location, basename);\r\n    let flushSync = (opts && opts.flushSync) === true;\r\n    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);\r\n    if (fogOfWar.active && fogOfWar.matches) {\r\n      matches = fogOfWar.matches;\r\n    }\r\n    // Short circuit with a 404 on the root error boundary if we match nothing\r\n    if (!matches) {\r\n      let {\r\n        error,\r\n        notFoundMatches,\r\n        route\r\n      } = handleNavigational404(location.pathname);\r\n      completeNavigation(location, {\r\n        matches: notFoundMatches,\r\n        loaderData: {},\r\n        errors: {\r\n          [route.id]: error\r\n        }\r\n      }, {\r\n        flushSync\r\n      });\r\n      return;\r\n    }\r\n    // Short circuit if it's only a hash change and not a revalidation or\r\n    // mutation submission.\r\n    //\r\n    // Ignore on initial page loads because since the initial hydration will always\r\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\r\n    // which will default to a navigation to /page\r\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\r\n      completeNavigation(location, {\r\n        matches\r\n      }, {\r\n        flushSync\r\n      });\r\n      return;\r\n    }\r\n    // Create a controller/Request for this navigation\r\n    pendingNavigationController = new AbortController();\r\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\r\n    let pendingActionResult;\r\n    if (opts && opts.pendingError) {\r\n      // If we have a pendingError, it means the user attempted a GET submission\r\n      // with binary FormData so assign here and skip to handleLoaders.  That\r\n      // way we handle calling loaders above the boundary etc.  It's not really\r\n      // different from an actionError in that sense.\r\n      pendingActionResult = [findNearestBoundary(matches).route.id, {\r\n        type: ResultType.error,\r\n        error: opts.pendingError\r\n      }];\r\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\r\n      // Call action if we received an action submission\r\n      let actionResult = await handleAction(request, location, opts.submission, matches, fogOfWar.active, {\r\n        replace: opts.replace,\r\n        flushSync\r\n      });\r\n      if (actionResult.shortCircuited) {\r\n        return;\r\n      }\r\n      // If we received a 404 from handleAction, it's because we couldn't lazily\r\n      // discover the destination route so we don't want to call loaders\r\n      if (actionResult.pendingActionResult) {\r\n        let [routeId, result] = actionResult.pendingActionResult;\r\n        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {\r\n          pendingNavigationController = null;\r\n          completeNavigation(location, {\r\n            matches: actionResult.matches,\r\n            loaderData: {},\r\n            errors: {\r\n              [routeId]: result.error\r\n            }\r\n          });\r\n          return;\r\n        }\r\n      }\r\n      matches = actionResult.matches || matches;\r\n      pendingActionResult = actionResult.pendingActionResult;\r\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\r\n      flushSync = false;\r\n      // No need to do fog of war matching again on loader execution\r\n      fogOfWar.active = false;\r\n      // Create a GET request for the loaders\r\n      request = createClientSideRequest(init.history, request.url, request.signal);\r\n    }\r\n    // Call loaders\r\n    let {\r\n      shortCircuited,\r\n      matches: updatedMatches,\r\n      loaderData,\r\n      errors\r\n    } = await handleLoaders(request, location, matches, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);\r\n    if (shortCircuited) {\r\n      return;\r\n    }\r\n    // Clean up now that the action/loaders have completed.  Don't clean up if\r\n    // we short circuited because pendingNavigationController will have already\r\n    // been assigned to a new controller for the next navigation\r\n    pendingNavigationController = null;\r\n    completeNavigation(location, _extends({\r\n      matches: updatedMatches || matches\r\n    }, getActionDataForCommit(pendingActionResult), {\r\n      loaderData,\r\n      errors\r\n    }));\r\n  }\r\n  // Call the action matched by the leaf route for this navigation and handle\r\n  // redirects/errors\r\n  async function handleAction(request, location, submission, matches, isFogOfWar, opts) {\r\n    if (opts === void 0) {\r\n      opts = {};\r\n    }\r\n    interruptActiveLoads();\r\n    // Put us in a submitting state\r\n    let navigation = getSubmittingNavigation(location, submission);\r\n    updateState({\r\n      navigation\r\n    }, {\r\n      flushSync: opts.flushSync === true\r\n    });\r\n    if (isFogOfWar) {\r\n      let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\r\n      if (discoverResult.type === \"aborted\") {\r\n        return {\r\n          shortCircuited: true\r\n        };\r\n      } else if (discoverResult.type === \"error\") {\r\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\r\n        return {\r\n          matches: discoverResult.partialMatches,\r\n          pendingActionResult: [boundaryId, {\r\n            type: ResultType.error,\r\n            error: discoverResult.error\r\n          }]\r\n        };\r\n      } else if (!discoverResult.matches) {\r\n        let {\r\n          notFoundMatches,\r\n          error,\r\n          route\r\n        } = handleNavigational404(location.pathname);\r\n        return {\r\n          matches: notFoundMatches,\r\n          pendingActionResult: [route.id, {\r\n            type: ResultType.error,\r\n            error\r\n          }]\r\n        };\r\n      } else {\r\n        matches = discoverResult.matches;\r\n      }\r\n    }\r\n    // Call our action and get the result\r\n    let result;\r\n    let actionMatch = getTargetMatch(matches, location);\r\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\r\n      result = {\r\n        type: ResultType.error,\r\n        error: getInternalRouterError(405, {\r\n          method: request.method,\r\n          pathname: location.pathname,\r\n          routeId: actionMatch.route.id\r\n        })\r\n      };\r\n    } else {\r\n      let results = await callDataStrategy(\"action\", state, request, [actionMatch], matches, null);\r\n      result = results[actionMatch.route.id];\r\n      if (request.signal.aborted) {\r\n        return {\r\n          shortCircuited: true\r\n        };\r\n      }\r\n    }\r\n    if (isRedirectResult(result)) {\r\n      let replace;\r\n      if (opts && opts.replace != null) {\r\n        replace = opts.replace;\r\n      } else {\r\n        // If the user didn't explicity indicate replace behavior, replace if\r\n        // we redirected to the exact same location we're currently at to avoid\r\n        // double back-buttons\r\n        let location = normalizeRedirectLocation(result.response.headers.get(\"Location\"), new URL(request.url), basename);\r\n        replace = location === state.location.pathname + state.location.search;\r\n      }\r\n      await startRedirectNavigation(request, result, true, {\r\n        submission,\r\n        replace\r\n      });\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    }\r\n    if (isDeferredResult(result)) {\r\n      throw getInternalRouterError(400, {\r\n        type: \"defer-action\"\r\n      });\r\n    }\r\n    if (isErrorResult(result)) {\r\n      // Store off the pending error - we use it to determine which loaders\r\n      // to call and will commit it when we complete the navigation\r\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\r\n      // By default, all submissions to the current location are REPLACE\r\n      // navigations, but if the action threw an error that'll be rendered in\r\n      // an errorElement, we fall back to PUSH so that the user can use the\r\n      // back button to get back to the pre-submission form location to try\r\n      // again\r\n      if ((opts && opts.replace) !== true) {\r\n        pendingAction = Action.Push;\r\n      }\r\n      return {\r\n        matches,\r\n        pendingActionResult: [boundaryMatch.route.id, result]\r\n      };\r\n    }\r\n    return {\r\n      matches,\r\n      pendingActionResult: [actionMatch.route.id, result]\r\n    };\r\n  }\r\n  // Call all applicable loaders for the given matches, handling redirects,\r\n  // errors, etc.\r\n  async function handleLoaders(request, location, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionResult) {\r\n    // Figure out the right navigation we want to use for data loading\r\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\r\n    // If this was a redirect from an action we don't have a \"submission\" but\r\n    // we have it on the loading navigation so use that if available\r\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\r\n    // If this is an uninterrupted revalidation, we remain in our current idle\r\n    // state.  If not, we need to switch to our loading state and load data,\r\n    // preserving any new action data or existing action data (in the case of\r\n    // a revalidation interrupting an actionReload)\r\n    // If we have partialHydration enabled, then don't update the state for the\r\n    // initial data load since it's not a \"navigation\"\r\n    let shouldUpdateNavigationState = !isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration);\r\n    // When fog of war is enabled, we enter our `loading` state earlier so we\r\n    // can discover new routes during the `loading` state.  We skip this if\r\n    // we've already run actions since we would have done our matching already.\r\n    // If the children() function threw then, we want to proceed with the\r\n    // partial matches it discovered.\r\n    if (isFogOfWar) {\r\n      if (shouldUpdateNavigationState) {\r\n        let actionData = getUpdatedActionData(pendingActionResult);\r\n        updateState(_extends({\r\n          navigation: loadingNavigation\r\n        }, actionData !== undefined ? {\r\n          actionData\r\n        } : {}), {\r\n          flushSync\r\n        });\r\n      }\r\n      let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\r\n      if (discoverResult.type === \"aborted\") {\r\n        return {\r\n          shortCircuited: true\r\n        };\r\n      } else if (discoverResult.type === \"error\") {\r\n        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\r\n        return {\r\n          matches: discoverResult.partialMatches,\r\n          loaderData: {},\r\n          errors: {\r\n            [boundaryId]: discoverResult.error\r\n          }\r\n        };\r\n      } else if (!discoverResult.matches) {\r\n        let {\r\n          error,\r\n          notFoundMatches,\r\n          route\r\n        } = handleNavigational404(location.pathname);\r\n        return {\r\n          matches: notFoundMatches,\r\n          loaderData: {},\r\n          errors: {\r\n            [route.id]: error\r\n          }\r\n        };\r\n      } else {\r\n        matches = discoverResult.matches;\r\n      }\r\n    }\r\n    let routesToUse = inFlightDataRoutes || dataRoutes;\r\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);\r\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\r\n    // about to reload.  Note that if this is an action reload we would have\r\n    // already cancelled all pending deferreds so this would be a no-op\r\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\r\n    pendingNavigationLoadId = ++incrementingLoadId;\r\n    // Short circuit if we have no loaders to run\r\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\r\n      let updatedFetchers = markFetchRedirectsDone();\r\n      completeNavigation(location, _extends({\r\n        matches,\r\n        loaderData: {},\r\n        // Commit pending error if we're short circuiting\r\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\r\n          [pendingActionResult[0]]: pendingActionResult[1].error\r\n        } : null\r\n      }, getActionDataForCommit(pendingActionResult), updatedFetchers ? {\r\n        fetchers: new Map(state.fetchers)\r\n      } : {}), {\r\n        flushSync\r\n      });\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    }\r\n    if (shouldUpdateNavigationState) {\r\n      let updates = {};\r\n      if (!isFogOfWar) {\r\n        // Only update navigation/actionNData if we didn't already do it above\r\n        updates.navigation = loadingNavigation;\r\n        let actionData = getUpdatedActionData(pendingActionResult);\r\n        if (actionData !== undefined) {\r\n          updates.actionData = actionData;\r\n        }\r\n      }\r\n      if (revalidatingFetchers.length > 0) {\r\n        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);\r\n      }\r\n      updateState(updates, {\r\n        flushSync\r\n      });\r\n    }\r\n    revalidatingFetchers.forEach(rf => {\r\n      abortFetcher(rf.key);\r\n      if (rf.controller) {\r\n        // Fetchers use an independent AbortController so that aborting a fetcher\r\n        // (via deleteFetcher) does not abort the triggering navigation that\r\n        // triggered the revalidation\r\n        fetchControllers.set(rf.key, rf.controller);\r\n      }\r\n    });\r\n    // Proxy navigation abort through to revalidation fetchers\r\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\r\n    if (pendingNavigationController) {\r\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\r\n    }\r\n    let {\r\n      loaderResults,\r\n      fetcherResults\r\n    } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, request);\r\n    if (request.signal.aborted) {\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    }\r\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\r\n    // circuited because fetchControllers would have been aborted and\r\n    // reassigned to new controllers for the next navigation\r\n    if (pendingNavigationController) {\r\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\r\n    }\r\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\r\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\r\n    let redirect = findRedirect(loaderResults);\r\n    if (redirect) {\r\n      await startRedirectNavigation(request, redirect.result, true, {\r\n        replace\r\n      });\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    }\r\n    redirect = findRedirect(fetcherResults);\r\n    if (redirect) {\r\n      // If this redirect came from a fetcher make sure we mark it in\r\n      // fetchRedirectIds so it doesn't get revalidated on the next set of\r\n      // loader executions\r\n      fetchRedirectIds.add(redirect.key);\r\n      await startRedirectNavigation(request, redirect.result, true, {\r\n        replace\r\n      });\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    }\r\n    // Process and commit output from loaders\r\n    let {\r\n      loaderData,\r\n      errors\r\n    } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);\r\n    // Wire up subscribers to update loaderData as promises settle\r\n    activeDeferreds.forEach((deferredData, routeId) => {\r\n      deferredData.subscribe(aborted => {\r\n        // Note: No need to updateState here since the TrackedPromise on\r\n        // loaderData is stable across resolve/reject\r\n        // Remove this instance if we were aborted or if promises have settled\r\n        if (aborted || deferredData.done) {\r\n          activeDeferreds.delete(routeId);\r\n        }\r\n      });\r\n    });\r\n    // Preserve SSR errors during partial hydration\r\n    if (future.v7_partialHydration && initialHydration && state.errors) {\r\n      errors = _extends({}, state.errors, errors);\r\n    }\r\n    let updatedFetchers = markFetchRedirectsDone();\r\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\r\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\r\n    return _extends({\r\n      matches,\r\n      loaderData,\r\n      errors\r\n    }, shouldUpdateFetchers ? {\r\n      fetchers: new Map(state.fetchers)\r\n    } : {});\r\n  }\r\n  function getUpdatedActionData(pendingActionResult) {\r\n    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\r\n      // This is cast to `any` currently because `RouteData`uses any and it\r\n      // would be a breaking change to use any.\r\n      // TODO: v7 - change `RouteData` to use `unknown` instead of `any`\r\n      return {\r\n        [pendingActionResult[0]]: pendingActionResult[1].data\r\n      };\r\n    } else if (state.actionData) {\r\n      if (Object.keys(state.actionData).length === 0) {\r\n        return null;\r\n      } else {\r\n        return state.actionData;\r\n      }\r\n    }\r\n  }\r\n  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {\r\n    revalidatingFetchers.forEach(rf => {\r\n      let fetcher = state.fetchers.get(rf.key);\r\n      let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\r\n      state.fetchers.set(rf.key, revalidatingFetcher);\r\n    });\r\n    return new Map(state.fetchers);\r\n  }\r\n  // Trigger a fetcher load/submit for the given fetcher key\r\n  function fetch(key, routeId, href, opts) {\r\n    if (isServer) {\r\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\r\n    }\r\n    abortFetcher(key);\r\n    let flushSync = (opts && opts.flushSync) === true;\r\n    let routesToUse = inFlightDataRoutes || dataRoutes;\r\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\r\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\r\n    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);\r\n    if (fogOfWar.active && fogOfWar.matches) {\r\n      matches = fogOfWar.matches;\r\n    }\r\n    if (!matches) {\r\n      setFetcherError(key, routeId, getInternalRouterError(404, {\r\n        pathname: normalizedPath\r\n      }), {\r\n        flushSync\r\n      });\r\n      return;\r\n    }\r\n    let {\r\n      path,\r\n      submission,\r\n      error\r\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\r\n    if (error) {\r\n      setFetcherError(key, routeId, error, {\r\n        flushSync\r\n      });\r\n      return;\r\n    }\r\n    let match = getTargetMatch(matches, path);\r\n    let preventScrollReset = (opts && opts.preventScrollReset) === true;\r\n    if (submission && isMutationMethod(submission.formMethod)) {\r\n      handleFetcherAction(key, routeId, path, match, matches, fogOfWar.active, flushSync, preventScrollReset, submission);\r\n      return;\r\n    }\r\n    // Store off the match so we can call it's shouldRevalidate on subsequent\r\n    // revalidations\r\n    fetchLoadMatches.set(key, {\r\n      routeId,\r\n      path\r\n    });\r\n    handleFetcherLoader(key, routeId, path, match, matches, fogOfWar.active, flushSync, preventScrollReset, submission);\r\n  }\r\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\r\n  // errors, and revalidation\r\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {\r\n    interruptActiveLoads();\r\n    fetchLoadMatches.delete(key);\r\n    function detectAndHandle405Error(m) {\r\n      if (!m.route.action && !m.route.lazy) {\r\n        let error = getInternalRouterError(405, {\r\n          method: submission.formMethod,\r\n          pathname: path,\r\n          routeId: routeId\r\n        });\r\n        setFetcherError(key, routeId, error, {\r\n          flushSync\r\n        });\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    if (!isFogOfWar && detectAndHandle405Error(match)) {\r\n      return;\r\n    }\r\n    // Put this fetcher into it's submitting state\r\n    let existingFetcher = state.fetchers.get(key);\r\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\r\n      flushSync\r\n    });\r\n    let abortController = new AbortController();\r\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\r\n    if (isFogOfWar) {\r\n      let discoverResult = await discoverRoutes(requestMatches, path, fetchRequest.signal);\r\n      if (discoverResult.type === \"aborted\") {\r\n        return;\r\n      } else if (discoverResult.type === \"error\") {\r\n        setFetcherError(key, routeId, discoverResult.error, {\r\n          flushSync\r\n        });\r\n        return;\r\n      } else if (!discoverResult.matches) {\r\n        setFetcherError(key, routeId, getInternalRouterError(404, {\r\n          pathname: path\r\n        }), {\r\n          flushSync\r\n        });\r\n        return;\r\n      } else {\r\n        requestMatches = discoverResult.matches;\r\n        match = getTargetMatch(requestMatches, path);\r\n        if (detectAndHandle405Error(match)) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n    // Call the action for the fetcher\r\n    fetchControllers.set(key, abortController);\r\n    let originatingLoadId = incrementingLoadId;\r\n    let actionResults = await callDataStrategy(\"action\", state, fetchRequest, [match], requestMatches, key);\r\n    let actionResult = actionResults[match.route.id];\r\n    if (fetchRequest.signal.aborted) {\r\n      // We can delete this so long as we weren't aborted by our own fetcher\r\n      // re-submit which would have put _new_ controller is in fetchControllers\r\n      if (fetchControllers.get(key) === abortController) {\r\n        fetchControllers.delete(key);\r\n      }\r\n      return;\r\n    }\r\n    // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\r\n    // or redirects processed for unmounted fetchers so we just revert them to\r\n    // idle\r\n    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\r\n      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\r\n        updateFetcherState(key, getDoneFetcher(undefined));\r\n        return;\r\n      }\r\n      // Let SuccessResult's fall through for revalidation\r\n    } else {\r\n      if (isRedirectResult(actionResult)) {\r\n        fetchControllers.delete(key);\r\n        if (pendingNavigationLoadId > originatingLoadId) {\r\n          // A new navigation was kicked off after our action started, so that\r\n          // should take precedence over this redirect navigation.  We already\r\n          // set isRevalidationRequired so all loaders for the new route should\r\n          // fire unless opted out via shouldRevalidate\r\n          updateFetcherState(key, getDoneFetcher(undefined));\r\n          return;\r\n        } else {\r\n          fetchRedirectIds.add(key);\r\n          updateFetcherState(key, getLoadingFetcher(submission));\r\n          return startRedirectNavigation(fetchRequest, actionResult, false, {\r\n            fetcherSubmission: submission,\r\n            preventScrollReset\r\n          });\r\n        }\r\n      }\r\n      // Process any non-redirect errors thrown\r\n      if (isErrorResult(actionResult)) {\r\n        setFetcherError(key, routeId, actionResult.error);\r\n        return;\r\n      }\r\n    }\r\n    if (isDeferredResult(actionResult)) {\r\n      throw getInternalRouterError(400, {\r\n        type: \"defer-action\"\r\n      });\r\n    }\r\n    // Start the data load for current matches, or the next location if we're\r\n    // in the middle of a navigation\r\n    let nextLocation = state.navigation.location || state.location;\r\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\r\n    let routesToUse = inFlightDataRoutes || dataRoutes;\r\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\r\n    invariant(matches, \"Didn't find any matches after fetcher action\");\r\n    let loadId = ++incrementingLoadId;\r\n    fetchReloadIds.set(key, loadId);\r\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\r\n    state.fetchers.set(key, loadFetcher);\r\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);\r\n    // Put all revalidating fetchers into the loading state, except for the\r\n    // current fetcher which we want to keep in it's current loading state which\r\n    // contains it's action submission info + action data\r\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\r\n      let staleKey = rf.key;\r\n      let existingFetcher = state.fetchers.get(staleKey);\r\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\r\n      state.fetchers.set(staleKey, revalidatingFetcher);\r\n      abortFetcher(staleKey);\r\n      if (rf.controller) {\r\n        fetchControllers.set(staleKey, rf.controller);\r\n      }\r\n    });\r\n    updateState({\r\n      fetchers: new Map(state.fetchers)\r\n    });\r\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\r\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\r\n    let {\r\n      loaderResults,\r\n      fetcherResults\r\n    } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\r\n    if (abortController.signal.aborted) {\r\n      return;\r\n    }\r\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\r\n    fetchReloadIds.delete(key);\r\n    fetchControllers.delete(key);\r\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\r\n    let redirect = findRedirect(loaderResults);\r\n    if (redirect) {\r\n      return startRedirectNavigation(revalidationRequest, redirect.result, false, {\r\n        preventScrollReset\r\n      });\r\n    }\r\n    redirect = findRedirect(fetcherResults);\r\n    if (redirect) {\r\n      // If this redirect came from a fetcher make sure we mark it in\r\n      // fetchRedirectIds so it doesn't get revalidated on the next set of\r\n      // loader executions\r\n      fetchRedirectIds.add(redirect.key);\r\n      return startRedirectNavigation(revalidationRequest, redirect.result, false, {\r\n        preventScrollReset\r\n      });\r\n    }\r\n    // Process and commit output from loaders\r\n    let {\r\n      loaderData,\r\n      errors\r\n    } = processLoaderData(state, matches, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\r\n    // Since we let revalidations complete even if the submitting fetcher was\r\n    // deleted, only put it back to idle if it hasn't been deleted\r\n    if (state.fetchers.has(key)) {\r\n      let doneFetcher = getDoneFetcher(actionResult.data);\r\n      state.fetchers.set(key, doneFetcher);\r\n    }\r\n    abortStaleFetchLoads(loadId);\r\n    // If we are currently in a navigation loading state and this fetcher is\r\n    // more recent than the navigation, we want the newer data so abort the\r\n    // navigation and complete it with the fetcher data\r\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\r\n      invariant(pendingAction, \"Expected pending action\");\r\n      pendingNavigationController && pendingNavigationController.abort();\r\n      completeNavigation(state.navigation.location, {\r\n        matches,\r\n        loaderData,\r\n        errors,\r\n        fetchers: new Map(state.fetchers)\r\n      });\r\n    } else {\r\n      // otherwise just update with the fetcher data, preserving any existing\r\n      // loaderData for loaders that did not need to reload.  We have to\r\n      // manually merge here since we aren't going through completeNavigation\r\n      updateState({\r\n        errors,\r\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\r\n        fetchers: new Map(state.fetchers)\r\n      });\r\n      isRevalidationRequired = false;\r\n    }\r\n  }\r\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\r\n  async function handleFetcherLoader(key, routeId, path, match, matches, isFogOfWar, flushSync, preventScrollReset, submission) {\r\n    let existingFetcher = state.fetchers.get(key);\r\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\r\n      flushSync\r\n    });\r\n    let abortController = new AbortController();\r\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\r\n    if (isFogOfWar) {\r\n      let discoverResult = await discoverRoutes(matches, path, fetchRequest.signal);\r\n      if (discoverResult.type === \"aborted\") {\r\n        return;\r\n      } else if (discoverResult.type === \"error\") {\r\n        setFetcherError(key, routeId, discoverResult.error, {\r\n          flushSync\r\n        });\r\n        return;\r\n      } else if (!discoverResult.matches) {\r\n        setFetcherError(key, routeId, getInternalRouterError(404, {\r\n          pathname: path\r\n        }), {\r\n          flushSync\r\n        });\r\n        return;\r\n      } else {\r\n        matches = discoverResult.matches;\r\n        match = getTargetMatch(matches, path);\r\n      }\r\n    }\r\n    // Call the loader for this fetcher route match\r\n    fetchControllers.set(key, abortController);\r\n    let originatingLoadId = incrementingLoadId;\r\n    let results = await callDataStrategy(\"loader\", state, fetchRequest, [match], matches, key);\r\n    let result = results[match.route.id];\r\n    // Deferred isn't supported for fetcher loads, await everything and treat it\r\n    // as a normal load.  resolveDeferredData will return undefined if this\r\n    // fetcher gets aborted, so we just leave result untouched and short circuit\r\n    // below if that happens\r\n    if (isDeferredResult(result)) {\r\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\r\n    }\r\n    // We can delete this so long as we weren't aborted by our our own fetcher\r\n    // re-load which would have put _new_ controller is in fetchControllers\r\n    if (fetchControllers.get(key) === abortController) {\r\n      fetchControllers.delete(key);\r\n    }\r\n    if (fetchRequest.signal.aborted) {\r\n      return;\r\n    }\r\n    // We don't want errors bubbling up or redirects followed for unmounted\r\n    // fetchers, so short circuit here if it was removed from the UI\r\n    if (deletedFetchers.has(key)) {\r\n      updateFetcherState(key, getDoneFetcher(undefined));\r\n      return;\r\n    }\r\n    // If the loader threw a redirect Response, start a new REPLACE navigation\r\n    if (isRedirectResult(result)) {\r\n      if (pendingNavigationLoadId > originatingLoadId) {\r\n        // A new navigation was kicked off after our loader started, so that\r\n        // should take precedence over this redirect navigation\r\n        updateFetcherState(key, getDoneFetcher(undefined));\r\n        return;\r\n      } else {\r\n        fetchRedirectIds.add(key);\r\n        await startRedirectNavigation(fetchRequest, result, false, {\r\n          preventScrollReset\r\n        });\r\n        return;\r\n      }\r\n    }\r\n    // Process any non-redirect errors thrown\r\n    if (isErrorResult(result)) {\r\n      setFetcherError(key, routeId, result.error);\r\n      return;\r\n    }\r\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\r\n    // Put the fetcher back into an idle state\r\n    updateFetcherState(key, getDoneFetcher(result.data));\r\n  }\r\n  /**\r\n   * Utility function to handle redirects returned from an action or loader.\r\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\r\n   * example:\r\n   *\r\n   *  - user is on /a\r\n   *  - user clicks a link to /b\r\n   *  - loader for /b redirects to /c\r\n   *\r\n   * In a non-JS app the browser would track the in-flight navigation to /b and\r\n   * then replace it with /c when it encountered the redirect response.  In\r\n   * the end it would only ever update the URL bar with /c.\r\n   *\r\n   * In client-side routing using pushState/replaceState, we aim to emulate\r\n   * this behavior and we also do not update history until the end of the\r\n   * navigation (including processed redirects).  This means that we never\r\n   * actually touch history until we've processed redirects, so we just use\r\n   * the history action from the original navigation (PUSH or REPLACE).\r\n   */\r\n  async function startRedirectNavigation(request, redirect, isNavigation, _temp2) {\r\n    let {\r\n      submission,\r\n      fetcherSubmission,\r\n      preventScrollReset,\r\n      replace\r\n    } = _temp2 === void 0 ? {} : _temp2;\r\n    if (redirect.response.headers.has(\"X-Remix-Revalidate\")) {\r\n      isRevalidationRequired = true;\r\n    }\r\n    let location = redirect.response.headers.get(\"Location\");\r\n    invariant(location, \"Expected a Location header on the redirect Response\");\r\n    location = normalizeRedirectLocation(location, new URL(request.url), basename);\r\n    let redirectLocation = createLocation(state.location, location, {\r\n      _isRedirect: true\r\n    });\r\n    if (isBrowser) {\r\n      let isDocumentReload = false;\r\n      if (redirect.response.headers.has(\"X-Remix-Reload-Document\")) {\r\n        // Hard reload if the response contained X-Remix-Reload-Document\r\n        isDocumentReload = true;\r\n      } else if (ABSOLUTE_URL_REGEX.test(location)) {\r\n        const url = init.history.createURL(location);\r\n        isDocumentReload =\r\n        // Hard reload if it's an absolute URL to a new origin\r\n        url.origin !== routerWindow.location.origin ||\r\n        // Hard reload if it's an absolute URL that does not match our basename\r\n        stripBasename(url.pathname, basename) == null;\r\n      }\r\n      if (isDocumentReload) {\r\n        if (replace) {\r\n          routerWindow.location.replace(location);\r\n        } else {\r\n          routerWindow.location.assign(location);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    // There's no need to abort on redirects, since we don't detect the\r\n    // redirect until the action/loaders have settled\r\n    pendingNavigationController = null;\r\n    let redirectHistoryAction = replace === true || redirect.response.headers.has(\"X-Remix-Replace\") ? Action.Replace : Action.Push;\r\n    // Use the incoming submission if provided, fallback on the active one in\r\n    // state.navigation\r\n    let {\r\n      formMethod,\r\n      formAction,\r\n      formEncType\r\n    } = state.navigation;\r\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\r\n      submission = getSubmissionFromNavigation(state.navigation);\r\n    }\r\n    // If this was a 307/308 submission we want to preserve the HTTP method and\r\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\r\n    // redirected location\r\n    let activeSubmission = submission || fetcherSubmission;\r\n    if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\r\n      await startNavigation(redirectHistoryAction, redirectLocation, {\r\n        submission: _extends({}, activeSubmission, {\r\n          formAction: location\r\n        }),\r\n        // Preserve these flags across redirects\r\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\r\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : undefined\r\n      });\r\n    } else {\r\n      // If we have a navigation submission, we will preserve it through the\r\n      // redirect navigation\r\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\r\n      await startNavigation(redirectHistoryAction, redirectLocation, {\r\n        overrideNavigation,\r\n        // Send fetcher submissions through for shouldRevalidate\r\n        fetcherSubmission,\r\n        // Preserve these flags across redirects\r\n        preventScrollReset: preventScrollReset || pendingPreventScrollReset,\r\n        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : undefined\r\n      });\r\n    }\r\n  }\r\n  // Utility wrapper for calling dataStrategy client-side without having to\r\n  // pass around the manifest, mapRouteProperties, etc.\r\n  async function callDataStrategy(type, state, request, matchesToLoad, matches, fetcherKey) {\r\n    let results;\r\n    let dataResults = {};\r\n    try {\r\n      results = await callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties);\r\n    } catch (e) {\r\n      // If the outer dataStrategy method throws, just return the error for all\r\n      // matches - and it'll naturally bubble to the root\r\n      matchesToLoad.forEach(m => {\r\n        dataResults[m.route.id] = {\r\n          type: ResultType.error,\r\n          error: e\r\n        };\r\n      });\r\n      return dataResults;\r\n    }\r\n    for (let [routeId, result] of Object.entries(results)) {\r\n      if (isRedirectDataStrategyResultResult(result)) {\r\n        let response = result.result;\r\n        dataResults[routeId] = {\r\n          type: ResultType.redirect,\r\n          response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, future.v7_relativeSplatPath)\r\n        };\r\n      } else {\r\n        dataResults[routeId] = await convertDataStrategyResultToDataResult(result);\r\n      }\r\n    }\r\n    return dataResults;\r\n  }\r\n  async function callLoadersAndMaybeResolveData(state, matches, matchesToLoad, fetchersToLoad, request) {\r\n    let currentMatches = state.matches;\r\n    // Kick off loaders and fetchers in parallel\r\n    let loaderResultsPromise = callDataStrategy(\"loader\", state, request, matchesToLoad, matches, null);\r\n    let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async f => {\r\n      if (f.matches && f.match && f.controller) {\r\n        let results = await callDataStrategy(\"loader\", state, createClientSideRequest(init.history, f.path, f.controller.signal), [f.match], f.matches, f.key);\r\n        let result = results[f.match.route.id];\r\n        // Fetcher results are keyed by fetcher key from here on out, not routeId\r\n        return {\r\n          [f.key]: result\r\n        };\r\n      } else {\r\n        return Promise.resolve({\r\n          [f.key]: {\r\n            type: ResultType.error,\r\n            error: getInternalRouterError(404, {\r\n              pathname: f.path\r\n            })\r\n          }\r\n        });\r\n      }\r\n    }));\r\n    let loaderResults = await loaderResultsPromise;\r\n    let fetcherResults = (await fetcherResultsPromise).reduce((acc, r) => Object.assign(acc, r), {});\r\n    await Promise.all([resolveNavigationDeferredResults(matches, loaderResults, request.signal, currentMatches, state.loaderData), resolveFetcherDeferredResults(matches, fetcherResults, fetchersToLoad)]);\r\n    return {\r\n      loaderResults,\r\n      fetcherResults\r\n    };\r\n  }\r\n  function interruptActiveLoads() {\r\n    // Every interruption triggers a revalidation\r\n    isRevalidationRequired = true;\r\n    // Cancel pending route-level deferreds and mark cancelled routes for\r\n    // revalidation\r\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\r\n    // Abort in-flight fetcher loads\r\n    fetchLoadMatches.forEach((_, key) => {\r\n      if (fetchControllers.has(key)) {\r\n        cancelledFetcherLoads.add(key);\r\n      }\r\n      abortFetcher(key);\r\n    });\r\n  }\r\n  function updateFetcherState(key, fetcher, opts) {\r\n    if (opts === void 0) {\r\n      opts = {};\r\n    }\r\n    state.fetchers.set(key, fetcher);\r\n    updateState({\r\n      fetchers: new Map(state.fetchers)\r\n    }, {\r\n      flushSync: (opts && opts.flushSync) === true\r\n    });\r\n  }\r\n  function setFetcherError(key, routeId, error, opts) {\r\n    if (opts === void 0) {\r\n      opts = {};\r\n    }\r\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\r\n    deleteFetcher(key);\r\n    updateState({\r\n      errors: {\r\n        [boundaryMatch.route.id]: error\r\n      },\r\n      fetchers: new Map(state.fetchers)\r\n    }, {\r\n      flushSync: (opts && opts.flushSync) === true\r\n    });\r\n  }\r\n  function getFetcher(key) {\r\n    if (future.v7_fetcherPersist) {\r\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\r\n      // If this fetcher was previously marked for deletion, unmark it since we\r\n      // have a new instance\r\n      if (deletedFetchers.has(key)) {\r\n        deletedFetchers.delete(key);\r\n      }\r\n    }\r\n    return state.fetchers.get(key) || IDLE_FETCHER;\r\n  }\r\n  function deleteFetcher(key) {\r\n    let fetcher = state.fetchers.get(key);\r\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\r\n    // in it's loading phase since - we don't want to abort the corresponding\r\n    // revalidation and want them to complete and land\r\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\r\n      abortFetcher(key);\r\n    }\r\n    fetchLoadMatches.delete(key);\r\n    fetchReloadIds.delete(key);\r\n    fetchRedirectIds.delete(key);\r\n    deletedFetchers.delete(key);\r\n    cancelledFetcherLoads.delete(key);\r\n    state.fetchers.delete(key);\r\n  }\r\n  function deleteFetcherAndUpdateState(key) {\r\n    if (future.v7_fetcherPersist) {\r\n      let count = (activeFetchers.get(key) || 0) - 1;\r\n      if (count <= 0) {\r\n        activeFetchers.delete(key);\r\n        deletedFetchers.add(key);\r\n      } else {\r\n        activeFetchers.set(key, count);\r\n      }\r\n    } else {\r\n      deleteFetcher(key);\r\n    }\r\n    updateState({\r\n      fetchers: new Map(state.fetchers)\r\n    });\r\n  }\r\n  function abortFetcher(key) {\r\n    let controller = fetchControllers.get(key);\r\n    if (controller) {\r\n      controller.abort();\r\n      fetchControllers.delete(key);\r\n    }\r\n  }\r\n  function markFetchersDone(keys) {\r\n    for (let key of keys) {\r\n      let fetcher = getFetcher(key);\r\n      let doneFetcher = getDoneFetcher(fetcher.data);\r\n      state.fetchers.set(key, doneFetcher);\r\n    }\r\n  }\r\n  function markFetchRedirectsDone() {\r\n    let doneKeys = [];\r\n    let updatedFetchers = false;\r\n    for (let key of fetchRedirectIds) {\r\n      let fetcher = state.fetchers.get(key);\r\n      invariant(fetcher, \"Expected fetcher: \" + key);\r\n      if (fetcher.state === \"loading\") {\r\n        fetchRedirectIds.delete(key);\r\n        doneKeys.push(key);\r\n        updatedFetchers = true;\r\n      }\r\n    }\r\n    markFetchersDone(doneKeys);\r\n    return updatedFetchers;\r\n  }\r\n  function abortStaleFetchLoads(landedId) {\r\n    let yeetedKeys = [];\r\n    for (let [key, id] of fetchReloadIds) {\r\n      if (id < landedId) {\r\n        let fetcher = state.fetchers.get(key);\r\n        invariant(fetcher, \"Expected fetcher: \" + key);\r\n        if (fetcher.state === \"loading\") {\r\n          abortFetcher(key);\r\n          fetchReloadIds.delete(key);\r\n          yeetedKeys.push(key);\r\n        }\r\n      }\r\n    }\r\n    markFetchersDone(yeetedKeys);\r\n    return yeetedKeys.length > 0;\r\n  }\r\n  function getBlocker(key, fn) {\r\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\r\n    if (blockerFunctions.get(key) !== fn) {\r\n      blockerFunctions.set(key, fn);\r\n    }\r\n    return blocker;\r\n  }\r\n  function deleteBlocker(key) {\r\n    state.blockers.delete(key);\r\n    blockerFunctions.delete(key);\r\n  }\r\n  // Utility function to update blockers, ensuring valid state transitions\r\n  function updateBlocker(key, newBlocker) {\r\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\r\n    // Poor mans state machine :)\r\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\r\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\r\n    let blockers = new Map(state.blockers);\r\n    blockers.set(key, newBlocker);\r\n    updateState({\r\n      blockers\r\n    });\r\n  }\r\n  function shouldBlockNavigation(_ref2) {\r\n    let {\r\n      currentLocation,\r\n      nextLocation,\r\n      historyAction\r\n    } = _ref2;\r\n    if (blockerFunctions.size === 0) {\r\n      return;\r\n    }\r\n    // We ony support a single active blocker at the moment since we don't have\r\n    // any compelling use cases for multi-blocker yet\r\n    if (blockerFunctions.size > 1) {\r\n      warning(false, \"A router only supports one blocker at a time\");\r\n    }\r\n    let entries = Array.from(blockerFunctions.entries());\r\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\r\n    let blocker = state.blockers.get(blockerKey);\r\n    if (blocker && blocker.state === \"proceeding\") {\r\n      // If the blocker is currently proceeding, we don't need to re-check\r\n      // it and can let this navigation continue\r\n      return;\r\n    }\r\n    // At this point, we know we're unblocked/blocked so we need to check the\r\n    // user-provided blocker function\r\n    if (blockerFunction({\r\n      currentLocation,\r\n      nextLocation,\r\n      historyAction\r\n    })) {\r\n      return blockerKey;\r\n    }\r\n  }\r\n  function handleNavigational404(pathname) {\r\n    let error = getInternalRouterError(404, {\r\n      pathname\r\n    });\r\n    let routesToUse = inFlightDataRoutes || dataRoutes;\r\n    let {\r\n      matches,\r\n      route\r\n    } = getShortCircuitMatches(routesToUse);\r\n    // Cancel all pending deferred on 404s since we don't keep any routes\r\n    cancelActiveDeferreds();\r\n    return {\r\n      notFoundMatches: matches,\r\n      route,\r\n      error\r\n    };\r\n  }\r\n  function cancelActiveDeferreds(predicate) {\r\n    let cancelledRouteIds = [];\r\n    activeDeferreds.forEach((dfd, routeId) => {\r\n      if (!predicate || predicate(routeId)) {\r\n        // Cancel the deferred - but do not remove from activeDeferreds here -\r\n        // we rely on the subscribers to do that so our tests can assert proper\r\n        // cleanup via _internalActiveDeferreds\r\n        dfd.cancel();\r\n        cancelledRouteIds.push(routeId);\r\n        activeDeferreds.delete(routeId);\r\n      }\r\n    });\r\n    return cancelledRouteIds;\r\n  }\r\n  // Opt in to capturing and reporting scroll positions during navigations,\r\n  // used by the <ScrollRestoration> component\r\n  function enableScrollRestoration(positions, getPosition, getKey) {\r\n    savedScrollPositions = positions;\r\n    getScrollPosition = getPosition;\r\n    getScrollRestorationKey = getKey || null;\r\n    // Perform initial hydration scroll restoration, since we miss the boat on\r\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\r\n    // and therefore have no savedScrollPositions available\r\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\r\n      initialScrollRestored = true;\r\n      let y = getSavedScrollPosition(state.location, state.matches);\r\n      if (y != null) {\r\n        updateState({\r\n          restoreScrollPosition: y\r\n        });\r\n      }\r\n    }\r\n    return () => {\r\n      savedScrollPositions = null;\r\n      getScrollPosition = null;\r\n      getScrollRestorationKey = null;\r\n    };\r\n  }\r\n  function getScrollKey(location, matches) {\r\n    if (getScrollRestorationKey) {\r\n      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));\r\n      return key || location.key;\r\n    }\r\n    return location.key;\r\n  }\r\n  function saveScrollPosition(location, matches) {\r\n    if (savedScrollPositions && getScrollPosition) {\r\n      let key = getScrollKey(location, matches);\r\n      savedScrollPositions[key] = getScrollPosition();\r\n    }\r\n  }\r\n  function getSavedScrollPosition(location, matches) {\r\n    if (savedScrollPositions) {\r\n      let key = getScrollKey(location, matches);\r\n      let y = savedScrollPositions[key];\r\n      if (typeof y === \"number\") {\r\n        return y;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  function checkFogOfWar(matches, routesToUse, pathname) {\r\n    if (patchRoutesOnNavigationImpl) {\r\n      if (!matches) {\r\n        let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\r\n        return {\r\n          active: true,\r\n          matches: fogMatches || []\r\n        };\r\n      } else {\r\n        if (Object.keys(matches[0].params).length > 0) {\r\n          // If we matched a dynamic param or a splat, it might only be because\r\n          // we haven't yet discovered other routes that would match with a\r\n          // higher score.  Call patchRoutesOnNavigation just to be sure\r\n          let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\r\n          return {\r\n            active: true,\r\n            matches: partialMatches\r\n          };\r\n        }\r\n      }\r\n    }\r\n    return {\r\n      active: false,\r\n      matches: null\r\n    };\r\n  }\r\n  async function discoverRoutes(matches, pathname, signal) {\r\n    if (!patchRoutesOnNavigationImpl) {\r\n      return {\r\n        type: \"success\",\r\n        matches\r\n      };\r\n    }\r\n    let partialMatches = matches;\r\n    while (true) {\r\n      let isNonHMR = inFlightDataRoutes == null;\r\n      let routesToUse = inFlightDataRoutes || dataRoutes;\r\n      let localManifest = manifest;\r\n      try {\r\n        await patchRoutesOnNavigationImpl({\r\n          path: pathname,\r\n          matches: partialMatches,\r\n          patch: (routeId, children) => {\r\n            if (signal.aborted) return;\r\n            patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties);\r\n          }\r\n        });\r\n      } catch (e) {\r\n        return {\r\n          type: \"error\",\r\n          error: e,\r\n          partialMatches\r\n        };\r\n      } finally {\r\n        // If we are not in the middle of an HMR revalidation and we changed the\r\n        // routes, provide a new identity so when we `updateState` at the end of\r\n        // this navigation/fetch `router.routes` will be a new identity and\r\n        // trigger a re-run of memoized `router.routes` dependencies.\r\n        // HMR will already update the identity and reflow when it lands\r\n        // `inFlightDataRoutes` in `completeNavigation`\r\n        if (isNonHMR && !signal.aborted) {\r\n          dataRoutes = [...dataRoutes];\r\n        }\r\n      }\r\n      if (signal.aborted) {\r\n        return {\r\n          type: \"aborted\"\r\n        };\r\n      }\r\n      let newMatches = matchRoutes(routesToUse, pathname, basename);\r\n      if (newMatches) {\r\n        return {\r\n          type: \"success\",\r\n          matches: newMatches\r\n        };\r\n      }\r\n      let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\r\n      // Avoid loops if the second pass results in the same partial matches\r\n      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i) => m.route.id === newPartialMatches[i].route.id)) {\r\n        return {\r\n          type: \"success\",\r\n          matches: null\r\n        };\r\n      }\r\n      partialMatches = newPartialMatches;\r\n    }\r\n  }\r\n  function _internalSetRoutes(newRoutes) {\r\n    manifest = {};\r\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\r\n  }\r\n  function patchRoutes(routeId, children) {\r\n    let isNonHMR = inFlightDataRoutes == null;\r\n    let routesToUse = inFlightDataRoutes || dataRoutes;\r\n    patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties);\r\n    // If we are not in the middle of an HMR revalidation and we changed the\r\n    // routes, provide a new identity and trigger a reflow via `updateState`\r\n    // to re-run memoized `router.routes` dependencies.\r\n    // HMR will already update the identity and reflow when it lands\r\n    // `inFlightDataRoutes` in `completeNavigation`\r\n    if (isNonHMR) {\r\n      dataRoutes = [...dataRoutes];\r\n      updateState({});\r\n    }\r\n  }\r\n  router = {\r\n    get basename() {\r\n      return basename;\r\n    },\r\n    get future() {\r\n      return future;\r\n    },\r\n    get state() {\r\n      return state;\r\n    },\r\n    get routes() {\r\n      return dataRoutes;\r\n    },\r\n    get window() {\r\n      return routerWindow;\r\n    },\r\n    initialize,\r\n    subscribe,\r\n    enableScrollRestoration,\r\n    navigate,\r\n    fetch,\r\n    revalidate,\r\n    // Passthrough to history-aware createHref used by useHref so we get proper\r\n    // hash-aware URLs in DOM paths\r\n    createHref: to => init.history.createHref(to),\r\n    encodeLocation: to => init.history.encodeLocation(to),\r\n    getFetcher,\r\n    deleteFetcher: deleteFetcherAndUpdateState,\r\n    dispose,\r\n    getBlocker,\r\n    deleteBlocker,\r\n    patchRoutes,\r\n    _internalFetchControllers: fetchControllers,\r\n    _internalActiveDeferreds: activeDeferreds,\r\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\r\n    // updating the tree while validating the update algorithm.\r\n    _internalSetRoutes\r\n  };\r\n  return router;\r\n}\r\n//#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region createStaticHandler\r\n////////////////////////////////////////////////////////////////////////////////\r\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\r\nfunction createStaticHandler(routes, opts) {\r\n  invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\r\n  let manifest = {};\r\n  let basename = (opts ? opts.basename : null) || \"/\";\r\n  let mapRouteProperties;\r\n  if (opts != null && opts.mapRouteProperties) {\r\n    mapRouteProperties = opts.mapRouteProperties;\r\n  } else if (opts != null && opts.detectErrorBoundary) {\r\n    // If they are still using the deprecated version, wrap it with the new API\r\n    let detectErrorBoundary = opts.detectErrorBoundary;\r\n    mapRouteProperties = route => ({\r\n      hasErrorBoundary: detectErrorBoundary(route)\r\n    });\r\n  } else {\r\n    mapRouteProperties = defaultMapRouteProperties;\r\n  }\r\n  // Config driven behavior flags\r\n  let future = _extends({\r\n    v7_relativeSplatPath: false,\r\n    v7_throwAbortReason: false\r\n  }, opts ? opts.future : null);\r\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\r\n  /**\r\n   * The query() method is intended for document requests, in which we want to\r\n   * call an optional action and potentially multiple loaders for all nested\r\n   * routes.  It returns a StaticHandlerContext object, which is very similar\r\n   * to the router state (location, loaderData, actionData, errors, etc.) and\r\n   * also adds SSR-specific information such as the statusCode and headers\r\n   * from action/loaders Responses.\r\n   *\r\n   * It _should_ never throw and should report all errors through the\r\n   * returned context.errors object, properly associating errors to their error\r\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\r\n   * used to emulate React error boundaries during SSr by performing a second\r\n   * pass only down to the boundaryId.\r\n   *\r\n   * The one exception where we do not return a StaticHandlerContext is when a\r\n   * redirect response is returned or thrown from any action/loader.  We\r\n   * propagate that out and return the raw Response so the HTTP server can\r\n   * return it directly.\r\n   *\r\n   * - `opts.requestContext` is an optional server context that will be passed\r\n   *   to actions/loaders in the `context` parameter\r\n   * - `opts.skipLoaderErrorBubbling` is an optional parameter that will prevent\r\n   *   the bubbling of errors which allows single-fetch-type implementations\r\n   *   where the client will handle the bubbling and we may need to return data\r\n   *   for the handling route\r\n   */\r\n  async function query(request, _temp3) {\r\n    let {\r\n      requestContext,\r\n      skipLoaderErrorBubbling,\r\n      dataStrategy\r\n    } = _temp3 === void 0 ? {} : _temp3;\r\n    let url = new URL(request.url);\r\n    let method = request.method;\r\n    let location = createLocation(\"\", createPath(url), null, \"default\");\r\n    let matches = matchRoutes(dataRoutes, location, basename);\r\n    // SSR supports HEAD requests while SPA doesn't\r\n    if (!isValidMethod(method) && method !== \"HEAD\") {\r\n      let error = getInternalRouterError(405, {\r\n        method\r\n      });\r\n      let {\r\n        matches: methodNotAllowedMatches,\r\n        route\r\n      } = getShortCircuitMatches(dataRoutes);\r\n      return {\r\n        basename,\r\n        location,\r\n        matches: methodNotAllowedMatches,\r\n        loaderData: {},\r\n        actionData: null,\r\n        errors: {\r\n          [route.id]: error\r\n        },\r\n        statusCode: error.status,\r\n        loaderHeaders: {},\r\n        actionHeaders: {},\r\n        activeDeferreds: null\r\n      };\r\n    } else if (!matches) {\r\n      let error = getInternalRouterError(404, {\r\n        pathname: location.pathname\r\n      });\r\n      let {\r\n        matches: notFoundMatches,\r\n        route\r\n      } = getShortCircuitMatches(dataRoutes);\r\n      return {\r\n        basename,\r\n        location,\r\n        matches: notFoundMatches,\r\n        loaderData: {},\r\n        actionData: null,\r\n        errors: {\r\n          [route.id]: error\r\n        },\r\n        statusCode: error.status,\r\n        loaderHeaders: {},\r\n        actionHeaders: {},\r\n        activeDeferreds: null\r\n      };\r\n    }\r\n    let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null);\r\n    if (isResponse(result)) {\r\n      return result;\r\n    }\r\n    // When returning StaticHandlerContext, we patch back in the location here\r\n    // since we need it for React Context.  But this helps keep our submit and\r\n    // loadRouteData operating on a Request instead of a Location\r\n    return _extends({\r\n      location,\r\n      basename\r\n    }, result);\r\n  }\r\n  /**\r\n   * The queryRoute() method is intended for targeted route requests, either\r\n   * for fetch ?_data requests or resource route requests.  In this case, we\r\n   * are only ever calling a single action or loader, and we are returning the\r\n   * returned value directly.  In most cases, this will be a Response returned\r\n   * from the action/loader, but it may be a primitive or other value as well -\r\n   * and in such cases the calling context should handle that accordingly.\r\n   *\r\n   * We do respect the throw/return differentiation, so if an action/loader\r\n   * throws, then this method will throw the value.  This is important so we\r\n   * can do proper boundary identification in Remix where a thrown Response\r\n   * must go to the Catch Boundary but a returned Response is happy-path.\r\n   *\r\n   * One thing to note is that any Router-initiated Errors that make sense\r\n   * to associate with a status code will be thrown as an ErrorResponse\r\n   * instance which include the raw Error, such that the calling context can\r\n   * serialize the error as they see fit while including the proper response\r\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\r\n   * any user-defined loaders.\r\n   *\r\n   * - `opts.routeId` allows you to specify the specific route handler to call.\r\n   *   If not provided the handler will determine the proper route by matching\r\n   *   against `request.url`\r\n   * - `opts.requestContext` is an optional server context that will be passed\r\n   *    to actions/loaders in the `context` parameter\r\n   */\r\n  async function queryRoute(request, _temp4) {\r\n    let {\r\n      routeId,\r\n      requestContext,\r\n      dataStrategy\r\n    } = _temp4 === void 0 ? {} : _temp4;\r\n    let url = new URL(request.url);\r\n    let method = request.method;\r\n    let location = createLocation(\"\", createPath(url), null, \"default\");\r\n    let matches = matchRoutes(dataRoutes, location, basename);\r\n    // SSR supports HEAD requests while SPA doesn't\r\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\r\n      throw getInternalRouterError(405, {\r\n        method\r\n      });\r\n    } else if (!matches) {\r\n      throw getInternalRouterError(404, {\r\n        pathname: location.pathname\r\n      });\r\n    }\r\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\r\n    if (routeId && !match) {\r\n      throw getInternalRouterError(403, {\r\n        pathname: location.pathname,\r\n        routeId\r\n      });\r\n    } else if (!match) {\r\n      // This should never hit I don't think?\r\n      throw getInternalRouterError(404, {\r\n        pathname: location.pathname\r\n      });\r\n    }\r\n    let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match);\r\n    if (isResponse(result)) {\r\n      return result;\r\n    }\r\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\r\n    if (error !== undefined) {\r\n      // If we got back result.errors, that means the loader/action threw\r\n      // _something_ that wasn't a Response, but it's not guaranteed/required\r\n      // to be an `instanceof Error` either, so we have to use throw here to\r\n      // preserve the \"error\" state outside of queryImpl.\r\n      throw error;\r\n    }\r\n    // Pick off the right state value to return\r\n    if (result.actionData) {\r\n      return Object.values(result.actionData)[0];\r\n    }\r\n    if (result.loaderData) {\r\n      var _result$activeDeferre;\r\n      let data = Object.values(result.loaderData)[0];\r\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\r\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\r\n      }\r\n      return data;\r\n    }\r\n    return undefined;\r\n  }\r\n  async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch) {\r\n    invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\r\n    try {\r\n      if (isMutationMethod(request.method.toLowerCase())) {\r\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch != null);\r\n        return result;\r\n      }\r\n      let result = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch);\r\n      return isResponse(result) ? result : _extends({}, result, {\r\n        actionData: null,\r\n        actionHeaders: {}\r\n      });\r\n    } catch (e) {\r\n      // If the user threw/returned a Response in callLoaderOrAction for a\r\n      // `queryRoute` call, we throw the `DataStrategyResult` to bail out early\r\n      // and then return or throw the raw Response here accordingly\r\n      if (isDataStrategyResult(e) && isResponse(e.result)) {\r\n        if (e.type === ResultType.error) {\r\n          throw e.result;\r\n        }\r\n        return e.result;\r\n      }\r\n      // Redirects are always returned since they don't propagate to catch\r\n      // boundaries\r\n      if (isRedirectResponse(e)) {\r\n        return e;\r\n      }\r\n      throw e;\r\n    }\r\n  }\r\n  async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest) {\r\n    let result;\r\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\r\n      let error = getInternalRouterError(405, {\r\n        method: request.method,\r\n        pathname: new URL(request.url).pathname,\r\n        routeId: actionMatch.route.id\r\n      });\r\n      if (isRouteRequest) {\r\n        throw error;\r\n      }\r\n      result = {\r\n        type: ResultType.error,\r\n        error\r\n      };\r\n    } else {\r\n      let results = await callDataStrategy(\"action\", request, [actionMatch], matches, isRouteRequest, requestContext, dataStrategy);\r\n      result = results[actionMatch.route.id];\r\n      if (request.signal.aborted) {\r\n        throwStaticHandlerAbortedError(request, isRouteRequest, future);\r\n      }\r\n    }\r\n    if (isRedirectResult(result)) {\r\n      // Uhhhh - this should never happen, we should always throw these from\r\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\r\n      // can get back on the \"throw all redirect responses\" train here should\r\n      // this ever happen :/\r\n      throw new Response(null, {\r\n        status: result.response.status,\r\n        headers: {\r\n          Location: result.response.headers.get(\"Location\")\r\n        }\r\n      });\r\n    }\r\n    if (isDeferredResult(result)) {\r\n      let error = getInternalRouterError(400, {\r\n        type: \"defer-action\"\r\n      });\r\n      if (isRouteRequest) {\r\n        throw error;\r\n      }\r\n      result = {\r\n        type: ResultType.error,\r\n        error\r\n      };\r\n    }\r\n    if (isRouteRequest) {\r\n      // Note: This should only be non-Response values if we get here, since\r\n      // isRouteRequest should throw any Response received in callLoaderOrAction\r\n      if (isErrorResult(result)) {\r\n        throw result.error;\r\n      }\r\n      return {\r\n        matches: [actionMatch],\r\n        loaderData: {},\r\n        actionData: {\r\n          [actionMatch.route.id]: result.data\r\n        },\r\n        errors: null,\r\n        // Note: statusCode + headers are unused here since queryRoute will\r\n        // return the raw Response or value\r\n        statusCode: 200,\r\n        loaderHeaders: {},\r\n        actionHeaders: {},\r\n        activeDeferreds: null\r\n      };\r\n    }\r\n    // Create a GET request for the loaders\r\n    let loaderRequest = new Request(request.url, {\r\n      headers: request.headers,\r\n      redirect: request.redirect,\r\n      signal: request.signal\r\n    });\r\n    if (isErrorResult(result)) {\r\n      // Store off the pending error - we use it to determine which loaders\r\n      // to call and will commit it when we complete the navigation\r\n      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\r\n      let context = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, [boundaryMatch.route.id, result]);\r\n      // action status codes take precedence over loader status codes\r\n      return _extends({}, context, {\r\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\r\n        actionData: null,\r\n        actionHeaders: _extends({}, result.headers ? {\r\n          [actionMatch.route.id]: result.headers\r\n        } : {})\r\n      });\r\n    }\r\n    let context = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null);\r\n    return _extends({}, context, {\r\n      actionData: {\r\n        [actionMatch.route.id]: result.data\r\n      }\r\n    }, result.statusCode ? {\r\n      statusCode: result.statusCode\r\n    } : {}, {\r\n      actionHeaders: result.headers ? {\r\n        [actionMatch.route.id]: result.headers\r\n      } : {}\r\n    });\r\n  }\r\n  async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, pendingActionResult) {\r\n    let isRouteRequest = routeMatch != null;\r\n    // Short circuit if we have no loaders to run (queryRoute())\r\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\r\n      throw getInternalRouterError(400, {\r\n        method: request.method,\r\n        pathname: new URL(request.url).pathname,\r\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\r\n      });\r\n    }\r\n    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;\r\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\r\n    // Short circuit if we have no loaders to run (query())\r\n    if (matchesToLoad.length === 0) {\r\n      return {\r\n        matches,\r\n        // Add a null for all matched routes for proper revalidation on the client\r\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\r\n          [m.route.id]: null\r\n        }), {}),\r\n        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\r\n          [pendingActionResult[0]]: pendingActionResult[1].error\r\n        } : null,\r\n        statusCode: 200,\r\n        loaderHeaders: {},\r\n        activeDeferreds: null\r\n      };\r\n    }\r\n    let results = await callDataStrategy(\"loader\", request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy);\r\n    if (request.signal.aborted) {\r\n      throwStaticHandlerAbortedError(request, isRouteRequest, future);\r\n    }\r\n    // Process and commit output from loaders\r\n    let activeDeferreds = new Map();\r\n    let context = processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling);\r\n    // Add a null for any non-loader matches for proper revalidation on the client\r\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\r\n    matches.forEach(match => {\r\n      if (!executedLoaders.has(match.route.id)) {\r\n        context.loaderData[match.route.id] = null;\r\n      }\r\n    });\r\n    return _extends({}, context, {\r\n      matches,\r\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\r\n    });\r\n  }\r\n  // Utility wrapper for calling dataStrategy server-side without having to\r\n  // pass around the manifest, mapRouteProperties, etc.\r\n  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy) {\r\n    let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, type, null, request, matchesToLoad, matches, null, manifest, mapRouteProperties, requestContext);\r\n    let dataResults = {};\r\n    await Promise.all(matches.map(async match => {\r\n      if (!(match.route.id in results)) {\r\n        return;\r\n      }\r\n      let result = results[match.route.id];\r\n      if (isRedirectDataStrategyResultResult(result)) {\r\n        let response = result.result;\r\n        // Throw redirects and let the server handle them with an HTTP redirect\r\n        throw normalizeRelativeRoutingRedirectResponse(response, request, match.route.id, matches, basename, future.v7_relativeSplatPath);\r\n      }\r\n      if (isResponse(result.result) && isRouteRequest) {\r\n        // For SSR single-route requests, we want to hand Responses back\r\n        // directly without unwrapping\r\n        throw result;\r\n      }\r\n      dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);\r\n    }));\r\n    return dataResults;\r\n  }\r\n  return {\r\n    dataRoutes,\r\n    query,\r\n    queryRoute\r\n  };\r\n}\r\n//#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region Helpers\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Given an existing StaticHandlerContext and an error thrown at render time,\r\n * provide an updated StaticHandlerContext suitable for a second SSR render\r\n */\r\nfunction getStaticContextFromError(routes, context, error) {\r\n  let newContext = _extends({}, context, {\r\n    statusCode: isRouteErrorResponse(error) ? error.status : 500,\r\n    errors: {\r\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\r\n    }\r\n  });\r\n  return newContext;\r\n}\r\nfunction throwStaticHandlerAbortedError(request, isRouteRequest, future) {\r\n  if (future.v7_throwAbortReason && request.signal.reason !== undefined) {\r\n    throw request.signal.reason;\r\n  }\r\n  let method = isRouteRequest ? \"queryRoute\" : \"query\";\r\n  throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\r\n}\r\nfunction isSubmissionNavigation(opts) {\r\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\r\n}\r\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\r\n  let contextualMatches;\r\n  let activeRouteMatch;\r\n  if (fromRouteId) {\r\n    // Grab matches up to the calling route so our route-relative logic is\r\n    // relative to the correct source route\r\n    contextualMatches = [];\r\n    for (let match of matches) {\r\n      contextualMatches.push(match);\r\n      if (match.route.id === fromRouteId) {\r\n        activeRouteMatch = match;\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    contextualMatches = matches;\r\n    activeRouteMatch = matches[matches.length - 1];\r\n  }\r\n  // Resolve the relative path\r\n  let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\r\n  // When `to` is not specified we inherit search/hash from the current\r\n  // location, unlike when to=\".\" and we just inherit the path.\r\n  // See https://github.com/remix-run/remix/issues/927\r\n  if (to == null) {\r\n    path.search = location.search;\r\n    path.hash = location.hash;\r\n  }\r\n  // Account for `?index` params when routing to the current location\r\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch) {\r\n    let nakedIndex = hasNakedIndexQuery(path.search);\r\n    if (activeRouteMatch.route.index && !nakedIndex) {\r\n      // Add one when we're targeting an index route\r\n      path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\r\n    } else if (!activeRouteMatch.route.index && nakedIndex) {\r\n      // Remove existing ones when we're not\r\n      let params = new URLSearchParams(path.search);\r\n      let indexValues = params.getAll(\"index\");\r\n      params.delete(\"index\");\r\n      indexValues.filter(v => v).forEach(v => params.append(\"index\", v));\r\n      let qs = params.toString();\r\n      path.search = qs ? \"?\" + qs : \"\";\r\n    }\r\n  }\r\n  // If we're operating within a basename, prepend it to the pathname.  If\r\n  // this is a root navigation, then just use the raw basename which allows\r\n  // the basename to have full control over the presence of a trailing slash\r\n  // on root actions\r\n  if (prependBasename && basename !== \"/\") {\r\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\r\n  }\r\n  return createPath(path);\r\n}\r\n// Normalize navigation options by converting formMethod=GET formData objects to\r\n// URLSearchParams so they behave identically to links with query params\r\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\r\n  // Return location verbatim on non-submission navigations\r\n  if (!opts || !isSubmissionNavigation(opts)) {\r\n    return {\r\n      path\r\n    };\r\n  }\r\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\r\n    return {\r\n      path,\r\n      error: getInternalRouterError(405, {\r\n        method: opts.formMethod\r\n      })\r\n    };\r\n  }\r\n  let getInvalidBodyError = () => ({\r\n    path,\r\n    error: getInternalRouterError(400, {\r\n      type: \"invalid-body\"\r\n    })\r\n  });\r\n  // Create a Submission on non-GET navigations\r\n  let rawFormMethod = opts.formMethod || \"get\";\r\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\r\n  let formAction = stripHashFromPath(path);\r\n  if (opts.body !== undefined) {\r\n    if (opts.formEncType === \"text/plain\") {\r\n      // text only support POST/PUT/PATCH/DELETE submissions\r\n      if (!isMutationMethod(formMethod)) {\r\n        return getInvalidBodyError();\r\n      }\r\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\r\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\r\n      Array.from(opts.body.entries()).reduce((acc, _ref3) => {\r\n        let [name, value] = _ref3;\r\n        return \"\" + acc + name + \"=\" + value + \"\\n\";\r\n      }, \"\") : String(opts.body);\r\n      return {\r\n        path,\r\n        submission: {\r\n          formMethod,\r\n          formAction,\r\n          formEncType: opts.formEncType,\r\n          formData: undefined,\r\n          json: undefined,\r\n          text\r\n        }\r\n      };\r\n    } else if (opts.formEncType === \"application/json\") {\r\n      // json only supports POST/PUT/PATCH/DELETE submissions\r\n      if (!isMutationMethod(formMethod)) {\r\n        return getInvalidBodyError();\r\n      }\r\n      try {\r\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\r\n        return {\r\n          path,\r\n          submission: {\r\n            formMethod,\r\n            formAction,\r\n            formEncType: opts.formEncType,\r\n            formData: undefined,\r\n            json,\r\n            text: undefined\r\n          }\r\n        };\r\n      } catch (e) {\r\n        return getInvalidBodyError();\r\n      }\r\n    }\r\n  }\r\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\r\n  let searchParams;\r\n  let formData;\r\n  if (opts.formData) {\r\n    searchParams = convertFormDataToSearchParams(opts.formData);\r\n    formData = opts.formData;\r\n  } else if (opts.body instanceof FormData) {\r\n    searchParams = convertFormDataToSearchParams(opts.body);\r\n    formData = opts.body;\r\n  } else if (opts.body instanceof URLSearchParams) {\r\n    searchParams = opts.body;\r\n    formData = convertSearchParamsToFormData(searchParams);\r\n  } else if (opts.body == null) {\r\n    searchParams = new URLSearchParams();\r\n    formData = new FormData();\r\n  } else {\r\n    try {\r\n      searchParams = new URLSearchParams(opts.body);\r\n      formData = convertSearchParamsToFormData(searchParams);\r\n    } catch (e) {\r\n      return getInvalidBodyError();\r\n    }\r\n  }\r\n  let submission = {\r\n    formMethod,\r\n    formAction,\r\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\r\n    formData,\r\n    json: undefined,\r\n    text: undefined\r\n  };\r\n  if (isMutationMethod(submission.formMethod)) {\r\n    return {\r\n      path,\r\n      submission\r\n    };\r\n  }\r\n  // Flatten submission onto URLSearchParams for GET submissions\r\n  let parsedPath = parsePath(path);\r\n  // On GET navigation submissions we can drop the ?index param from the\r\n  // resulting location since all loaders will run.  But fetcher GET submissions\r\n  // only run a single loader so we need to preserve any incoming ?index params\r\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\r\n    searchParams.append(\"index\", \"\");\r\n  }\r\n  parsedPath.search = \"?\" + searchParams;\r\n  return {\r\n    path: createPath(parsedPath),\r\n    submission\r\n  };\r\n}\r\n// Filter out all routes at/below any caught error as they aren't going to\r\n// render so we don't need to load them\r\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary) {\r\n  if (includeBoundary === void 0) {\r\n    includeBoundary = false;\r\n  }\r\n  let index = matches.findIndex(m => m.route.id === boundaryId);\r\n  if (index >= 0) {\r\n    return matches.slice(0, includeBoundary ? index + 1 : index);\r\n  }\r\n  return matches;\r\n}\r\nfunction getMatchesToLoad(history, state, matches, submission, location, initialHydration, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {\r\n  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : undefined;\r\n  let currentUrl = history.createURL(state.location);\r\n  let nextUrl = history.createURL(location);\r\n  // Pick navigation matches that are net-new or qualify for revalidation\r\n  let boundaryMatches = matches;\r\n  if (initialHydration && state.errors) {\r\n    // On initial hydration, only consider matches up to _and including_ the boundary.\r\n    // This is inclusive to handle cases where a server loader ran successfully,\r\n    // a child server loader bubbled up to this route, but this route has\r\n    // `clientLoader.hydrate` so we want to still run the `clientLoader` so that\r\n    // we have a complete version of `loaderData`\r\n    boundaryMatches = getLoaderMatchesUntilBoundary(matches, Object.keys(state.errors)[0], true);\r\n  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {\r\n    // If an action threw an error, we call loaders up to, but not including the\r\n    // boundary\r\n    boundaryMatches = getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]);\r\n  }\r\n  // Don't revalidate loaders by default after action 4xx/5xx responses\r\n  // when the flag is enabled.  They can still opt-into revalidation via\r\n  // `shouldRevalidate` via `actionResult`\r\n  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : undefined;\r\n  let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;\r\n  let navigationMatches = boundaryMatches.filter((match, index) => {\r\n    let {\r\n      route\r\n    } = match;\r\n    if (route.lazy) {\r\n      // We haven't loaded this route yet so we don't know if it's got a loader!\r\n      return true;\r\n    }\r\n    if (route.loader == null) {\r\n      return false;\r\n    }\r\n    if (initialHydration) {\r\n      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);\r\n    }\r\n    // Always call the loader on new route instances and pending defer cancellations\r\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\r\n      return true;\r\n    }\r\n    // This is the default implementation for when we revalidate.  If the route\r\n    // provides it's own implementation, then we give them full control but\r\n    // provide this value so they can leverage it if needed after they check\r\n    // their own specific use cases\r\n    let currentRouteMatch = state.matches[index];\r\n    let nextRouteMatch = match;\r\n    return shouldRevalidateLoader(match, _extends({\r\n      currentUrl,\r\n      currentParams: currentRouteMatch.params,\r\n      nextUrl,\r\n      nextParams: nextRouteMatch.params\r\n    }, submission, {\r\n      actionResult,\r\n      actionStatus,\r\n      defaultShouldRevalidate: shouldSkipRevalidation ? false :\r\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\r\n      isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\r\n      // Search params affect all loaders\r\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\r\n    }));\r\n  });\r\n  // Pick fetcher.loads that need to be revalidated\r\n  let revalidatingFetchers = [];\r\n  fetchLoadMatches.forEach((f, key) => {\r\n    // Don't revalidate:\r\n    //  - on initial hydration (shouldn't be any fetchers then anyway)\r\n    //  - if fetcher won't be present in the subsequent render\r\n    //    - no longer matches the URL (v7_fetcherPersist=false)\r\n    //    - was unmounted but persisted due to v7_fetcherPersist=true\r\n    if (initialHydration || !matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {\r\n      return;\r\n    }\r\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\r\n    // If the fetcher path no longer matches, push it in with null matches so\r\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\r\n    // currently only a use-case for Remix HMR where the route tree can change\r\n    // at runtime and remove a route previously loaded via a fetcher\r\n    if (!fetcherMatches) {\r\n      revalidatingFetchers.push({\r\n        key,\r\n        routeId: f.routeId,\r\n        path: f.path,\r\n        matches: null,\r\n        match: null,\r\n        controller: null\r\n      });\r\n      return;\r\n    }\r\n    // Revalidating fetchers are decoupled from the route matches since they\r\n    // load from a static href.  They revalidate based on explicit revalidation\r\n    // (submission, useRevalidator, or X-Remix-Revalidate)\r\n    let fetcher = state.fetchers.get(key);\r\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\r\n    let shouldRevalidate = false;\r\n    if (fetchRedirectIds.has(key)) {\r\n      // Never trigger a revalidation of an actively redirecting fetcher\r\n      shouldRevalidate = false;\r\n    } else if (cancelledFetcherLoads.has(key)) {\r\n      // Always mark for revalidation if the fetcher was cancelled\r\n      cancelledFetcherLoads.delete(key);\r\n      shouldRevalidate = true;\r\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\r\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\r\n      // revalidation, it would just be a brand new load if an explicit\r\n      // revalidation is required\r\n      shouldRevalidate = isRevalidationRequired;\r\n    } else {\r\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\r\n      // to explicit revalidations only\r\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\r\n        currentUrl,\r\n        currentParams: state.matches[state.matches.length - 1].params,\r\n        nextUrl,\r\n        nextParams: matches[matches.length - 1].params\r\n      }, submission, {\r\n        actionResult,\r\n        actionStatus,\r\n        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\r\n      }));\r\n    }\r\n    if (shouldRevalidate) {\r\n      revalidatingFetchers.push({\r\n        key,\r\n        routeId: f.routeId,\r\n        path: f.path,\r\n        matches: fetcherMatches,\r\n        match: fetcherMatch,\r\n        controller: new AbortController()\r\n      });\r\n    }\r\n  });\r\n  return [navigationMatches, revalidatingFetchers];\r\n}\r\nfunction shouldLoadRouteOnHydration(route, loaderData, errors) {\r\n  // We dunno if we have a loader - gotta find out!\r\n  if (route.lazy) {\r\n    return true;\r\n  }\r\n  // No loader, nothing to initialize\r\n  if (!route.loader) {\r\n    return false;\r\n  }\r\n  let hasData = loaderData != null && loaderData[route.id] !== undefined;\r\n  let hasError = errors != null && errors[route.id] !== undefined;\r\n  // Don't run if we error'd during SSR\r\n  if (!hasData && hasError) {\r\n    return false;\r\n  }\r\n  // Explicitly opting-in to running on hydration\r\n  if (typeof route.loader === \"function\" && route.loader.hydrate === true) {\r\n    return true;\r\n  }\r\n  // Otherwise, run if we're not yet initialized with anything\r\n  return !hasData && !hasError;\r\n}\r\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\r\n  let isNew =\r\n  // [a] -> [a, b]\r\n  !currentMatch ||\r\n  // [a, b] -> [a, c]\r\n  match.route.id !== currentMatch.route.id;\r\n  // Handle the case that we don't have data for a re-used route, potentially\r\n  // from a prior error or from a cancelled pending deferred\r\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\r\n  // Always load if this is a net-new route or we don't yet have data\r\n  return isNew || isMissingData;\r\n}\r\nfunction isNewRouteInstance(currentMatch, match) {\r\n  let currentPath = currentMatch.route.path;\r\n  return (\r\n    // param change for this match, /users/123 -> /users/456\r\n    currentMatch.pathname !== match.pathname ||\r\n    // splat param changed, which is not present in match.path\r\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\r\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\r\n  );\r\n}\r\nfunction shouldRevalidateLoader(loaderMatch, arg) {\r\n  if (loaderMatch.route.shouldRevalidate) {\r\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\r\n    if (typeof routeChoice === \"boolean\") {\r\n      return routeChoice;\r\n    }\r\n  }\r\n  return arg.defaultShouldRevalidate;\r\n}\r\nfunction patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties) {\r\n  var _childrenToPatch;\r\n  let childrenToPatch;\r\n  if (routeId) {\r\n    let route = manifest[routeId];\r\n    invariant(route, \"No route found to patch children into: routeId = \" + routeId);\r\n    if (!route.children) {\r\n      route.children = [];\r\n    }\r\n    childrenToPatch = route.children;\r\n  } else {\r\n    childrenToPatch = routesToUse;\r\n  }\r\n  // Don't patch in routes we already know about so that `patch` is idempotent\r\n  // to simplify user-land code. This is useful because we re-call the\r\n  // `patchRoutesOnNavigation` function for matched routes with params.\r\n  let uniqueChildren = children.filter(newRoute => !childrenToPatch.some(existingRoute => isSameRoute(newRoute, existingRoute)));\r\n  let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties, [routeId || \"_\", \"patch\", String(((_childrenToPatch = childrenToPatch) == null ? void 0 : _childrenToPatch.length) || \"0\")], manifest);\r\n  childrenToPatch.push(...newRoutes);\r\n}\r\nfunction isSameRoute(newRoute, existingRoute) {\r\n  // Most optimal check is by id\r\n  if (\"id\" in newRoute && \"id\" in existingRoute && newRoute.id === existingRoute.id) {\r\n    return true;\r\n  }\r\n  // Second is by pathing differences\r\n  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {\r\n    return false;\r\n  }\r\n  // Pathless layout routes are trickier since we need to check children.\r\n  // If they have no children then they're the same as far as we can tell\r\n  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {\r\n    return true;\r\n  }\r\n  // Otherwise, we look to see if every child in the new route is already\r\n  // represented in the existing route's children\r\n  return newRoute.children.every((aChild, i) => {\r\n    var _existingRoute$childr;\r\n    return (_existingRoute$childr = existingRoute.children) == null ? void 0 : _existingRoute$childr.some(bChild => isSameRoute(aChild, bChild));\r\n  });\r\n}\r\n/**\r\n * Execute route.lazy() methods to lazily load route modules (loader, action,\r\n * shouldRevalidate) and update the routeManifest in place which shares objects\r\n * with dataRoutes so those get updated as well.\r\n */\r\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\r\n  if (!route.lazy) {\r\n    return;\r\n  }\r\n  let lazyRoute = await route.lazy();\r\n  // If the lazy route function was executed and removed by another parallel\r\n  // call then we can return - first lazy() to finish wins because the return\r\n  // value of lazy is expected to be static\r\n  if (!route.lazy) {\r\n    return;\r\n  }\r\n  let routeToUpdate = manifest[route.id];\r\n  invariant(routeToUpdate, \"No route found in manifest\");\r\n  // Update the route in place.  This should be safe because there's no way\r\n  // we could yet be sitting on this route as we can't get there without\r\n  // resolving lazy() first.\r\n  //\r\n  // This is different than the HMR \"update\" use-case where we may actively be\r\n  // on the route being updated.  The main concern boils down to \"does this\r\n  // mutation affect any ongoing navigations or any current state.matches\r\n  // values?\".  If not, it should be safe to update in place.\r\n  let routeUpdates = {};\r\n  for (let lazyRouteProperty in lazyRoute) {\r\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\r\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\r\n    // This property isn't static since it should always be updated based\r\n    // on the route updates\r\n    lazyRouteProperty !== \"hasErrorBoundary\";\r\n    warning(!isPropertyStaticallyDefined, \"Route \\\"\" + routeToUpdate.id + \"\\\" has a static property \\\"\" + lazyRouteProperty + \"\\\" \" + \"defined but its lazy function is also returning a value for this property. \" + (\"The lazy route property \\\"\" + lazyRouteProperty + \"\\\" will be ignored.\"));\r\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\r\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\r\n    }\r\n  }\r\n  // Mutate the route with the provided updates.  Do this first so we pass\r\n  // the updated version to mapRouteProperties\r\n  Object.assign(routeToUpdate, routeUpdates);\r\n  // Mutate the `hasErrorBoundary` property on the route based on the route\r\n  // updates and remove the `lazy` function so we don't resolve the lazy\r\n  // route again.\r\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\r\n    lazy: undefined\r\n  }));\r\n}\r\n// Default implementation of `dataStrategy` which fetches all loaders in parallel\r\nasync function defaultDataStrategy(_ref4) {\r\n  let {\r\n    matches\r\n  } = _ref4;\r\n  let matchesToLoad = matches.filter(m => m.shouldLoad);\r\n  let results = await Promise.all(matchesToLoad.map(m => m.resolve()));\r\n  return results.reduce((acc, result, i) => Object.assign(acc, {\r\n    [matchesToLoad[i].route.id]: result\r\n  }), {});\r\n}\r\nasync function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties, requestContext) {\r\n  let loadRouteDefinitionsPromises = matches.map(m => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties, manifest) : undefined);\r\n  let dsMatches = matches.map((match, i) => {\r\n    let loadRoutePromise = loadRouteDefinitionsPromises[i];\r\n    let shouldLoad = matchesToLoad.some(m => m.route.id === match.route.id);\r\n    // `resolve` encapsulates route.lazy(), executing the loader/action,\r\n    // and mapping return values/thrown errors to a `DataStrategyResult`.  Users\r\n    // can pass a callback to take fine-grained control over the execution\r\n    // of the loader/action\r\n    let resolve = async handlerOverride => {\r\n      if (handlerOverride && request.method === \"GET\" && (match.route.lazy || match.route.loader)) {\r\n        shouldLoad = true;\r\n      }\r\n      return shouldLoad ? callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, requestContext) : Promise.resolve({\r\n        type: ResultType.data,\r\n        result: undefined\r\n      });\r\n    };\r\n    return _extends({}, match, {\r\n      shouldLoad,\r\n      resolve\r\n    });\r\n  });\r\n  // Send all matches here to allow for a middleware-type implementation.\r\n  // handler will be a no-op for unneeded routes and we filter those results\r\n  // back out below.\r\n  let results = await dataStrategyImpl({\r\n    matches: dsMatches,\r\n    request,\r\n    params: matches[0].params,\r\n    fetcherKey,\r\n    context: requestContext\r\n  });\r\n  // Wait for all routes to load here but 'swallow the error since we want\r\n  // it to bubble up from the `await loadRoutePromise` in `callLoaderOrAction` -\r\n  // called from `match.resolve()`\r\n  try {\r\n    await Promise.all(loadRouteDefinitionsPromises);\r\n  } catch (e) {\r\n    // No-op\r\n  }\r\n  return results;\r\n}\r\n// Default logic for calling a loader/action is the user has no specified a dataStrategy\r\nasync function callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, staticContext) {\r\n  let result;\r\n  let onReject;\r\n  let runHandler = handler => {\r\n    // Setup a promise we can race against so that abort signals short circuit\r\n    let reject;\r\n    // This will never resolve so safe to type it as Promise<DataStrategyResult> to\r\n    // satisfy the function return value\r\n    let abortPromise = new Promise((_, r) => reject = r);\r\n    onReject = () => reject();\r\n    request.signal.addEventListener(\"abort\", onReject);\r\n    let actualHandler = ctx => {\r\n      if (typeof handler !== \"function\") {\r\n        return Promise.reject(new Error(\"You cannot call the handler for a route which defines a boolean \" + (\"\\\"\" + type + \"\\\" [routeId: \" + match.route.id + \"]\")));\r\n      }\r\n      return handler({\r\n        request,\r\n        params: match.params,\r\n        context: staticContext\r\n      }, ...(ctx !== undefined ? [ctx] : []));\r\n    };\r\n    let handlerPromise = (async () => {\r\n      try {\r\n        let val = await (handlerOverride ? handlerOverride(ctx => actualHandler(ctx)) : actualHandler());\r\n        return {\r\n          type: \"data\",\r\n          result: val\r\n        };\r\n      } catch (e) {\r\n        return {\r\n          type: \"error\",\r\n          result: e\r\n        };\r\n      }\r\n    })();\r\n    return Promise.race([handlerPromise, abortPromise]);\r\n  };\r\n  try {\r\n    let handler = match.route[type];\r\n    // If we have a route.lazy promise, await that first\r\n    if (loadRoutePromise) {\r\n      if (handler) {\r\n        // Run statically defined handler in parallel with lazy()\r\n        let handlerError;\r\n        let [value] = await Promise.all([\r\n        // If the handler throws, don't let it immediately bubble out,\r\n        // since we need to let the lazy() execution finish so we know if this\r\n        // route has a boundary that can handle the error\r\n        runHandler(handler).catch(e => {\r\n          handlerError = e;\r\n        }), loadRoutePromise]);\r\n        if (handlerError !== undefined) {\r\n          throw handlerError;\r\n        }\r\n        result = value;\r\n      } else {\r\n        // Load lazy route module, then run any returned handler\r\n        await loadRoutePromise;\r\n        handler = match.route[type];\r\n        if (handler) {\r\n          // Handler still runs even if we got interrupted to maintain consistency\r\n          // with un-abortable behavior of handler execution on non-lazy or\r\n          // previously-lazy-loaded routes\r\n          result = await runHandler(handler);\r\n        } else if (type === \"action\") {\r\n          let url = new URL(request.url);\r\n          let pathname = url.pathname + url.search;\r\n          throw getInternalRouterError(405, {\r\n            method: request.method,\r\n            pathname,\r\n            routeId: match.route.id\r\n          });\r\n        } else {\r\n          // lazy() route has no loader to run.  Short circuit here so we don't\r\n          // hit the invariant below that errors on returning undefined.\r\n          return {\r\n            type: ResultType.data,\r\n            result: undefined\r\n          };\r\n        }\r\n      }\r\n    } else if (!handler) {\r\n      let url = new URL(request.url);\r\n      let pathname = url.pathname + url.search;\r\n      throw getInternalRouterError(404, {\r\n        pathname\r\n      });\r\n    } else {\r\n      result = await runHandler(handler);\r\n    }\r\n    invariant(result.result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\r\n  } catch (e) {\r\n    // We should already be catching and converting normal handler executions to\r\n    // DataStrategyResults and returning them, so anything that throws here is an\r\n    // unexpected error we still need to wrap\r\n    return {\r\n      type: ResultType.error,\r\n      result: e\r\n    };\r\n  } finally {\r\n    if (onReject) {\r\n      request.signal.removeEventListener(\"abort\", onReject);\r\n    }\r\n  }\r\n  return result;\r\n}\r\nasync function convertDataStrategyResultToDataResult(dataStrategyResult) {\r\n  let {\r\n    result,\r\n    type\r\n  } = dataStrategyResult;\r\n  if (isResponse(result)) {\r\n    let data;\r\n    try {\r\n      let contentType = result.headers.get(\"Content-Type\");\r\n      // Check between word boundaries instead of startsWith() due to the last\r\n      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\r\n      if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\r\n        if (result.body == null) {\r\n          data = null;\r\n        } else {\r\n          data = await result.json();\r\n        }\r\n      } else {\r\n        data = await result.text();\r\n      }\r\n    } catch (e) {\r\n      return {\r\n        type: ResultType.error,\r\n        error: e\r\n      };\r\n    }\r\n    if (type === ResultType.error) {\r\n      return {\r\n        type: ResultType.error,\r\n        error: new ErrorResponseImpl(result.status, result.statusText, data),\r\n        statusCode: result.status,\r\n        headers: result.headers\r\n      };\r\n    }\r\n    return {\r\n      type: ResultType.data,\r\n      data,\r\n      statusCode: result.status,\r\n      headers: result.headers\r\n    };\r\n  }\r\n  if (type === ResultType.error) {\r\n    if (isDataWithResponseInit(result)) {\r\n      var _result$init2;\r\n      if (result.data instanceof Error) {\r\n        var _result$init;\r\n        return {\r\n          type: ResultType.error,\r\n          error: result.data,\r\n          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status\r\n        };\r\n      }\r\n      // Convert thrown data() to ErrorResponse instances\r\n      result = new ErrorResponseImpl(((_result$init2 = result.init) == null ? void 0 : _result$init2.status) || 500, undefined, result.data);\r\n    }\r\n    return {\r\n      type: ResultType.error,\r\n      error: result,\r\n      statusCode: isRouteErrorResponse(result) ? result.status : undefined\r\n    };\r\n  }\r\n  if (isDeferredData(result)) {\r\n    var _result$init3, _result$init4;\r\n    return {\r\n      type: ResultType.deferred,\r\n      deferredData: result,\r\n      statusCode: (_result$init3 = result.init) == null ? void 0 : _result$init3.status,\r\n      headers: ((_result$init4 = result.init) == null ? void 0 : _result$init4.headers) && new Headers(result.init.headers)\r\n    };\r\n  }\r\n  if (isDataWithResponseInit(result)) {\r\n    var _result$init5, _result$init6;\r\n    return {\r\n      type: ResultType.data,\r\n      data: result.data,\r\n      statusCode: (_result$init5 = result.init) == null ? void 0 : _result$init5.status,\r\n      headers: (_result$init6 = result.init) != null && _result$init6.headers ? new Headers(result.init.headers) : undefined\r\n    };\r\n  }\r\n  return {\r\n    type: ResultType.data,\r\n    data: result\r\n  };\r\n}\r\n// Support relative routing in internal redirects\r\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {\r\n  let location = response.headers.get(\"Location\");\r\n  invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\r\n  if (!ABSOLUTE_URL_REGEX.test(location)) {\r\n    let trimmedMatches = matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1);\r\n    location = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location, v7_relativeSplatPath);\r\n    response.headers.set(\"Location\", location);\r\n  }\r\n  return response;\r\n}\r\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\r\n  if (ABSOLUTE_URL_REGEX.test(location)) {\r\n    // Strip off the protocol+origin for same-origin + same-basename absolute redirects\r\n    let normalizedLocation = location;\r\n    let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\r\n    let isSameBasename = stripBasename(url.pathname, basename) != null;\r\n    if (url.origin === currentUrl.origin && isSameBasename) {\r\n      return url.pathname + url.search + url.hash;\r\n    }\r\n  }\r\n  return location;\r\n}\r\n// Utility method for creating the Request instances for loaders/actions during\r\n// client-side navigations and fetches.  During SSR we will always have a\r\n// Request instance from the static handler (query/queryRoute)\r\nfunction createClientSideRequest(history, location, signal, submission) {\r\n  let url = history.createURL(stripHashFromPath(location)).toString();\r\n  let init = {\r\n    signal\r\n  };\r\n  if (submission && isMutationMethod(submission.formMethod)) {\r\n    let {\r\n      formMethod,\r\n      formEncType\r\n    } = submission;\r\n    // Didn't think we needed this but it turns out unlike other methods, patch\r\n    // won't be properly normalized to uppercase and results in a 405 error.\r\n    // See: https://fetch.spec.whatwg.org/#concept-method\r\n    init.method = formMethod.toUpperCase();\r\n    if (formEncType === \"application/json\") {\r\n      init.headers = new Headers({\r\n        \"Content-Type\": formEncType\r\n      });\r\n      init.body = JSON.stringify(submission.json);\r\n    } else if (formEncType === \"text/plain\") {\r\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\r\n      init.body = submission.text;\r\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\r\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\r\n      init.body = convertFormDataToSearchParams(submission.formData);\r\n    } else {\r\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\r\n      init.body = submission.formData;\r\n    }\r\n  }\r\n  return new Request(url, init);\r\n}\r\nfunction convertFormDataToSearchParams(formData) {\r\n  let searchParams = new URLSearchParams();\r\n  for (let [key, value] of formData.entries()) {\r\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\r\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\r\n  }\r\n  return searchParams;\r\n}\r\nfunction convertSearchParamsToFormData(searchParams) {\r\n  let formData = new FormData();\r\n  for (let [key, value] of searchParams.entries()) {\r\n    formData.append(key, value);\r\n  }\r\n  return formData;\r\n}\r\nfunction processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {\r\n  // Fill in loaderData/errors from our loaders\r\n  let loaderData = {};\r\n  let errors = null;\r\n  let statusCode;\r\n  let foundError = false;\r\n  let loaderHeaders = {};\r\n  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : undefined;\r\n  // Process loader results into state.loaderData/state.errors\r\n  matches.forEach(match => {\r\n    if (!(match.route.id in results)) {\r\n      return;\r\n    }\r\n    let id = match.route.id;\r\n    let result = results[id];\r\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\r\n    if (isErrorResult(result)) {\r\n      let error = result.error;\r\n      // If we have a pending action error, we report it at the highest-route\r\n      // that throws a loader error, and then clear it out to indicate that\r\n      // it was consumed\r\n      if (pendingError !== undefined) {\r\n        error = pendingError;\r\n        pendingError = undefined;\r\n      }\r\n      errors = errors || {};\r\n      if (skipLoaderErrorBubbling) {\r\n        errors[id] = error;\r\n      } else {\r\n        // Look upwards from the matched route for the closest ancestor error\r\n        // boundary, defaulting to the root match.  Prefer higher error values\r\n        // if lower errors bubble to the same boundary\r\n        let boundaryMatch = findNearestBoundary(matches, id);\r\n        if (errors[boundaryMatch.route.id] == null) {\r\n          errors[boundaryMatch.route.id] = error;\r\n        }\r\n      }\r\n      // Clear our any prior loaderData for the throwing route\r\n      loaderData[id] = undefined;\r\n      // Once we find our first (highest) error, we set the status code and\r\n      // prevent deeper status codes from overriding\r\n      if (!foundError) {\r\n        foundError = true;\r\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\r\n      }\r\n      if (result.headers) {\r\n        loaderHeaders[id] = result.headers;\r\n      }\r\n    } else {\r\n      if (isDeferredResult(result)) {\r\n        activeDeferreds.set(id, result.deferredData);\r\n        loaderData[id] = result.deferredData.data;\r\n        // Error status codes always override success status codes, but if all\r\n        // loaders are successful we take the deepest status code.\r\n        if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\r\n          statusCode = result.statusCode;\r\n        }\r\n        if (result.headers) {\r\n          loaderHeaders[id] = result.headers;\r\n        }\r\n      } else {\r\n        loaderData[id] = result.data;\r\n        // Error status codes always override success status codes, but if all\r\n        // loaders are successful we take the deepest status code.\r\n        if (result.statusCode && result.statusCode !== 200 && !foundError) {\r\n          statusCode = result.statusCode;\r\n        }\r\n        if (result.headers) {\r\n          loaderHeaders[id] = result.headers;\r\n        }\r\n      }\r\n    }\r\n  });\r\n  // If we didn't consume the pending action error (i.e., all loaders\r\n  // resolved), then consume it here.  Also clear out any loaderData for the\r\n  // throwing route\r\n  if (pendingError !== undefined && pendingActionResult) {\r\n    errors = {\r\n      [pendingActionResult[0]]: pendingError\r\n    };\r\n    loaderData[pendingActionResult[0]] = undefined;\r\n  }\r\n  return {\r\n    loaderData,\r\n    errors,\r\n    statusCode: statusCode || 200,\r\n    loaderHeaders\r\n  };\r\n}\r\nfunction processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {\r\n  let {\r\n    loaderData,\r\n    errors\r\n  } = processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, false // This method is only called client side so we always want to bubble\r\n  );\r\n  // Process results from our revalidating fetchers\r\n  revalidatingFetchers.forEach(rf => {\r\n    let {\r\n      key,\r\n      match,\r\n      controller\r\n    } = rf;\r\n    let result = fetcherResults[key];\r\n    invariant(result, \"Did not find corresponding fetcher result\");\r\n    // Process fetcher non-redirect errors\r\n    if (controller && controller.signal.aborted) {\r\n      // Nothing to do for aborted fetchers\r\n      return;\r\n    } else if (isErrorResult(result)) {\r\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\r\n      if (!(errors && errors[boundaryMatch.route.id])) {\r\n        errors = _extends({}, errors, {\r\n          [boundaryMatch.route.id]: result.error\r\n        });\r\n      }\r\n      state.fetchers.delete(key);\r\n    } else if (isRedirectResult(result)) {\r\n      // Should never get here, redirects should get processed above, but we\r\n      // keep this to type narrow to a success result in the else\r\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\r\n    } else if (isDeferredResult(result)) {\r\n      // Should never get here, deferred data should be awaited for fetchers\r\n      // in resolveDeferredResults\r\n      invariant(false, \"Unhandled fetcher deferred data\");\r\n    } else {\r\n      let doneFetcher = getDoneFetcher(result.data);\r\n      state.fetchers.set(key, doneFetcher);\r\n    }\r\n  });\r\n  return {\r\n    loaderData,\r\n    errors\r\n  };\r\n}\r\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\r\n  let mergedLoaderData = _extends({}, newLoaderData);\r\n  for (let match of matches) {\r\n    let id = match.route.id;\r\n    if (newLoaderData.hasOwnProperty(id)) {\r\n      if (newLoaderData[id] !== undefined) {\r\n        mergedLoaderData[id] = newLoaderData[id];\r\n      }\r\n    } else if (loaderData[id] !== undefined && match.route.loader) {\r\n      // Preserve existing keys not included in newLoaderData and where a loader\r\n      // wasn't removed by HMR\r\n      mergedLoaderData[id] = loaderData[id];\r\n    }\r\n    if (errors && errors.hasOwnProperty(id)) {\r\n      // Don't keep any loader data below the boundary\r\n      break;\r\n    }\r\n  }\r\n  return mergedLoaderData;\r\n}\r\nfunction getActionDataForCommit(pendingActionResult) {\r\n  if (!pendingActionResult) {\r\n    return {};\r\n  }\r\n  return isErrorResult(pendingActionResult[1]) ? {\r\n    // Clear out prior actionData on errors\r\n    actionData: {}\r\n  } : {\r\n    actionData: {\r\n      [pendingActionResult[0]]: pendingActionResult[1].data\r\n    }\r\n  };\r\n}\r\n// Find the nearest error boundary, looking upwards from the leaf route (or the\r\n// route specified by routeId) for the closest ancestor error boundary,\r\n// defaulting to the root match\r\nfunction findNearestBoundary(matches, routeId) {\r\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\r\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\r\n}\r\nfunction getShortCircuitMatches(routes) {\r\n  // Prefer a root layout route if present, otherwise shim in a route object\r\n  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === \"/\") || {\r\n    id: \"__shim-error-route__\"\r\n  };\r\n  return {\r\n    matches: [{\r\n      params: {},\r\n      pathname: \"\",\r\n      pathnameBase: \"\",\r\n      route\r\n    }],\r\n    route\r\n  };\r\n}\r\nfunction getInternalRouterError(status, _temp5) {\r\n  let {\r\n    pathname,\r\n    routeId,\r\n    method,\r\n    type,\r\n    message\r\n  } = _temp5 === void 0 ? {} : _temp5;\r\n  let statusText = \"Unknown Server Error\";\r\n  let errorMessage = \"Unknown @remix-run/router error\";\r\n  if (status === 400) {\r\n    statusText = \"Bad Request\";\r\n    if (method && pathname && routeId) {\r\n      errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\r\n    } else if (type === \"defer-action\") {\r\n      errorMessage = \"defer() is not supported in actions\";\r\n    } else if (type === \"invalid-body\") {\r\n      errorMessage = \"Unable to encode submission body\";\r\n    }\r\n  } else if (status === 403) {\r\n    statusText = \"Forbidden\";\r\n    errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\r\n  } else if (status === 404) {\r\n    statusText = \"Not Found\";\r\n    errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\r\n  } else if (status === 405) {\r\n    statusText = \"Method Not Allowed\";\r\n    if (method && pathname && routeId) {\r\n      errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\r\n    } else if (method) {\r\n      errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\r\n    }\r\n  }\r\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\r\n}\r\n// Find any returned redirect errors, starting from the lowest match\r\nfunction findRedirect(results) {\r\n  let entries = Object.entries(results);\r\n  for (let i = entries.length - 1; i >= 0; i--) {\r\n    let [key, result] = entries[i];\r\n    if (isRedirectResult(result)) {\r\n      return {\r\n        key,\r\n        result\r\n      };\r\n    }\r\n  }\r\n}\r\nfunction stripHashFromPath(path) {\r\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\r\n  return createPath(_extends({}, parsedPath, {\r\n    hash: \"\"\r\n  }));\r\n}\r\nfunction isHashChangeOnly(a, b) {\r\n  if (a.pathname !== b.pathname || a.search !== b.search) {\r\n    return false;\r\n  }\r\n  if (a.hash === \"\") {\r\n    // /page -> /page#hash\r\n    return b.hash !== \"\";\r\n  } else if (a.hash === b.hash) {\r\n    // /page#hash -> /page#hash\r\n    return true;\r\n  } else if (b.hash !== \"\") {\r\n    // /page#hash -> /page#other\r\n    return true;\r\n  }\r\n  // If the hash is removed the browser will re-perform a request to the server\r\n  // /page#hash -> /page\r\n  return false;\r\n}\r\nfunction isDataStrategyResult(result) {\r\n  return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === ResultType.data || result.type === ResultType.error);\r\n}\r\nfunction isRedirectDataStrategyResultResult(result) {\r\n  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\r\n}\r\nfunction isDeferredResult(result) {\r\n  return result.type === ResultType.deferred;\r\n}\r\nfunction isErrorResult(result) {\r\n  return result.type === ResultType.error;\r\n}\r\nfunction isRedirectResult(result) {\r\n  return (result && result.type) === ResultType.redirect;\r\n}\r\nfunction isDataWithResponseInit(value) {\r\n  return typeof value === \"object\" && value != null && \"type\" in value && \"data\" in value && \"init\" in value && value.type === \"DataWithResponseInit\";\r\n}\r\nfunction isDeferredData(value) {\r\n  let deferred = value;\r\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\r\n}\r\nfunction isResponse(value) {\r\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\r\n}\r\nfunction isRedirectResponse(result) {\r\n  if (!isResponse(result)) {\r\n    return false;\r\n  }\r\n  let status = result.status;\r\n  let location = result.headers.get(\"Location\");\r\n  return status >= 300 && status <= 399 && location != null;\r\n}\r\nfunction isValidMethod(method) {\r\n  return validRequestMethods.has(method.toLowerCase());\r\n}\r\nfunction isMutationMethod(method) {\r\n  return validMutationMethods.has(method.toLowerCase());\r\n}\r\nasync function resolveNavigationDeferredResults(matches, results, signal, currentMatches, currentLoaderData) {\r\n  let entries = Object.entries(results);\r\n  for (let index = 0; index < entries.length; index++) {\r\n    let [routeId, result] = entries[index];\r\n    let match = matches.find(m => (m == null ? void 0 : m.route.id) === routeId);\r\n    // If we don't have a match, then we can have a deferred result to do\r\n    // anything with.  This is for revalidating fetchers where the route was\r\n    // removed during HMR\r\n    if (!match) {\r\n      continue;\r\n    }\r\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\r\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\r\n    if (isDeferredResult(result) && isRevalidatingLoader) {\r\n      // Note: we do not have to touch activeDeferreds here since we race them\r\n      // against the signal in resolveDeferredData and they'll get aborted\r\n      // there if needed\r\n      await resolveDeferredData(result, signal, false).then(result => {\r\n        if (result) {\r\n          results[routeId] = result;\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\nasync function resolveFetcherDeferredResults(matches, results, revalidatingFetchers) {\r\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\r\n    let {\r\n      key,\r\n      routeId,\r\n      controller\r\n    } = revalidatingFetchers[index];\r\n    let result = results[key];\r\n    let match = matches.find(m => (m == null ? void 0 : m.route.id) === routeId);\r\n    // If we don't have a match, then we can have a deferred result to do\r\n    // anything with.  This is for revalidating fetchers where the route was\r\n    // removed during HMR\r\n    if (!match) {\r\n      continue;\r\n    }\r\n    if (isDeferredResult(result)) {\r\n      // Note: we do not have to touch activeDeferreds here since we race them\r\n      // against the signal in resolveDeferredData and they'll get aborted\r\n      // there if needed\r\n      invariant(controller, \"Expected an AbortController for revalidating fetcher deferred result\");\r\n      await resolveDeferredData(result, controller.signal, true).then(result => {\r\n        if (result) {\r\n          results[key] = result;\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\nasync function resolveDeferredData(result, signal, unwrap) {\r\n  if (unwrap === void 0) {\r\n    unwrap = false;\r\n  }\r\n  let aborted = await result.deferredData.resolveData(signal);\r\n  if (aborted) {\r\n    return;\r\n  }\r\n  if (unwrap) {\r\n    try {\r\n      return {\r\n        type: ResultType.data,\r\n        data: result.deferredData.unwrappedData\r\n      };\r\n    } catch (e) {\r\n      // Handle any TrackedPromise._error values encountered while unwrapping\r\n      return {\r\n        type: ResultType.error,\r\n        error: e\r\n      };\r\n    }\r\n  }\r\n  return {\r\n    type: ResultType.data,\r\n    data: result.deferredData.data\r\n  };\r\n}\r\nfunction hasNakedIndexQuery(search) {\r\n  return new URLSearchParams(search).getAll(\"index\").some(v => v === \"\");\r\n}\r\nfunction getTargetMatch(matches, location) {\r\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\r\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\r\n    // Return the leaf index route when index is present\r\n    return matches[matches.length - 1];\r\n  }\r\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\r\n  // pathless layout routes)\r\n  let pathMatches = getPathContributingMatches(matches);\r\n  return pathMatches[pathMatches.length - 1];\r\n}\r\nfunction getSubmissionFromNavigation(navigation) {\r\n  let {\r\n    formMethod,\r\n    formAction,\r\n    formEncType,\r\n    text,\r\n    formData,\r\n    json\r\n  } = navigation;\r\n  if (!formMethod || !formAction || !formEncType) {\r\n    return;\r\n  }\r\n  if (text != null) {\r\n    return {\r\n      formMethod,\r\n      formAction,\r\n      formEncType,\r\n      formData: undefined,\r\n      json: undefined,\r\n      text\r\n    };\r\n  } else if (formData != null) {\r\n    return {\r\n      formMethod,\r\n      formAction,\r\n      formEncType,\r\n      formData,\r\n      json: undefined,\r\n      text: undefined\r\n    };\r\n  } else if (json !== undefined) {\r\n    return {\r\n      formMethod,\r\n      formAction,\r\n      formEncType,\r\n      formData: undefined,\r\n      json,\r\n      text: undefined\r\n    };\r\n  }\r\n}\r\nfunction getLoadingNavigation(location, submission) {\r\n  if (submission) {\r\n    let navigation = {\r\n      state: \"loading\",\r\n      location,\r\n      formMethod: submission.formMethod,\r\n      formAction: submission.formAction,\r\n      formEncType: submission.formEncType,\r\n      formData: submission.formData,\r\n      json: submission.json,\r\n      text: submission.text\r\n    };\r\n    return navigation;\r\n  } else {\r\n    let navigation = {\r\n      state: \"loading\",\r\n      location,\r\n      formMethod: undefined,\r\n      formAction: undefined,\r\n      formEncType: undefined,\r\n      formData: undefined,\r\n      json: undefined,\r\n      text: undefined\r\n    };\r\n    return navigation;\r\n  }\r\n}\r\nfunction getSubmittingNavigation(location, submission) {\r\n  let navigation = {\r\n    state: \"submitting\",\r\n    location,\r\n    formMethod: submission.formMethod,\r\n    formAction: submission.formAction,\r\n    formEncType: submission.formEncType,\r\n    formData: submission.formData,\r\n    json: submission.json,\r\n    text: submission.text\r\n  };\r\n  return navigation;\r\n}\r\nfunction getLoadingFetcher(submission, data) {\r\n  if (submission) {\r\n    let fetcher = {\r\n      state: \"loading\",\r\n      formMethod: submission.formMethod,\r\n      formAction: submission.formAction,\r\n      formEncType: submission.formEncType,\r\n      formData: submission.formData,\r\n      json: submission.json,\r\n      text: submission.text,\r\n      data\r\n    };\r\n    return fetcher;\r\n  } else {\r\n    let fetcher = {\r\n      state: \"loading\",\r\n      formMethod: undefined,\r\n      formAction: undefined,\r\n      formEncType: undefined,\r\n      formData: undefined,\r\n      json: undefined,\r\n      text: undefined,\r\n      data\r\n    };\r\n    return fetcher;\r\n  }\r\n}\r\nfunction getSubmittingFetcher(submission, existingFetcher) {\r\n  let fetcher = {\r\n    state: \"submitting\",\r\n    formMethod: submission.formMethod,\r\n    formAction: submission.formAction,\r\n    formEncType: submission.formEncType,\r\n    formData: submission.formData,\r\n    json: submission.json,\r\n    text: submission.text,\r\n    data: existingFetcher ? existingFetcher.data : undefined\r\n  };\r\n  return fetcher;\r\n}\r\nfunction getDoneFetcher(data) {\r\n  let fetcher = {\r\n    state: \"idle\",\r\n    formMethod: undefined,\r\n    formAction: undefined,\r\n    formEncType: undefined,\r\n    formData: undefined,\r\n    json: undefined,\r\n    text: undefined,\r\n    data\r\n  };\r\n  return fetcher;\r\n}\r\nfunction restoreAppliedTransitions(_window, transitions) {\r\n  try {\r\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\r\n    if (sessionPositions) {\r\n      let json = JSON.parse(sessionPositions);\r\n      for (let [k, v] of Object.entries(json || {})) {\r\n        if (v && Array.isArray(v)) {\r\n          transitions.set(k, new Set(v || []));\r\n        }\r\n      }\r\n    }\r\n  } catch (e) {\r\n    // no-op, use default empty object\r\n  }\r\n}\r\nfunction persistAppliedTransitions(_window, transitions) {\r\n  if (transitions.size > 0) {\r\n    let json = {};\r\n    for (let [k, v] of transitions) {\r\n      json[k] = [...v];\r\n    }\r\n    try {\r\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\r\n    } catch (error) {\r\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\r\n    }\r\n  }\r\n}\r\n//#endregion\r\n\r\n\r\n//# sourceMappingURL=router.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yb3V0ZXIvZGlzdC9yb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdDQUF3QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkI7QUFDM0IsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QyxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUNBQXlDO0FBQ2hGO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0NBQWtDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBLFFBQVEsSUFBSTtBQUNaO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5QkFBeUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxVQUFVLElBQUk7QUFDZCxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrMUI7QUFDbDFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JvdXRlci9kaXN0L3JvdXRlci5qcz81MDM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAcmVtaXgtcnVuL3JvdXRlciB2MS4yMC4wXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBAbGljZW5zZSBNSVRcclxuICovXHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xyXG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XHJcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9O1xyXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyNyZWdpb24gVHlwZXMgYW5kIENvbnN0YW50c1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vKipcclxuICogQWN0aW9ucyByZXByZXNlbnQgdGhlIHR5cGUgb2YgY2hhbmdlIHRvIGEgbG9jYXRpb24gdmFsdWUuXHJcbiAqL1xyXG52YXIgQWN0aW9uO1xyXG4oZnVuY3Rpb24gKEFjdGlvbikge1xyXG4gIC8qKlxyXG4gICAqIEEgUE9QIGluZGljYXRlcyBhIGNoYW5nZSB0byBhbiBhcmJpdHJhcnkgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2hcclxuICAgKiBhcyBhIGJhY2sgb3IgZm9yd2FyZCBuYXZpZ2F0aW9uLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgZGlyZWN0aW9uIG9mIHRoZVxyXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIG5ld2x5IGNyZWF0ZWQgaGlzdG9yeSBvYmplY3RzLlxyXG4gICAqL1xyXG4gIEFjdGlvbltcIlBvcFwiXSA9IFwiUE9QXCI7XHJcbiAgLyoqXHJcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXHJcbiAgICogYSBsaW5rIGlzIGNsaWNrZWQgYW5kIGEgbmV3IHBhZ2UgbG9hZHMuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgc3Vic2VxdWVudFxyXG4gICAqIGVudHJpZXMgaW4gdGhlIHN0YWNrIGFyZSBsb3N0LlxyXG4gICAqL1xyXG4gIEFjdGlvbltcIlB1c2hcIl0gPSBcIlBVU0hcIjtcclxuICAvKipcclxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xyXG4gICAqIGJlaW5nIHJlcGxhY2VkIGJ5IGEgbmV3IG9uZS5cclxuICAgKi9cclxuICBBY3Rpb25bXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XHJcbn0pKEFjdGlvbiB8fCAoQWN0aW9uID0ge30pKTtcclxuY29uc3QgUG9wU3RhdGVFdmVudFR5cGUgPSBcInBvcHN0YXRlXCI7XHJcbi8qKlxyXG4gKiBNZW1vcnkgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gbWVtb3J5LiBJdCBpcyBkZXNpZ25lZCBmb3IgdXNlXHJcbiAqIGluIHN0YXRlZnVsIG5vbi1icm93c2VyIGVudmlyb25tZW50cyBsaWtlIHRlc3RzIGFuZCBSZWFjdCBOYXRpdmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMpIHtcclxuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICBvcHRpb25zID0ge307XHJcbiAgfVxyXG4gIGxldCB7XHJcbiAgICBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sXHJcbiAgICBpbml0aWFsSW5kZXgsXHJcbiAgICB2NUNvbXBhdCA9IGZhbHNlXHJcbiAgfSA9IG9wdGlvbnM7XHJcbiAgbGV0IGVudHJpZXM7IC8vIERlY2xhcmUgc28gd2UgY2FuIGFjY2VzcyBmcm9tIGNyZWF0ZU1lbW9yeUxvY2F0aW9uXHJcbiAgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcCgoZW50cnksIGluZGV4KSA9PiBjcmVhdGVNZW1vcnlMb2NhdGlvbihlbnRyeSwgdHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiID8gbnVsbCA6IGVudHJ5LnN0YXRlLCBpbmRleCA9PT0gMCA/IFwiZGVmYXVsdFwiIDogdW5kZWZpbmVkKSk7XHJcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleCk7XHJcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XHJcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcclxuICBmdW5jdGlvbiBjbGFtcEluZGV4KG4pIHtcclxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCAwKSwgZW50cmllcy5sZW5ndGggLSAxKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xyXG4gICAgcmV0dXJuIGVudHJpZXNbaW5kZXhdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUsIGtleSkge1xyXG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcclxuICAgICAgc3RhdGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oZW50cmllcyA/IGdldEN1cnJlbnRMb2NhdGlvbigpLnBhdGhuYW1lIDogXCIvXCIsIHRvLCBzdGF0ZSwga2V5KTtcclxuICAgIHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIiwgXCJyZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3Rvcnk6IFwiICsgSlNPTi5zdHJpbmdpZnkodG8pKTtcclxuICAgIHJldHVybiBsb2NhdGlvbjtcclxuICB9XHJcbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XHJcbiAgfVxyXG4gIGxldCBoaXN0b3J5ID0ge1xyXG4gICAgZ2V0IGluZGV4KCkge1xyXG4gICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9LFxyXG4gICAgZ2V0IGFjdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGFjdGlvbjtcclxuICAgIH0sXHJcbiAgICBnZXQgbG9jYXRpb24oKSB7XHJcbiAgICAgIHJldHVybiBnZXRDdXJyZW50TG9jYXRpb24oKTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVIcmVmLFxyXG4gICAgY3JlYXRlVVJMKHRvKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVVJMKGNyZWF0ZUhyZWYodG8pLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XHJcbiAgICB9LFxyXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcclxuICAgICAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgucGF0aG5hbWUgfHwgXCJcIixcclxuICAgICAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXHJcbiAgICAgICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCJcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xyXG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcclxuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XHJcbiAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCBlbnRyaWVzLmxlbmd0aCwgbmV4dExvY2F0aW9uKTtcclxuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgbGlzdGVuZXIoe1xyXG4gICAgICAgICAgYWN0aW9uLFxyXG4gICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcclxuICAgICAgICAgIGRlbHRhOiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZXBsYWNlKHRvLCBzdGF0ZSkge1xyXG4gICAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcclxuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XHJcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xyXG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcclxuICAgICAgICBsaXN0ZW5lcih7XHJcbiAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxyXG4gICAgICAgICAgZGVsdGE6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGdvKGRlbHRhKSB7XHJcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XHJcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xyXG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xyXG4gICAgICBpbmRleCA9IG5leHRJbmRleDtcclxuICAgICAgaWYgKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgbGlzdGVuZXIoe1xyXG4gICAgICAgICAgYWN0aW9uLFxyXG4gICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcclxuICAgICAgICAgIGRlbHRhXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBsaXN0ZW4oZm4pIHtcclxuICAgICAgbGlzdGVuZXIgPSBmbjtcclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4gaGlzdG9yeTtcclxufVxyXG4vKipcclxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcclxuICogbW9zdCB3ZWIgYXBwcywgYnV0IGl0IHJlcXVpcmVzIHNvbWUgY29uZmlndXJhdGlvbiBvbiB0aGUgc2VydmVyIHRvIGVuc3VyZSB5b3VcclxuICogc2VydmUgdGhlIHNhbWUgYXBwIGF0IG11bHRpcGxlIFVSTHMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlYnJvd3Nlcmhpc3RvcnlcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMpIHtcclxuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICBvcHRpb25zID0ge307XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIHBhdGhuYW1lLFxyXG4gICAgICBzZWFyY2gsXHJcbiAgICAgIGhhc2hcclxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XHJcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXCJcIiwge1xyXG4gICAgICBwYXRobmFtZSxcclxuICAgICAgc2VhcmNoLFxyXG4gICAgICBoYXNoXHJcbiAgICB9LFxyXG4gICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXHJcbiAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyIHx8IG51bGwsIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkgfHwgXCJkZWZhdWx0XCIpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3csIHRvKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcclxuICB9XHJcbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVCcm93c2VyTG9jYXRpb24sIGNyZWF0ZUJyb3dzZXJIcmVmLCBudWxsLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcclxuICogZm9yIHNpdHVhdGlvbnMgd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgbG9jYXRpb24gdG8gdGhlIHNlcnZlciBmb3JcclxuICogc29tZSByZWFzb24sIGVpdGhlciBiZWNhdXNlIHlvdSBkbyBjYW5ub3QgY29uZmlndXJlIGl0IG9yIHRoZSBVUkwgc3BhY2UgaXNcclxuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWhhc2hoaXN0b3J5XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShvcHRpb25zKSB7XHJcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgb3B0aW9ucyA9IHt9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBjcmVhdGVIYXNoTG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBwYXRobmFtZSA9IFwiL1wiLFxyXG4gICAgICBzZWFyY2ggPSBcIlwiLFxyXG4gICAgICBoYXNoID0gXCJcIlxyXG4gICAgfSA9IHBhcnNlUGF0aCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpO1xyXG4gICAgLy8gSGFzaCBVUkwgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbGVhZGluZyAvIGp1c3QgbGlrZSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVcclxuICAgIC8vIGRvZXMsIHNvIGlmIGFuIGFwcCBlbmRzIHVwIGF0IGEgcm91dGUgbGlrZSAvI3NvbWV0aGluZyB0aGVuIHdlIGFkZCBhXHJcbiAgICAvLyBsZWFkaW5nIHNsYXNoIHNvIGFsbCBvZiBvdXIgcGF0aC1tYXRjaGluZyBiZWhhdmVzIHRoZSBzYW1lIGFzIGlmIGl0IHdvdWxkXHJcbiAgICAvLyBpbiBhIGJyb3dzZXIgcm91dGVyLiAgVGhpcyBpcyBwYXJ0aWN1bGFybHkgaW1wb3J0YW50IHdoZW4gdGhlcmUgZXhpc3RzIGFcclxuICAgIC8vIHJvb3Qgc3BsYXQgcm91dGUgKDxSb3V0ZSBwYXRoPVwiKlwiPikgc2luY2UgdGhhdCBtYXRjaGVzIGludGVybmFsbHkgYWdhaW5zdFxyXG4gICAgLy8gXCIvKlwiIGFuZCB3ZSdkIGV4cGVjdCAvI3NvbWV0aGluZyB0byA0MDQgaW4gYSBoYXNoIHJvdXRlciBhcHAuXHJcbiAgICBpZiAoIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvXCIpICYmICFwYXRobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xyXG4gICAgICBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oXCJcIiwge1xyXG4gICAgICBwYXRobmFtZSxcclxuICAgICAgc2VhcmNoLFxyXG4gICAgICBoYXNoXHJcbiAgICB9LFxyXG4gICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXHJcbiAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyIHx8IG51bGwsIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS5rZXkgfHwgXCJkZWZhdWx0XCIpO1xyXG4gIH1cclxuICBmdW5jdGlvbiBjcmVhdGVIYXNoSHJlZih3aW5kb3csIHRvKSB7XHJcbiAgICBsZXQgYmFzZSA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKTtcclxuICAgIGxldCBocmVmID0gXCJcIjtcclxuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkge1xyXG4gICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XHJcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XHJcbiAgICAgIGhyZWYgPSBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xyXG4gIH1cclxuICBmdW5jdGlvbiB2YWxpZGF0ZUhhc2hMb2NhdGlvbihsb2NhdGlvbiwgdG8pIHtcclxuICAgIHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIiwgXCJyZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIik7XHJcbiAgfVxyXG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoY3JlYXRlSGFzaExvY2F0aW9uLCBjcmVhdGVIYXNoSHJlZiwgdmFsaWRhdGVIYXNoTG9jYXRpb24sIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xyXG4gIGlmICghY29uZCkge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgaGlzdG9yeSFcclxuICAgICAgLy9cclxuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSwgc28geW91IGNhbiBtb3JlIGVhc2lseVxyXG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcclxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxyXG4gICAgfSBjYXRjaCAoZSkge31cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xyXG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XHJcbn1cclxuLyoqXHJcbiAqIEZvciBicm93c2VyLWJhc2VkIGhpc3Rvcmllcywgd2UgY29tYmluZSB0aGUgc3RhdGUgYW5kIGtleSBpbnRvIGFuIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCkge1xyXG4gIHJldHVybiB7XHJcbiAgICB1c3I6IGxvY2F0aW9uLnN0YXRlLFxyXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXHJcbiAgICBpZHg6IGluZGV4XHJcbiAgfTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvY2F0aW9uIG9iamVjdCB3aXRoIGEgdW5pcXVlIGtleSBmcm9tIHRoZSBnaXZlbiBQYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihjdXJyZW50LCB0bywgc3RhdGUsIGtleSkge1xyXG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICBzdGF0ZSA9IG51bGw7XHJcbiAgfVxyXG4gIGxldCBsb2NhdGlvbiA9IF9leHRlbmRzKHtcclxuICAgIHBhdGhuYW1lOiB0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIiA/IGN1cnJlbnQgOiBjdXJyZW50LnBhdGhuYW1lLFxyXG4gICAgc2VhcmNoOiBcIlwiLFxyXG4gICAgaGFzaDogXCJcIlxyXG4gIH0sIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xyXG4gICAgc3RhdGUsXHJcbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGNsZWFuZWQgdXAuICBwdXNoL3JlcGxhY2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgdGFrZVxyXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXHJcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXHJcbiAgICAvLyBrZWVwIGFzIGlzIGZvciB0aGUgdGltZSBiZWluZyBhbmQganVzdCBsZXQgYW55IGluY29taW5nIGtleXMgdGFrZSBwcmVjZWRlbmNlXHJcbiAgICBrZXk6IHRvICYmIHRvLmtleSB8fCBrZXkgfHwgY3JlYXRlS2V5KClcclxuICB9KTtcclxuICByZXR1cm4gbG9jYXRpb247XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdHJpbmcgVVJMIHBhdGggZnJvbSB0aGUgZ2l2ZW4gcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdGgoX3JlZikge1xyXG4gIGxldCB7XHJcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxyXG4gICAgc2VhcmNoID0gXCJcIixcclxuICAgIGhhc2ggPSBcIlwiXHJcbiAgfSA9IF9yZWY7XHJcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09IFwiP1wiKSBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSBcIj9cIiA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xyXG4gIGlmIChoYXNoICYmIGhhc2ggIT09IFwiI1wiKSBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gXCIjXCIgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xyXG4gIHJldHVybiBwYXRobmFtZTtcclxufVxyXG4vKipcclxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xyXG4gIGxldCBwYXJzZWRQYXRoID0ge307XHJcbiAgaWYgKHBhdGgpIHtcclxuICAgIGxldCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xyXG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XHJcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XHJcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNlYXJjaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcclxuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XHJcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xyXG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhdGgpIHtcclxuICAgICAgcGFyc2VkUGF0aC5wYXRobmFtZSA9IHBhdGg7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBwYXJzZWRQYXRoO1xyXG59XHJcbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShnZXRMb2NhdGlvbiwgY3JlYXRlSHJlZiwgdmFsaWRhdGVMb2NhdGlvbiwgb3B0aW9ucykge1xyXG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcclxuICAgIG9wdGlvbnMgPSB7fTtcclxuICB9XHJcbiAgbGV0IHtcclxuICAgIHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LFxyXG4gICAgdjVDb21wYXQgPSBmYWxzZVxyXG4gIH0gPSBvcHRpb25zO1xyXG4gIGxldCBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XHJcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XHJcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcclxuICBsZXQgaW5kZXggPSBnZXRJbmRleCgpO1xyXG4gIC8vIEluZGV4IHNob3VsZCBvbmx5IGJlIG51bGwgd2hlbiB3ZSBpbml0aWFsaXplLiBJZiBub3QsIGl0J3MgYmVjYXVzZSB0aGVcclxuICAvLyB1c2VyIGNhbGxlZCBoaXN0b3J5LnB1c2hTdGF0ZSBvciBoaXN0b3J5LnJlcGxhY2VTdGF0ZSBkaXJlY3RseSwgaW4gd2hpY2hcclxuICAvLyBjYXNlIHdlIHNob3VsZCBsb2cgYSB3YXJuaW5nIGFzIGl0IHdpbGwgcmVzdWx0IGluIGJ1Z3MuXHJcbiAgaWYgKGluZGV4ID09IG51bGwpIHtcclxuICAgIGluZGV4ID0gMDtcclxuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBnbG9iYWxIaXN0b3J5LnN0YXRlLCB7XHJcbiAgICAgIGlkeDogaW5kZXhcclxuICAgIH0pLCBcIlwiKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XHJcbiAgICBsZXQgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHtcclxuICAgICAgaWR4OiBudWxsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHN0YXRlLmlkeDtcclxuICB9XHJcbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xyXG4gICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcclxuICAgIGxldCBuZXh0SW5kZXggPSBnZXRJbmRleCgpO1xyXG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XHJcbiAgICBpbmRleCA9IG5leHRJbmRleDtcclxuICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICBsaXN0ZW5lcih7XHJcbiAgICAgICAgYWN0aW9uLFxyXG4gICAgICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxyXG4gICAgICAgIGRlbHRhXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xyXG4gICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XHJcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xyXG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcclxuICAgIGluZGV4ID0gZ2V0SW5kZXgoKSArIDE7XHJcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XHJcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcclxuICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXHJcbiAgICB0cnkge1xyXG4gICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBJZiB0aGUgZXhjZXB0aW9uIGlzIGJlY2F1c2UgYHN0YXRlYCBjYW4ndCBiZSBzZXJpYWxpemVkLCBsZXQgdGhhdCB0aHJvd1xyXG4gICAgICAvLyBvdXR3YXJkcyBqdXN0IGxpa2UgYSByZXBsYWNlIGNhbGwgd291bGQgc28gdGhlIGRldiBrbm93cyB0aGUgY2F1c2VcclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbmF2LWhpc3RvcnktYXBpcy5odG1sI3NoYXJlZC1oaXN0b3J5LXB1c2gvcmVwbGFjZS1zdGF0ZS1zdGVwc1xyXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zdHJ1Y3R1cmVkLWRhdGEuaHRtbCNzdHJ1Y3R1cmVkc2VyaWFsaXplaW50ZXJuYWxcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiRGF0YUNsb25lRXJyb3JcIikge1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcclxuICAgICAgLy8gd2F5IHRvIHdhcm4gdGhlbSBhYm91dCBpdCBzaW5jZSB0aGUgcGFnZSB3aWxsIHJlZnJlc2guLi5cclxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xyXG4gICAgfVxyXG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XHJcbiAgICAgIGxpc3RlbmVyKHtcclxuICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXHJcbiAgICAgICAgZGVsdGE6IDFcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG8sIHN0YXRlKSB7XHJcbiAgICBhY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcclxuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XHJcbiAgICBpZiAodmFsaWRhdGVMb2NhdGlvbikgdmFsaWRhdGVMb2NhdGlvbihsb2NhdGlvbiwgdG8pO1xyXG4gICAgaW5kZXggPSBnZXRJbmRleCgpO1xyXG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xyXG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XHJcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XHJcbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcclxuICAgICAgbGlzdGVuZXIoe1xyXG4gICAgICAgIGFjdGlvbixcclxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcclxuICAgICAgICBkZWx0YTogMFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gY3JlYXRlVVJMKHRvKSB7XHJcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcclxuICAgIC8vIHVuZGVyIGNlcnRhaW4gY29uZGl0aW9ucywgbm90YWJseSB3aGVuIHNlcnZpbmcgZnJvbSBhIGxvY2FsIEhUTUwgZmlsZVxyXG4gICAgLy8gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg3ODI5N1xyXG4gICAgbGV0IGJhc2UgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIiA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcclxuICAgIGxldCBocmVmID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcclxuICAgIC8vIFRyZWF0aW5nIHRoaXMgYXMgYSBmdWxsIFVSTCB3aWxsIHN0cmlwIGFueSB0cmFpbGluZyBzcGFjZXMgc28gd2UgbmVlZCB0b1xyXG4gICAgLy8gcHJlLWVuY29kZSB0aGVtIHNpbmNlIHRoZXkgbWlnaHQgYmUgcGFydCBvZiBhIG1hdGNoaW5nIHNwbGF0IHBhcmFtIGZyb21cclxuICAgIC8vIGFuIGFuY2VzdG9yIHJvdXRlXHJcbiAgICBocmVmID0gaHJlZi5yZXBsYWNlKC8gJC8sIFwiJTIwXCIpO1xyXG4gICAgaW52YXJpYW50KGJhc2UsIFwiTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkwgZm9yIGhyZWY6IFwiICsgaHJlZik7XHJcbiAgICByZXR1cm4gbmV3IFVSTChocmVmLCBiYXNlKTtcclxuICB9XHJcbiAgbGV0IGhpc3RvcnkgPSB7XHJcbiAgICBnZXQgYWN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gYWN0aW9uO1xyXG4gICAgfSxcclxuICAgIGdldCBsb2NhdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHdpbmRvdywgZ2xvYmFsSGlzdG9yeSk7XHJcbiAgICB9LFxyXG4gICAgbGlzdGVuKGZuKSB7XHJcbiAgICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcclxuICAgICAgfVxyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcclxuICAgICAgbGlzdGVuZXIgPSBmbjtcclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcclxuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlSHJlZih0bykge1xyXG4gICAgICByZXR1cm4gY3JlYXRlSHJlZih3aW5kb3csIHRvKTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVVUkwsXHJcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xyXG4gICAgICAvLyBFbmNvZGUgYSBMb2NhdGlvbiB0aGUgc2FtZSB3YXkgd2luZG93LmxvY2F0aW9uIHdvdWxkXHJcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWUsXHJcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxyXG4gICAgICAgIGhhc2g6IHVybC5oYXNoXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcHVzaCxcclxuICAgIHJlcGxhY2UsXHJcbiAgICBnbyhuKSB7XHJcbiAgICAgIHJldHVybiBnbG9iYWxIaXN0b3J5LmdvKG4pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIGhpc3Rvcnk7XHJcbn1cclxuLy8jZW5kcmVnaW9uXHJcblxyXG52YXIgUmVzdWx0VHlwZTtcclxuKGZ1bmN0aW9uIChSZXN1bHRUeXBlKSB7XHJcbiAgUmVzdWx0VHlwZVtcImRhdGFcIl0gPSBcImRhdGFcIjtcclxuICBSZXN1bHRUeXBlW1wiZGVmZXJyZWRcIl0gPSBcImRlZmVycmVkXCI7XHJcbiAgUmVzdWx0VHlwZVtcInJlZGlyZWN0XCJdID0gXCJyZWRpcmVjdFwiO1xyXG4gIFJlc3VsdFR5cGVbXCJlcnJvclwiXSA9IFwiZXJyb3JcIjtcclxufSkoUmVzdWx0VHlwZSB8fCAoUmVzdWx0VHlwZSA9IHt9KSk7XHJcbmNvbnN0IGltbXV0YWJsZVJvdXRlS2V5cyA9IG5ldyBTZXQoW1wibGF6eVwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJwYXRoXCIsIFwiaWRcIiwgXCJpbmRleFwiLCBcImNoaWxkcmVuXCJdKTtcclxuZnVuY3Rpb24gaXNJbmRleFJvdXRlKHJvdXRlKSB7XHJcbiAgcmV0dXJuIHJvdXRlLmluZGV4ID09PSB0cnVlO1xyXG59XHJcbi8vIFdhbGsgdGhlIHJvdXRlIHRyZWUgZ2VuZXJhdGluZyB1bmlxdWUgSURzIHdoZXJlIG5lY2Vzc2FyeSwgc28gd2UgYXJlIHdvcmtpbmdcclxuLy8gc29sZWx5IHdpdGggQWdub3N0aWNEYXRhUm91dGVPYmplY3QncyB3aXRoaW4gdGhlIFJvdXRlclxyXG5mdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCBwYXJlbnRQYXRoLCBtYW5pZmVzdCkge1xyXG4gIGlmIChwYXJlbnRQYXRoID09PSB2b2lkIDApIHtcclxuICAgIHBhcmVudFBhdGggPSBbXTtcclxuICB9XHJcbiAgaWYgKG1hbmlmZXN0ID09PSB2b2lkIDApIHtcclxuICAgIG1hbmlmZXN0ID0ge307XHJcbiAgfVxyXG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSwgaW5kZXgpID0+IHtcclxuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBTdHJpbmcoaW5kZXgpXTtcclxuICAgIGxldCBpZCA9IHR5cGVvZiByb3V0ZS5pZCA9PT0gXCJzdHJpbmdcIiA/IHJvdXRlLmlkIDogdHJlZVBhdGguam9pbihcIi1cIik7XHJcbiAgICBpbnZhcmlhbnQocm91dGUuaW5kZXggIT09IHRydWUgfHwgIXJvdXRlLmNoaWxkcmVuLCBcIkNhbm5vdCBzcGVjaWZ5IGNoaWxkcmVuIG9uIGFuIGluZGV4IHJvdXRlXCIpO1xyXG4gICAgaW52YXJpYW50KCFtYW5pZmVzdFtpZF0sIFwiRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXFxcIlwiICsgaWQgKyBcIlxcXCIuICBSb3V0ZSBcIiArIFwiaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzXCIpO1xyXG4gICAgaWYgKGlzSW5kZXhSb3V0ZShyb3V0ZSkpIHtcclxuICAgICAgbGV0IGluZGV4Um91dGUgPSBfZXh0ZW5kcyh7fSwgcm91dGUsIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSksIHtcclxuICAgICAgICBpZFxyXG4gICAgICB9KTtcclxuICAgICAgbWFuaWZlc3RbaWRdID0gaW5kZXhSb3V0ZTtcclxuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgcGF0aE9yTGF5b3V0Um91dGUgPSBfZXh0ZW5kcyh7fSwgcm91dGUsIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSksIHtcclxuICAgICAgICBpZCxcclxuICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkXHJcbiAgICAgIH0pO1xyXG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcclxuICAgICAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgcGF0aE9yTGF5b3V0Um91dGUuY2hpbGRyZW4gPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBtYXBSb3V0ZVByb3BlcnRpZXMsIHRyZWVQYXRoLCBtYW5pZmVzdCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhdGhPckxheW91dFJvdXRlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cclxuICpcclxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1yb3V0ZXNcclxuICovXHJcbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcsIGJhc2VuYW1lKSB7XHJcbiAgaWYgKGJhc2VuYW1lID09PSB2b2lkIDApIHtcclxuICAgIGJhc2VuYW1lID0gXCIvXCI7XHJcbiAgfVxyXG4gIHJldHVybiBtYXRjaFJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUsIGZhbHNlKTtcclxufVxyXG5mdW5jdGlvbiBtYXRjaFJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUsIGFsbG93UGFydGlhbCkge1xyXG4gIGxldCBsb2NhdGlvbiA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcclxuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XHJcbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XHJcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xyXG4gIGxldCBtYXRjaGVzID0gbnVsbDtcclxuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgLy8gSW5jb21pbmcgcGF0aG5hbWVzIGFyZSBnZW5lcmFsbHkgZW5jb2RlZCBmcm9tIGVpdGhlciB3aW5kb3cubG9jYXRpb25cclxuICAgIC8vIG9yIGZyb20gcm91dGVyLm5hdmlnYXRlLCBidXQgd2Ugd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1bmVuY29kZWRcclxuICAgIC8vIHBhdGhzIGluIHRoZSByb3V0ZSBkZWZpbml0aW9ucy4gIE1lbW9yeSByb3V0ZXIgbG9jYXRpb25zIHdvbid0IGJlXHJcbiAgICAvLyBlbmNvZGVkIGhlcmUgYnV0IHRoZXJlIGFsc28gc2hvdWxkbid0IGJlIGFueXRoaW5nIHRvIGRlY29kZSBzbyB0aGlzXHJcbiAgICAvLyBzaG91bGQgYmUgYSBzYWZlIG9wZXJhdGlvbi4gIFRoaXMgYXZvaWRzIG5lZWRpbmcgbWF0Y2hSb3V0ZXMgdG8gYmVcclxuICAgIC8vIGhpc3RvcnktYXdhcmUuXHJcbiAgICBsZXQgZGVjb2RlZCA9IGRlY29kZVBhdGgocGF0aG5hbWUpO1xyXG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2goYnJhbmNoZXNbaV0sIGRlY29kZWQsIGFsbG93UGFydGlhbCk7XHJcbiAgfVxyXG4gIHJldHVybiBtYXRjaGVzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG1hdGNoLCBsb2FkZXJEYXRhKSB7XHJcbiAgbGV0IHtcclxuICAgIHJvdXRlLFxyXG4gICAgcGF0aG5hbWUsXHJcbiAgICBwYXJhbXNcclxuICB9ID0gbWF0Y2g7XHJcbiAgcmV0dXJuIHtcclxuICAgIGlkOiByb3V0ZS5pZCxcclxuICAgIHBhdGhuYW1lLFxyXG4gICAgcGFyYW1zLFxyXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXHJcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZmxhdHRlblJvdXRlcyhyb3V0ZXMsIGJyYW5jaGVzLCBwYXJlbnRzTWV0YSwgcGFyZW50UGF0aCkge1xyXG4gIGlmIChicmFuY2hlcyA9PT0gdm9pZCAwKSB7XHJcbiAgICBicmFuY2hlcyA9IFtdO1xyXG4gIH1cclxuICBpZiAocGFyZW50c01ldGEgPT09IHZvaWQgMCkge1xyXG4gICAgcGFyZW50c01ldGEgPSBbXTtcclxuICB9XHJcbiAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkge1xyXG4gICAgcGFyZW50UGF0aCA9IFwiXCI7XHJcbiAgfVxyXG4gIGxldCBmbGF0dGVuUm91dGUgPSAocm91dGUsIGluZGV4LCByZWxhdGl2ZVBhdGgpID0+IHtcclxuICAgIGxldCBtZXRhID0ge1xyXG4gICAgICByZWxhdGl2ZVBhdGg6IHJlbGF0aXZlUGF0aCA9PT0gdW5kZWZpbmVkID8gcm91dGUucGF0aCB8fCBcIlwiIDogcmVsYXRpdmVQYXRoLFxyXG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLFxyXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcclxuICAgICAgcm91dGVcclxuICAgIH07XHJcbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcclxuICAgICAgaW52YXJpYW50KG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCksIFwiQWJzb2x1dGUgcm91dGUgcGF0aCBcXFwiXCIgKyBtZXRhLnJlbGF0aXZlUGF0aCArIFwiXFxcIiBuZXN0ZWQgdW5kZXIgcGF0aCBcIiArIChcIlxcXCJcIiArIHBhcmVudFBhdGggKyBcIlxcXCIgaXMgbm90IHZhbGlkLiBBbiBhYnNvbHV0ZSBjaGlsZCByb3V0ZSBwYXRoIFwiKSArIFwibXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5cIik7XHJcbiAgICAgIG1ldGEucmVsYXRpdmVQYXRoID0gbWV0YS5yZWxhdGl2ZVBhdGguc2xpY2UocGFyZW50UGF0aC5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XHJcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcclxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSwgc28gd2UgdHJhdmVyc2UgdGhlXHJcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXHJcbiAgICAvLyB0aGUgXCJmbGF0dGVuZWRcIiB2ZXJzaW9uLlxyXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgaW52YXJpYW50KFxyXG4gICAgICAvLyBPdXIgdHlwZXMga25vdyBiZXR0ZXIsIGJ1dCBydW50aW1lIEpTIG1heSBub3QhXHJcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsIFwiSW5kZXggcm91dGVzIG11c3Qgbm90IGhhdmUgY2hpbGQgcm91dGVzLiBQbGVhc2UgcmVtb3ZlIFwiICsgKFwiYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIi5cIikpO1xyXG4gICAgICBmbGF0dGVuUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBicmFuY2hlcywgcm91dGVzTWV0YSwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcclxuICAgIC8vIGluZGV4IHJvdXRlcywgc28gZG9uJ3QgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgb2YgcG9zc2libGUgYnJhbmNoZXMuXHJcbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBicmFuY2hlcy5wdXNoKHtcclxuICAgICAgcGF0aCxcclxuICAgICAgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksXHJcbiAgICAgIHJvdXRlc01ldGFcclxuICAgIH0pO1xyXG4gIH07XHJcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xyXG4gICAgdmFyIF9yb3V0ZSRwYXRoO1xyXG4gICAgLy8gY29hcnNlLWdyYWluIGNoZWNrIGZvciBvcHRpb25hbCBwYXJhbXNcclxuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICEoKF9yb3V0ZSRwYXRoID0gcm91dGUucGF0aCkgIT0gbnVsbCAmJiBfcm91dGUkcGF0aC5pbmNsdWRlcyhcIj9cIikpKSB7XHJcbiAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcclxuICAgICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4LCBleHBsb2RlZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gYnJhbmNoZXM7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFsbCBjb21iaW5hdGlvbnMgb2Ygb3B0aW9uYWwgcGF0aCBzZWdtZW50cyBmb3IgYSBnaXZlbiBwYXRoLFxyXG4gKiBleGNsdWRpbmcgY29tYmluYXRpb25zIHRoYXQgYXJlIGFtYmlndW91cyBhbmQgb2YgbG93ZXIgcHJpb3JpdHkuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCBgL29uZS86dHdvPy90aHJlZS86Zm91cj8vOmZpdmU/YCBleHBsb2RlcyB0bzpcclxuICogLSBgL29uZS90aHJlZWBcclxuICogLSBgL29uZS86dHdvL3RocmVlYFxyXG4gKiAtIGAvb25lL3RocmVlLzpmb3VyYFxyXG4gKiAtIGAvb25lL3RocmVlLzpmaXZlYFxyXG4gKiAtIGAvb25lLzp0d28vdGhyZWUvOmZvdXJgXHJcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zml2ZWBcclxuICogLSBgL29uZS90aHJlZS86Zm91ci86Zml2ZWBcclxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyLzpmaXZlYFxyXG4gKi9cclxuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aCkge1xyXG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xyXG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcclxuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xyXG4gIC8vIE9wdGlvbmFsIHBhdGggc2VnbWVudHMgYXJlIGRlbm90ZWQgYnkgYSB0cmFpbGluZyBgP2BcclxuICBsZXQgaXNPcHRpb25hbCA9IGZpcnN0LmVuZHNXaXRoKFwiP1wiKTtcclxuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxyXG4gIGxldCByZXF1aXJlZCA9IGZpcnN0LnJlcGxhY2UoL1xcPyQvLCBcIlwiKTtcclxuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcclxuICAgIC8vIEludGVwcmV0IGVtcHR5IHN0cmluZyBhcyBvbWl0dGluZyBhbiBvcHRpb25hbCBzZWdtZW50XHJcbiAgICAvLyBgW1wib25lXCIsIFwiXCIsIFwidGhyZWVcIl1gIGNvcnJlc3BvbmRzIHRvIG9taXR0aW5nIGA6dHdvYCBmcm9tIGAvb25lLzp0d28/L3RocmVlYCAtPiBgL29uZS90aHJlZWBcclxuICAgIHJldHVybiBpc09wdGlvbmFsID8gW3JlcXVpcmVkLCBcIlwiXSA6IFtyZXF1aXJlZF07XHJcbiAgfVxyXG4gIGxldCByZXN0RXhwbG9kZWQgPSBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyZXN0LmpvaW4oXCIvXCIpKTtcclxuICBsZXQgcmVzdWx0ID0gW107XHJcbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXHJcbiAgLy8gb3B0aW9uYWwgdmVyc2lvbiBmb3IgYWxsIGNoaWxkcmVuLCBzbyB3ZSBnZXQgY29uc2lzdGVudCBvcmRlcmluZyB3aGVyZSB0aGVcclxuICAvLyBwYXJlbnQgb3B0aW9uYWwgYXNwZWN0IGlzIHByZWZlcnJlZCBhcyByZXF1aXJlZC4gIE90aGVyd2lzZSwgd2UgY2FuIGdldFxyXG4gIC8vIGNoaWxkIHNlY3Rpb25zIGludGVyc3BlcnNlZCB3aGVyZSBkZWVwZXIgb3B0aW9uYWwgc2VnbWVudHMgYXJlIGhpZ2hlciB0aGFuXHJcbiAgLy8gcGFyZW50IG9wdGlvbmFsIHNlZ21lbnRzLCB3aGVyZSBmb3IgZXhhbXBsZSwgLzp0d28gd291bGQgZXhwbG9kZSBfZWFybGllcl9cclxuICAvLyB0aGVuIC86b25lLiAgQnkgYWx3YXlzIGluY2x1ZGluZyB0aGUgcGFyZW50IGFzIHJlcXVpcmVkIF9mb3IgYWxsIGNoaWxkcmVuX1xyXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXHJcbiAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkLm1hcChzdWJwYXRoID0+IHN1YnBhdGggPT09IFwiXCIgPyByZXF1aXJlZCA6IFtyZXF1aXJlZCwgc3VicGF0aF0uam9pbihcIi9cIikpKTtcclxuICAvLyBUaGVuLCBpZiB0aGlzIGlzIGFuIG9wdGlvbmFsIHZhbHVlLCBhZGQgYWxsIGNoaWxkIHZlcnNpb25zIHdpdGhvdXRcclxuICBpZiAoaXNPcHRpb25hbCkge1xyXG4gICAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkKTtcclxuICB9XHJcbiAgLy8gZm9yIGFic29sdXRlIHBhdGhzLCBlbnN1cmUgYC9gIGluc3RlYWQgb2YgZW1wdHkgc2VnbWVudFxyXG4gIHJldHVybiByZXN1bHQubWFwKGV4cGxvZGVkID0+IHBhdGguc3RhcnRzV2l0aChcIi9cIikgJiYgZXhwbG9kZWQgPT09IFwiXCIgPyBcIi9cIiA6IGV4cGxvZGVkKTtcclxufVxyXG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xyXG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+IGEuc2NvcmUgIT09IGIuc2NvcmUgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcclxuICA6IGNvbXBhcmVJbmRleGVzKGEucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLCBiLnJvdXRlc01ldGEubWFwKG1ldGEgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSkpO1xyXG59XHJcbmNvbnN0IHBhcmFtUmUgPSAvXjpbXFx3LV0rJC87XHJcbmNvbnN0IGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xyXG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xyXG5jb25zdCBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XHJcbmNvbnN0IHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xyXG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcclxuY29uc3QgaXNTcGxhdCA9IHMgPT4gcyA9PT0gXCIqXCI7XHJcbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoLCBpbmRleCkge1xyXG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xyXG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XHJcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcclxuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XHJcbiAgfVxyXG4gIGlmIChpbmRleCkge1xyXG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHNlZ21lbnRzLmZpbHRlcihzID0+ICFpc1NwbGF0KHMpKS5yZWR1Y2UoKHNjb3JlLCBzZWdtZW50KSA9PiBzY29yZSArIChwYXJhbVJlLnRlc3Qoc2VnbWVudCkgPyBkeW5hbWljU2VnbWVudFZhbHVlIDogc2VnbWVudCA9PT0gXCJcIiA/IGVtcHR5U2VnbWVudFZhbHVlIDogc3RhdGljU2VnbWVudFZhbHVlKSwgaW5pdGlhbFNjb3JlKTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhLCBiKSB7XHJcbiAgbGV0IHNpYmxpbmdzID0gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuc2xpY2UoMCwgLTEpLmV2ZXJ5KChuLCBpKSA9PiBuID09PSBiW2ldKTtcclxuICByZXR1cm4gc2libGluZ3MgP1xyXG4gIC8vIElmIHR3byByb3V0ZXMgYXJlIHNpYmxpbmdzLCB3ZSBzaG91bGQgdHJ5IHRvIG1hdGNoIHRoZSBlYXJsaWVyIHNpYmxpbmdcclxuICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcclxuICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcclxuICAvLyB3YW50IHRoZW0gdHJpZWQuXHJcbiAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdIDpcclxuICAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXHJcbiAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXHJcbiAgMDtcclxufVxyXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaCwgcGF0aG5hbWUsIGFsbG93UGFydGlhbCkge1xyXG4gIGlmIChhbGxvd1BhcnRpYWwgPT09IHZvaWQgMCkge1xyXG4gICAgYWxsb3dQYXJ0aWFsID0gZmFsc2U7XHJcbiAgfVxyXG4gIGxldCB7XHJcbiAgICByb3V0ZXNNZXRhXHJcbiAgfSA9IGJyYW5jaDtcclxuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xyXG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcclxuICBsZXQgbWF0Y2hlcyA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xyXG4gICAgbGV0IGVuZCA9IGkgPT09IHJvdXRlc01ldGEubGVuZ3RoIC0gMTtcclxuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xyXG4gICAgbGV0IG1hdGNoID0gbWF0Y2hQYXRoKHtcclxuICAgICAgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsXHJcbiAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcclxuICAgICAgZW5kXHJcbiAgICB9LCByZW1haW5pbmdQYXRobmFtZSk7XHJcbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xyXG4gICAgaWYgKCFtYXRjaCAmJiBlbmQgJiYgYWxsb3dQYXJ0aWFsICYmICFyb3V0ZXNNZXRhW3JvdXRlc01ldGEubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXgpIHtcclxuICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoe1xyXG4gICAgICAgIHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLFxyXG4gICAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcclxuICAgICAgICBlbmQ6IGZhbHNlXHJcbiAgICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lKTtcclxuICAgIH1cclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XHJcbiAgICBtYXRjaGVzLnB1c2goe1xyXG4gICAgICAvLyBUT0RPOiBDYW4gdGhpcyBhcyBiZSBhdm9pZGVkP1xyXG4gICAgICBwYXJhbXM6IG1hdGNoZWRQYXJhbXMsXHJcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcclxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSkpLFxyXG4gICAgICByb3V0ZVxyXG4gICAgfSk7XHJcbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xyXG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPSBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBtYXRjaGVzO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvZ2VuZXJhdGUtcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG9yaWdpbmFsUGF0aCwgcGFyYW1zKSB7XHJcbiAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XHJcbiAgICBwYXJhbXMgPSB7fTtcclxuICB9XHJcbiAgbGV0IHBhdGggPSBvcmlnaW5hbFBhdGg7XHJcbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpICYmIHBhdGggIT09IFwiKlwiICYmICFwYXRoLmVuZHNXaXRoKFwiLypcIikpIHtcclxuICAgIHdhcm5pbmcoZmFsc2UsIFwiUm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiICsgKFwiXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIiBiZWNhdXNlIHRoZSBgKmAgY2hhcmFjdGVyIG11c3QgXCIpICsgXCJhbHdheXMgZm9sbG93IGEgYC9gIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgXCIgKyAoXCJwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIuXCIpKTtcclxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpO1xyXG4gIH1cclxuICAvLyBlbnN1cmUgYC9gIGlzIGFkZGVkIGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGVcclxuICBjb25zdCBwcmVmaXggPSBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCIvXCIgOiBcIlwiO1xyXG4gIGNvbnN0IHN0cmluZ2lmeSA9IHAgPT4gcCA9PSBudWxsID8gXCJcIiA6IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8gcCA6IFN0cmluZyhwKTtcclxuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoL1xcLysvKS5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xyXG4gICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxO1xyXG4gICAgLy8gb25seSBhcHBseSB0aGUgc3BsYXQgaWYgaXQncyB0aGUgbGFzdCBzZWdtZW50XHJcbiAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xyXG4gICAgICBjb25zdCBzdGFyID0gXCIqXCI7XHJcbiAgICAgIC8vIEFwcGx5IHRoZSBzcGxhdFxyXG4gICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtc1tzdGFyXSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXlNYXRjaCA9IHNlZ21lbnQubWF0Y2goL146KFtcXHctXSspKFxcPz8pJC8pO1xyXG4gICAgaWYgKGtleU1hdGNoKSB7XHJcbiAgICAgIGNvbnN0IFssIGtleSwgb3B0aW9uYWxdID0ga2V5TWF0Y2g7XHJcbiAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1trZXldO1xyXG4gICAgICBpbnZhcmlhbnQob3B0aW9uYWwgPT09IFwiP1wiIHx8IHBhcmFtICE9IG51bGwsIFwiTWlzc2luZyBcXFwiOlwiICsga2V5ICsgXCJcXFwiIHBhcmFtXCIpO1xyXG4gICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtKTtcclxuICAgIH1cclxuICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xyXG4gICAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvXFw/JC9nLCBcIlwiKTtcclxuICB9KVxyXG4gIC8vIFJlbW92ZSBlbXB0eSBzZWdtZW50c1xyXG4gIC5maWx0ZXIoc2VnbWVudCA9PiAhIXNlZ21lbnQpO1xyXG4gIHJldHVybiBwcmVmaXggKyBzZWdtZW50cy5qb2luKFwiL1wiKTtcclxufVxyXG4vKipcclxuICogUGVyZm9ybXMgcGF0dGVybiBtYXRjaGluZyBvbiBhIFVSTCBwYXRobmFtZSBhbmQgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dFxyXG4gKiB0aGUgbWF0Y2guXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvbWF0Y2gtcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSB7XHJcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICBwYXR0ZXJuID0ge1xyXG4gICAgICBwYXRoOiBwYXR0ZXJuLFxyXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZSxcclxuICAgICAgZW5kOiB0cnVlXHJcbiAgICB9O1xyXG4gIH1cclxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKHBhdHRlcm4ucGF0aCwgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLCBwYXR0ZXJuLmVuZCk7XHJcbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XHJcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XHJcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xyXG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xyXG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XHJcbiAgbGV0IHBhcmFtcyA9IGNvbXBpbGVkUGFyYW1zLnJlZHVjZSgobWVtbywgX3JlZiwgaW5kZXgpID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIHBhcmFtTmFtZSxcclxuICAgICAgaXNPcHRpb25hbFxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIHBhdGhuYW1lQmFzZSBoZXJlIHVzaW5nIHRoZSByYXcgc3BsYXQgdmFsdWVcclxuICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXHJcbiAgICBpZiAocGFyYW1OYW1lID09PSBcIipcIikge1xyXG4gICAgICBsZXQgc3BsYXRWYWx1ZSA9IGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCI7XHJcbiAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF07XHJcbiAgICBpZiAoaXNPcHRpb25hbCAmJiAhdmFsdWUpIHtcclxuICAgICAgbWVtb1twYXJhbU5hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWVtb1twYXJhbU5hbWVdID0gKHZhbHVlIHx8IFwiXCIpLnJlcGxhY2UoLyUyRi9nLCBcIi9cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVtbztcclxuICB9LCB7fSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHBhcmFtcyxcclxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXHJcbiAgICBwYXRobmFtZUJhc2UsXHJcbiAgICBwYXR0ZXJuXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjb21waWxlUGF0aChwYXRoLCBjYXNlU2Vuc2l0aXZlLCBlbmQpIHtcclxuICBpZiAoY2FzZVNlbnNpdGl2ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xyXG4gICAgZW5kID0gdHJ1ZTtcclxuICB9XHJcbiAgd2FybmluZyhwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLCBcIlJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiArIChcIlxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYCpgIGNoYXJhY3RlciBtdXN0IFwiKSArIFwiYWx3YXlzIGZvbGxvdyBhIGAvYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIFwiICsgKFwicGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiLlwiKSk7XHJcbiAgbGV0IHBhcmFtcyA9IFtdO1xyXG4gIGxldCByZWdleHBTb3VyY2UgPSBcIl5cIiArIHBhdGgucmVwbGFjZSgvXFwvKlxcKj8kLywgXCJcIikgLy8gSWdub3JlIHRyYWlsaW5nIC8gYW5kIC8qLCB3ZSdsbCBoYW5kbGUgaXQgYmVsb3dcclxuICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xyXG4gIC5yZXBsYWNlKC9bXFxcXC4qK14ke318KClbXFxdXS9nLCBcIlxcXFwkJlwiKSAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyc1xyXG4gIC5yZXBsYWNlKC9cXC86KFtcXHctXSspKFxcPyk/L2csIChfLCBwYXJhbU5hbWUsIGlzT3B0aW9uYWwpID0+IHtcclxuICAgIHBhcmFtcy5wdXNoKHtcclxuICAgICAgcGFyYW1OYW1lLFxyXG4gICAgICBpc09wdGlvbmFsOiBpc09wdGlvbmFsICE9IG51bGxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBcIi8/KFteXFxcXC9dKyk/XCIgOiBcIi8oW15cXFxcL10rKVwiO1xyXG4gIH0pO1xyXG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xyXG4gICAgcGFyYW1zLnB1c2goe1xyXG4gICAgICBwYXJhbU5hbWU6IFwiKlwiXHJcbiAgICB9KTtcclxuICAgIHJlZ2V4cFNvdXJjZSArPSBwYXRoID09PSBcIipcIiB8fCBwYXRoID09PSBcIi8qXCIgPyBcIiguKikkXCIgLy8gQWxyZWFkeSBtYXRjaGVkIHRoZSBpbml0aWFsIC8sIGp1c3QgbWF0Y2ggdGhlIHJlc3RcclxuICAgIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjsgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgLyBpbiBwYXJhbXNbXCIqXCJdXHJcbiAgfSBlbHNlIGlmIChlbmQpIHtcclxuICAgIC8vIFdoZW4gbWF0Y2hpbmcgdG8gdGhlIGVuZCwgaWdub3JlIHRyYWlsaW5nIHNsYXNoZXNcclxuICAgIHJlZ2V4cFNvdXJjZSArPSBcIlxcXFwvKiRcIjtcclxuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcclxuICAgIC8vIElmIG91ciBwYXRoIGlzIG5vbi1lbXB0eSBhbmQgY29udGFpbnMgYW55dGhpbmcgYmV5b25kIGFuIGluaXRpYWwgc2xhc2gsXHJcbiAgICAvLyB0aGVuIHdlIGhhdmUgX3NvbWVfIGZvcm0gb2YgcGF0aCBpbiBvdXIgcmVnZXgsIHNvIHdlIHNob3VsZCBleHBlY3QgdG9cclxuICAgIC8vIG1hdGNoIG9ubHkgaWYgd2UgZmluZCB0aGUgZW5kIG9mIHRoaXMgcGF0aCBzZWdtZW50LiAgTG9vayBmb3IgYW4gb3B0aW9uYWxcclxuICAgIC8vIG5vbi1jYXB0dXJlZCB0cmFpbGluZyBzbGFzaCAodG8gbWF0Y2ggYSBwb3J0aW9uIG9mIHRoZSBVUkwpIG9yIHRoZSBlbmRcclxuICAgIC8vIG9mIHRoZSBwYXRoIChpZiB3ZSd2ZSBtYXRjaGVkIHRvIHRoZSBlbmQpLiAgV2UgdXNlZCB0byBkbyB0aGlzIHdpdGggYVxyXG4gICAgLy8gd29yZCBib3VuZGFyeSBidXQgdGhhdCBnaXZlcyBmYWxzZSBwb3NpdGl2ZXMgb24gcm91dGVzIGxpa2VcclxuICAgIC8vIC91c2VyLXByZWZlcmVuY2VzIHNpbmNlIGAtYCBjb3VudHMgYXMgYSB3b3JkIGJvdW5kYXJ5LlxyXG4gICAgcmVnZXhwU291cmNlICs9IFwiKD86KD89XFxcXC98JCkpXCI7XHJcbiAgfSBlbHNlIDtcclxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogXCJpXCIpO1xyXG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1zXTtcclxufVxyXG5mdW5jdGlvbiBkZWNvZGVQYXRoKHZhbHVlKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiB2YWx1ZS5zcGxpdChcIi9cIikubWFwKHYgPT4gZGVjb2RlVVJJQ29tcG9uZW50KHYpLnJlcGxhY2UoL1xcLy9nLCBcIiUyRlwiKSkuam9pbihcIi9cIik7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHdhcm5pbmcoZmFsc2UsIFwiVGhlIFVSTCBwYXRoIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2UgaXQgaXMgaXMgYSBcIiArIFwibWFsZm9ybWVkIFVSTCBzZWdtZW50LiBUaGlzIGlzIHByb2JhYmx5IGR1ZSB0byBhIGJhZCBwZXJjZW50IFwiICsgKFwiZW5jb2RpbmcgKFwiICsgZXJyb3IgKyBcIikuXCIpKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSkge1xyXG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcclxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIC8vIFdlIHdhbnQgdG8gbGVhdmUgdHJhaWxpbmcgc2xhc2ggYmVoYXZpb3IgaW4gdGhlIHVzZXIncyBjb250cm9sLCBzbyBpZiB0aGV5XHJcbiAgLy8gc3BlY2lmeSBhIGJhc2VuYW1lIHdpdGggYSB0cmFpbGluZyBzbGFzaCwgd2Ugc2hvdWxkIHN1cHBvcnQgaXRcclxuICBsZXQgc3RhcnRJbmRleCA9IGJhc2VuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IGJhc2VuYW1lLmxlbmd0aCAtIDEgOiBiYXNlbmFtZS5sZW5ndGg7XHJcbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KHN0YXJ0SW5kZXgpO1xyXG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcclxuICAgIC8vIHBhdGhuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggYmFzZW5hbWUvXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL3Jlc29sdmUtcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG8sIGZyb21QYXRobmFtZSkge1xyXG4gIGlmIChmcm9tUGF0aG5hbWUgPT09IHZvaWQgMCkge1xyXG4gICAgZnJvbVBhdGhuYW1lID0gXCIvXCI7XHJcbiAgfVxyXG4gIGxldCB7XHJcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcclxuICAgIHNlYXJjaCA9IFwiXCIsXHJcbiAgICBoYXNoID0gXCJcIlxyXG4gIH0gPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XHJcbiAgbGV0IHBhdGhuYW1lID0gdG9QYXRobmFtZSA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgPyB0b1BhdGhuYW1lIDogcmVzb2x2ZVBhdGhuYW1lKHRvUGF0aG5hbWUsIGZyb21QYXRobmFtZSkgOiBmcm9tUGF0aG5hbWU7XHJcbiAgcmV0dXJuIHtcclxuICAgIHBhdGhuYW1lLFxyXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcclxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xyXG4gIGxldCBzZWdtZW50cyA9IGZyb21QYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcclxuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XHJcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xyXG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xyXG4gICAgICAvLyBLZWVwIHRoZSByb290IFwiXCIgc2VnbWVudCBzbyB0aGUgcGF0aG5hbWUgc3RhcnRzIGF0IC9cclxuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xyXG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xyXG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcclxufVxyXG5mdW5jdGlvbiBnZXRJbnZhbGlkUGF0aEVycm9yKGNoYXIsIGZpZWxkLCBkZXN0LCBwYXRoKSB7XHJcbiAgcmV0dXJuIFwiQ2Fubm90IGluY2x1ZGUgYSAnXCIgKyBjaGFyICsgXCInIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBcIiArIChcImB0by5cIiArIGZpZWxkICsgXCJgIGZpZWxkIFtcIiArIEpTT04uc3RyaW5naWZ5KHBhdGgpICsgXCJdLiAgUGxlYXNlIHNlcGFyYXRlIGl0IG91dCB0byB0aGUgXCIpICsgKFwiYHRvLlwiICsgZGVzdCArIFwiYCBmaWVsZC4gQWx0ZXJuYXRpdmVseSB5b3UgbWF5IHByb3ZpZGUgdGhlIGZ1bGwgcGF0aCBhcyBcIikgKyBcImEgc3RyaW5nIGluIDxMaW5rIHRvPVxcXCIuLi5cXFwiPiBhbmQgdGhlIHJvdXRlciB3aWxsIHBhcnNlIGl0IGZvciB5b3UuXCI7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIFdoZW4gcHJvY2Vzc2luZyByZWxhdGl2ZSBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gaWdub3JlIGFuY2VzdG9yIHJvdXRlcyB0aGF0XHJcbiAqIGRvIG5vdCBjb250cmlidXRlIHRvIHRoZSBwYXRoLCBzdWNoIHRoYXQgaW5kZXgvcGF0aGxlc3MgbGF5b3V0IHJvdXRlcyBkb24ndFxyXG4gKiBpbnRlcmZlcmUuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCB3aGVuIG1vdmluZyBhIHJvdXRlIGVsZW1lbnQgaW50byBhbiBpbmRleCByb3V0ZSBhbmQvb3IgYVxyXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxyXG4gKiB0aGUgc2FtZS4gIEJvdGggb2YgdGhlIGZvbGxvd2luZyBleGFtcGxlcyBzaG91bGQgbGluayBiYWNrIHRvIHRoZSByb290OlxyXG4gKlxyXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxyXG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiIGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0+XHJcbiAqICAgPC9Sb3V0ZT5cclxuICpcclxuICogICA8Um91dGUgcGF0aD1cIi9cIj5cclxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIj5cclxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXHJcbiAqICAgICAgICAgPFJvdXRlIGluZGV4IGVsZW1lbnQ9ezxMaW5rIHRvPVwiLi5cIn0gLz4gIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXHJcbiAqICAgICAgIDwvUm91dGVcclxuICogICAgIDwvUm91dGU+XHJcbiAqICAgPC9Sb3V0ZT5cclxuICovXHJcbmZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpIHtcclxuICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4gaW5kZXggPT09IDAgfHwgbWF0Y2gucm91dGUucGF0aCAmJiBtYXRjaC5yb3V0ZS5wYXRoLmxlbmd0aCA+IDApO1xyXG59XHJcbi8vIFJldHVybiB0aGUgYXJyYXkgb2YgcGF0aG5hbWVzIGZvciB0aGUgY3VycmVudCByb3V0ZSBtYXRjaGVzIC0gdXNlZCB0b1xyXG4vLyBnZW5lcmF0ZSB0aGUgcm91dGVQYXRobmFtZXMgaW5wdXQgZm9yIHJlc29sdmVUbygpXHJcbmZ1bmN0aW9uIGdldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgdjdfcmVsYXRpdmVTcGxhdFBhdGgpIHtcclxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcclxuICAvLyBXaGVuIHY3X3JlbGF0aXZlU3BsYXRQYXRoIGlzIGVuYWJsZWQsIHVzZSB0aGUgZnVsbCBwYXRobmFtZSBmb3IgdGhlIGxlYWZcclxuICAvLyBtYXRjaCBzbyB3ZSBpbmNsdWRlIHNwbGF0IHZhbHVlcyBmb3IgXCIuXCIgbGlua3MuICBTZWU6XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzExMDUyI2lzc3VlY29tbWVudC0xODM2NTg5MzI5XHJcbiAgaWYgKHY3X3JlbGF0aXZlU3BsYXRQYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKChtYXRjaCwgaWR4KSA9PiBpZHggPT09IHBhdGhNYXRjaGVzLmxlbmd0aCAtIDEgPyBtYXRjaC5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZSk7XHJcbiAgfVxyXG4gIHJldHVybiBwYXRoTWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVUbyh0b0FyZywgcm91dGVQYXRobmFtZXMsIGxvY2F0aW9uUGF0aG5hbWUsIGlzUGF0aFJlbGF0aXZlKSB7XHJcbiAgaWYgKGlzUGF0aFJlbGF0aXZlID09PSB2b2lkIDApIHtcclxuICAgIGlzUGF0aFJlbGF0aXZlID0gZmFsc2U7XHJcbiAgfVxyXG4gIGxldCB0bztcclxuICBpZiAodHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICB0byA9IHBhcnNlUGF0aCh0b0FyZyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRvID0gX2V4dGVuZHMoe30sIHRvQXJnKTtcclxuICAgIGludmFyaWFudCghdG8ucGF0aG5hbWUgfHwgIXRvLnBhdGhuYW1lLmluY2x1ZGVzKFwiP1wiKSwgZ2V0SW52YWxpZFBhdGhFcnJvcihcIj9cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiLCB0bykpO1xyXG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bykpO1xyXG4gICAgaW52YXJpYW50KCF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksIGdldEludmFsaWRQYXRoRXJyb3IoXCIjXCIsIFwic2VhcmNoXCIsIFwiaGFzaFwiLCB0bykpO1xyXG4gIH1cclxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcclxuICBsZXQgdG9QYXRobmFtZSA9IGlzRW1wdHlQYXRoID8gXCIvXCIgOiB0by5wYXRobmFtZTtcclxuICBsZXQgZnJvbTtcclxuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxyXG4gIC8vXHJcbiAgLy8gSWYgYSBwYXRobmFtZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIGB0b2AsIGl0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGVcclxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxyXG4gIC8vIG1pZ3JhdGlvbiBndWlkZSBmcm9tIHY1IGFzIGEgbWVhbnMgb2YgZGlzYW1iaWd1YXRpb24gYmV0d2VlbiBgdG9gIHZhbHVlc1xyXG4gIC8vIHRoYXQgYmVnaW4gd2l0aCBgL2AgYW5kIHRob3NlIHRoYXQgZG8gbm90LiBIb3dldmVyLCB0aGlzIGlzIHByb2JsZW1hdGljIGZvclxyXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXHJcbiAgLy8gaGFzaCBzdHJpbmcsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkIGFzc3VtZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIGlzIHJlbGF0aXZlXHJcbiAgLy8gdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24ncyBwYXRobmFtZSBhbmQgKm5vdCogdGhlIHJvdXRlIHBhdGhuYW1lLlxyXG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcclxuICAgIGZyb20gPSBsb2NhdGlvblBhdGhuYW1lO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcclxuICAgIC8vIFdpdGggcmVsYXRpdmU9XCJyb3V0ZVwiICh0aGUgZGVmYXVsdCksIGVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zXHJcbiAgICAvLyBcImdvIHVwIG9uZSByb3V0ZVwiIGluc3RlYWQgb2YgXCJnbyB1cCBvbmUgVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXlcclxuICAgIC8vIGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGEgbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhXHJcbiAgICAvLyBcInRvXCIgdmFsdWUgaW5zdGVhZCBvZiBhIFwiaHJlZlwiLlxyXG4gICAgaWYgKCFpc1BhdGhSZWxhdGl2ZSAmJiB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xyXG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xyXG4gICAgICB3aGlsZSAodG9TZWdtZW50c1swXSA9PT0gXCIuLlwiKSB7XHJcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xyXG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcclxuICAgIH1cclxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcclxuICB9XHJcbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XHJcbiAgLy8gRW5zdXJlIHRoZSBwYXRobmFtZSBoYXMgYSB0cmFpbGluZyBzbGFzaCBpZiB0aGUgb3JpZ2luYWwgXCJ0b1wiIGhhZCBvbmVcclxuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID0gdG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcclxuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxyXG4gIGxldCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCA9IChpc0VtcHR5UGF0aCB8fCB0b1BhdGhuYW1lID09PSBcIi5cIikgJiYgbG9jYXRpb25QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XHJcbiAgaWYgKCFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKSkge1xyXG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcclxuICB9XHJcbiAgcmV0dXJuIHBhdGg7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUb1BhdGhuYW1lKHRvKSB7XHJcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXHJcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiID8gXCIvXCIgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lIDogdG8ucGF0aG5hbWU7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBqb2luUGF0aHMgPSBwYXRocyA9PiBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBub3JtYWxpemVQYXRobmFtZSA9IHBhdGhuYW1lID0+IHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgbm9ybWFsaXplU2VhcmNoID0gc2VhcmNoID0+ICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIiA/IFwiXCIgOiBzZWFyY2guc3RhcnRzV2l0aChcIj9cIikgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBub3JtYWxpemVIYXNoID0gaGFzaCA9PiAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcclxuLyoqXHJcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgY3JlYXRpbmcgYGFwcGxpY2F0aW9uL2pzb25gIHJlc3BvbnNlcy4gQ29udmVydHMgYGRhdGFgXHJcbiAqIHRvIEpTT04gYW5kIHNldHMgdGhlIGBDb250ZW50LVR5cGVgIGhlYWRlci5cclxuICovXHJcbmNvbnN0IGpzb24gPSBmdW5jdGlvbiBqc29uKGRhdGEsIGluaXQpIHtcclxuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XHJcbiAgICBpbml0ID0ge307XHJcbiAgfVxyXG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHtcclxuICAgIHN0YXR1czogaW5pdFxyXG4gIH0gOiBpbml0O1xyXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xyXG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcclxuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwgX2V4dGVuZHMoe30sIHJlc3BvbnNlSW5pdCwge1xyXG4gICAgaGVhZGVyc1xyXG4gIH0pKTtcclxufTtcclxuY2xhc3MgRGF0YVdpdGhSZXNwb25zZUluaXQge1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEsIGluaXQpIHtcclxuICAgIHRoaXMudHlwZSA9IFwiRGF0YVdpdGhSZXNwb25zZUluaXRcIjtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmluaXQgPSBpbml0IHx8IG51bGw7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgXCJyZXNwb25zZXNcIiB0aGF0IGNvbnRhaW4gYHN0YXR1c2AvYGhlYWRlcnNgIHdpdGhvdXQgZm9yY2luZ1xyXG4gKiBzZXJpYWxpemF0aW9uIGludG8gYW4gYWN0dWFsIGBSZXNwb25zZWAgLSB1c2VkIGJ5IFJlbWl4IHNpbmdsZSBmZXRjaFxyXG4gKi9cclxuZnVuY3Rpb24gZGF0YShkYXRhLCBpbml0KSB7XHJcbiAgcmV0dXJuIG5ldyBEYXRhV2l0aFJlc3BvbnNlSW5pdChkYXRhLCB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHtcclxuICAgIHN0YXR1czogaW5pdFxyXG4gIH0gOiBpbml0KTtcclxufVxyXG5jbGFzcyBBYm9ydGVkRGVmZXJyZWRFcnJvciBleHRlbmRzIEVycm9yIHt9XHJcbmNsYXNzIERlZmVycmVkRGF0YSB7XHJcbiAgY29uc3RydWN0b3IoZGF0YSwgcmVzcG9uc2VJbml0KSB7XHJcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcclxuICAgIHRoaXMuZGVmZXJyZWRLZXlzID0gW107XHJcbiAgICBpbnZhcmlhbnQoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSwgXCJkZWZlcigpIG9ubHkgYWNjZXB0cyBwbGFpbiBvYmplY3RzXCIpO1xyXG4gICAgLy8gU2V0IHVwIGFuIEFib3J0Q29udHJvbGxlciArIFByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCB0byBleGl0IGVhcmx5XHJcbiAgICAvLyBjYW5jZWxsYXRpb25cclxuICAgIGxldCByZWplY3Q7XHJcbiAgICB0aGlzLmFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcclxuICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGxldCBvbkFib3J0ID0gKCkgPT4gcmVqZWN0KG5ldyBBYm9ydGVkRGVmZXJyZWRFcnJvcihcIkRlZmVycmVkIGRhdGEgYWJvcnRlZFwiKSk7XHJcbiAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwgPSAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcclxuICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xyXG4gICAgdGhpcy5kYXRhID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChhY2MsIF9yZWYyKSA9PiB7XHJcbiAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMjtcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCB7XHJcbiAgICAgICAgW2tleV06IHRoaXMudHJhY2tQcm9taXNlKGtleSwgdmFsdWUpXHJcbiAgICAgIH0pO1xyXG4gICAgfSwge30pO1xyXG4gICAgaWYgKHRoaXMuZG9uZSkge1xyXG4gICAgICAvLyBBbGwgaW5jb21pbmcgdmFsdWVzIHdlcmUgcmVzb2x2ZWRcclxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmluaXQgPSByZXNwb25zZUluaXQ7XHJcbiAgfVxyXG4gIHRyYWNrUHJvbWlzZShrZXksIHZhbHVlKSB7XHJcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHRoaXMuZGVmZXJyZWRLZXlzLnB1c2goa2V5KTtcclxuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuYWRkKGtleSk7XHJcbiAgICAvLyBXZSBzdG9yZSBhIGxpdHRsZSB3cmFwcGVyIHByb21pc2UgdGhhdCB3aWxsIGJlIGV4dGVuZGVkIHdpdGhcclxuICAgIC8vIF9kYXRhL19lcnJvciBwcm9wcyB1cG9uIHJlc29sdmUvcmVqZWN0XHJcbiAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmFjZShbdmFsdWUsIHRoaXMuYWJvcnRQcm9taXNlXSkudGhlbihkYXRhID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCB1bmRlZmluZWQsIGRhdGEpLCBlcnJvciA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgZXJyb3IpKTtcclxuICAgIC8vIFJlZ2lzdGVyIHJlamVjdGlvbiBsaXN0ZW5lcnMgdG8gYXZvaWQgdW5jYXVnaHQgcHJvbWlzZSByZWplY3Rpb25zIG9uXHJcbiAgICAvLyBlcnJvcnMgb3IgYWJvcnRlZCBkZWZlcnJlZCB2YWx1ZXNcclxuICAgIHByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xyXG4gICAgICBnZXQ6ICgpID0+IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbiAgfVxyXG4gIG9uU2V0dGxlKHByb21pc2UsIGtleSwgZXJyb3IsIGRhdGEpIHtcclxuICAgIGlmICh0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgJiYgZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvcikge1xyXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcclxuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5kZWxldGUoa2V5KTtcclxuICAgIGlmICh0aGlzLmRvbmUpIHtcclxuICAgICAgLy8gTm90aGluZyBsZWZ0IHRvIGFib3J0IVxyXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcclxuICAgIH1cclxuICAgIC8vIElmIHRoZSBwcm9taXNlIHdhcyByZXNvbHZlZC9yZWplY3RlZCB3aXRoIHVuZGVmaW5lZCwgd2UnbGwgdGhyb3cgYW4gZXJyb3IgYXMgeW91XHJcbiAgICAvLyBzaG91bGQgYWx3YXlzIHJlc29sdmUgd2l0aCBhIHZhbHVlIG9yIG51bGxcclxuICAgIGlmIChlcnJvciA9PT0gdW5kZWZpbmVkICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBsZXQgdW5kZWZpbmVkRXJyb3IgPSBuZXcgRXJyb3IoXCJEZWZlcnJlZCBkYXRhIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJlc29sdmVkL3JlamVjdGVkIHdpdGggYHVuZGVmaW5lZGAsIFwiICsgXCJ5b3UgbXVzdCByZXNvbHZlL3JlamVjdCB3aXRoIGEgdmFsdWUgb3IgYG51bGxgLlwiKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcclxuICAgICAgICBnZXQ6ICgpID0+IHVuZGVmaW5lZEVycm9yXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh1bmRlZmluZWRFcnJvcik7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBlcnJvclxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwge1xyXG4gICAgICBnZXQ6ICgpID0+IGRhdGFcclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG4gIGVtaXQoYWJvcnRlZCwgc2V0dGxlZEtleSkge1xyXG4gICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcihhYm9ydGVkLCBzZXR0bGVkS2V5KSk7XHJcbiAgfVxyXG4gIHN1YnNjcmliZShmbikge1xyXG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoZm4pO1xyXG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcclxuICB9XHJcbiAgY2FuY2VsKCkge1xyXG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmZvckVhY2goKHYsIGspID0+IHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGspKTtcclxuICAgIHRoaXMuZW1pdCh0cnVlKTtcclxuICB9XHJcbiAgYXN5bmMgcmVzb2x2ZURhdGEoc2lnbmFsKSB7XHJcbiAgICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xyXG4gICAgaWYgKCF0aGlzLmRvbmUpIHtcclxuICAgICAgbGV0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLmNhbmNlbCgpO1xyXG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xyXG4gICAgICBhYm9ydGVkID0gYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoYWJvcnRlZCA9PiB7XHJcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xyXG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoYWJvcnRlZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFib3J0ZWQ7XHJcbiAgfVxyXG4gIGdldCBkb25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ0tleXNTZXQuc2l6ZSA9PT0gMDtcclxuICB9XHJcbiAgZ2V0IHVud3JhcHBlZERhdGEoKSB7XHJcbiAgICBpbnZhcmlhbnQodGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSwgXCJDYW4gb25seSB1bndyYXAgZGF0YSBvbiBpbml0aWFsaXplZCBhbmQgc2V0dGxlZCBkZWZlcnJlZHNcIik7XHJcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5kYXRhKS5yZWR1Y2UoKGFjYywgX3JlZjMpID0+IHtcclxuICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWYzO1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHtcclxuICAgICAgICBba2V5XTogdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpXHJcbiAgICAgIH0pO1xyXG4gICAgfSwge30pO1xyXG4gIH1cclxuICBnZXQgcGVuZGluZ0tleXMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdLZXlzU2V0KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgJiYgdmFsdWUuX3RyYWNrZWQgPT09IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpIHtcclxuICBpZiAoIWlzVHJhY2tlZFByb21pc2UodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGlmICh2YWx1ZS5fZXJyb3IpIHtcclxuICAgIHRocm93IHZhbHVlLl9lcnJvcjtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlLl9kYXRhO1xyXG59XHJcbmNvbnN0IGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoZGF0YSwgaW5pdCkge1xyXG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcclxuICAgIGluaXQgPSB7fTtcclxuICB9XHJcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8ge1xyXG4gICAgc3RhdHVzOiBpbml0XHJcbiAgfSA6IGluaXQ7XHJcbiAgcmV0dXJuIG5ldyBEZWZlcnJlZERhdGEoZGF0YSwgcmVzcG9uc2VJbml0KTtcclxufTtcclxuLyoqXHJcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UuIFNldHMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgYExvY2F0aW9uYCBoZWFkZXIuXHJcbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXHJcbiAqL1xyXG5jb25zdCByZWRpcmVjdCA9IGZ1bmN0aW9uIHJlZGlyZWN0KHVybCwgaW5pdCkge1xyXG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcclxuICAgIGluaXQgPSAzMDI7XHJcbiAgfVxyXG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xyXG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICByZXNwb25zZUluaXQgPSB7XHJcbiAgICAgIHN0YXR1czogcmVzcG9uc2VJbml0XHJcbiAgICB9O1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XHJcbiAgfVxyXG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xyXG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcclxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIF9leHRlbmRzKHt9LCByZXNwb25zZUluaXQsIHtcclxuICAgIGhlYWRlcnNcclxuICB9KSk7XHJcbn07XHJcbi8qKlxyXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlIHRoYXQgd2lsbCBmb3JjZSBhIGRvY3VtZW50IHJlbG9hZCB0byB0aGUgbmV3IGxvY2F0aW9uLlxyXG4gKiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxyXG4gKiBEZWZhdWx0cyB0byBcIjMwMiBGb3VuZFwiLlxyXG4gKi9cclxuY29uc3QgcmVkaXJlY3REb2N1bWVudCA9ICh1cmwsIGluaXQpID0+IHtcclxuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xyXG4gIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIiwgXCJ0cnVlXCIpO1xyXG4gIHJldHVybiByZXNwb25zZTtcclxufTtcclxuLyoqXHJcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UgdGhhdCB3aWxsIHBlcmZvcm0gYSBgaGlzdG9yeS5yZXBsYWNlU3RhdGVgIGluc3RlYWQgb2YgYVxyXG4gKiBgaGlzdG9yeS5wdXNoU3RhdGVgIGZvciBjbGllbnQtc2lkZSBuYXZpZ2F0aW9uIHJlZGlyZWN0cy5cclxuICogU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cclxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cclxuICovXHJcbmNvbnN0IHJlcGxhY2UgPSAodXJsLCBpbml0KSA9PiB7XHJcbiAgbGV0IHJlc3BvbnNlID0gcmVkaXJlY3QodXJsLCBpbml0KTtcclxuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVwbGFjZVwiLCBcInRydWVcIik7XHJcbiAgcmV0dXJuIHJlc3BvbnNlO1xyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICogVXRpbGl0eSBjbGFzcyB3ZSB1c2UgdG8gaG9sZCBhdXRvLXVud3JhcHBlZCA0eHgvNXh4IFJlc3BvbnNlIGJvZGllc1xyXG4gKlxyXG4gKiBXZSBkb24ndCBleHBvcnQgdGhlIGNsYXNzIGZvciBwdWJsaWMgdXNlIHNpbmNlIGl0J3MgYW4gaW1wbGVtZW50YXRpb25cclxuICogZGV0YWlsLCBidXQgd2UgZXhwb3J0IHRoZSBpbnRlcmZhY2UgYWJvdmUgc28gZm9sa3MgY2FuIGJ1aWxkIHRoZWlyIG93blxyXG4gKiBhYnN0cmFjdGlvbnMgYXJvdW5kIGluc3RhbmNlcyB2aWEgaXNSb3V0ZUVycm9yUmVzcG9uc2UoKVxyXG4gKi9cclxuY2xhc3MgRXJyb3JSZXNwb25zZUltcGwge1xyXG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YSwgaW50ZXJuYWwpIHtcclxuICAgIGlmIChpbnRlcm5hbCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGludGVybmFsID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQgfHwgXCJcIjtcclxuICAgIHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcclxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgdGhpcy5kYXRhID0gZGF0YS50b1N0cmluZygpO1xyXG4gICAgICB0aGlzLmVycm9yID0gZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gRXJyb3JSZXNwb25zZSBnZW5lcmF0ZWQgZnJvbSBhIDR4eC81eHhcclxuICogUmVzcG9uc2UgdGhyb3duIGZyb20gYW4gYWN0aW9uL2xvYWRlclxyXG4gKi9cclxuZnVuY3Rpb24gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpIHtcclxuICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiYgXCJkYXRhXCIgaW4gZXJyb3I7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzQXJyID0gW1wicG9zdFwiLCBcInB1dFwiLCBcInBhdGNoXCIsIFwiZGVsZXRlXCJdO1xyXG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kcyA9IG5ldyBTZXQodmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIpO1xyXG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzQXJyID0gW1wiZ2V0XCIsIC4uLnZhbGlkTXV0YXRpb25NZXRob2RzQXJyXTtcclxuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kcyA9IG5ldyBTZXQodmFsaWRSZXF1ZXN0TWV0aG9kc0Fycik7XHJcbmNvbnN0IHJlZGlyZWN0U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xyXG5jb25zdCByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDcsIDMwOF0pO1xyXG5jb25zdCBJRExFX05BVklHQVRJT04gPSB7XHJcbiAgc3RhdGU6IFwiaWRsZVwiLFxyXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXHJcbiAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxyXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcclxuICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxyXG4gIGZvcm1EYXRhOiB1bmRlZmluZWQsXHJcbiAganNvbjogdW5kZWZpbmVkLFxyXG4gIHRleHQ6IHVuZGVmaW5lZFxyXG59O1xyXG5jb25zdCBJRExFX0ZFVENIRVIgPSB7XHJcbiAgc3RhdGU6IFwiaWRsZVwiLFxyXG4gIGRhdGE6IHVuZGVmaW5lZCxcclxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXHJcbiAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxyXG4gIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXHJcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcclxuICBqc29uOiB1bmRlZmluZWQsXHJcbiAgdGV4dDogdW5kZWZpbmVkXHJcbn07XHJcbmNvbnN0IElETEVfQkxPQ0tFUiA9IHtcclxuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcclxuICBwcm9jZWVkOiB1bmRlZmluZWQsXHJcbiAgcmVzZXQ6IHVuZGVmaW5lZCxcclxuICBsb2NhdGlvbjogdW5kZWZpbmVkXHJcbn07XHJcbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcclxuY29uc3QgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XHJcbiAgaGFzRXJyb3JCb3VuZGFyeTogQm9vbGVhbihyb3V0ZS5oYXNFcnJvckJvdW5kYXJ5KVxyXG59KTtcclxuY29uc3QgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVkgPSBcInJlbWl4LXJvdXRlci10cmFuc2l0aW9uc1wiO1xyXG4vLyNlbmRyZWdpb25cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8jcmVnaW9uIGNyZWF0ZVJvdXRlclxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vKipcclxuICogQ3JlYXRlIGEgcm91dGVyIGFuZCBsaXN0ZW4gdG8gaGlzdG9yeSBQT1AgbmF2aWdhdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihpbml0KSB7XHJcbiAgY29uc3Qgcm91dGVyV2luZG93ID0gaW5pdC53aW5kb3cgPyBpbml0LndpbmRvdyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XHJcbiAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHJvdXRlcldpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcclxuICBjb25zdCBpc1NlcnZlciA9ICFpc0Jyb3dzZXI7XHJcbiAgaW52YXJpYW50KGluaXQucm91dGVzLmxlbmd0aCA+IDAsIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlUm91dGVyXCIpO1xyXG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM7XHJcbiAgaWYgKGluaXQubWFwUm91dGVQcm9wZXJ0aWVzKSB7XHJcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBpbml0Lm1hcFJvdXRlUHJvcGVydGllcztcclxuICB9IGVsc2UgaWYgKGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xyXG4gICAgLy8gSWYgdGhleSBhcmUgc3RpbGwgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgdmVyc2lvbiwgd3JhcCBpdCB3aXRoIHRoZSBuZXcgQVBJXHJcbiAgICBsZXQgZGV0ZWN0RXJyb3JCb3VuZGFyeSA9IGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeTtcclxuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XHJcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpXHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcclxuICB9XHJcbiAgLy8gUm91dGVzIGtleWVkIGJ5IElEXHJcbiAgbGV0IG1hbmlmZXN0ID0ge307XHJcbiAgLy8gUm91dGVzIGluIHRyZWUgZm9ybWF0IGZvciBtYXRjaGluZ1xyXG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhpbml0LnJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcclxuICBsZXQgaW5GbGlnaHREYXRhUm91dGVzO1xyXG4gIGxldCBiYXNlbmFtZSA9IGluaXQuYmFzZW5hbWUgfHwgXCIvXCI7XHJcbiAgbGV0IGRhdGFTdHJhdGVneUltcGwgPSBpbml0LmRhdGFTdHJhdGVneSB8fCBkZWZhdWx0RGF0YVN0cmF0ZWd5O1xyXG4gIGxldCBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbkltcGwgPSBpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uO1xyXG4gIC8vIENvbmZpZyBkcml2ZW4gYmVoYXZpb3IgZmxhZ3NcclxuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xyXG4gICAgdjdfZmV0Y2hlclBlcnNpc3Q6IGZhbHNlLFxyXG4gICAgdjdfbm9ybWFsaXplRm9ybU1ldGhvZDogZmFsc2UsXHJcbiAgICB2N19wYXJ0aWFsSHlkcmF0aW9uOiBmYWxzZSxcclxuICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogZmFsc2UsXHJcbiAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogZmFsc2UsXHJcbiAgICB2N19za2lwQWN0aW9uRXJyb3JSZXZhbGlkYXRpb246IGZhbHNlXHJcbiAgfSwgaW5pdC5mdXR1cmUpO1xyXG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIGhpc3RvcnlcclxuICBsZXQgdW5saXN0ZW5IaXN0b3J5ID0gbnVsbDtcclxuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9ucyB0byBjYWxsIG9uIGFsbCBzdGF0ZSBjaGFuZ2VzXHJcbiAgbGV0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xyXG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgb2JqZWN0IHRvIGhvbGQgc2Nyb2xsIHJlc3RvcmF0aW9uIGxvY2F0aW9ucyBkdXJpbmcgcm91dGluZ1xyXG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XHJcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgc2Nyb2xsIHJlc3RvcmF0aW9uIGtleXNcclxuICBsZXQgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBudWxsO1xyXG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXHJcbiAgbGV0IGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcclxuICAvLyBPbmUtdGltZSBmbGFnIHRvIGNvbnRyb2wgdGhlIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbi4gIEJlY2F1c2VcclxuICAvLyB3ZSBkb24ndCBnZXQgdGhlIHNhdmVkIHBvc2l0aW9ucyBmcm9tIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB1bnRpbCBfYWZ0ZXJfXHJcbiAgLy8gdGhlIGluaXRpYWwgcmVuZGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZXBhcmF0ZSB1cGRhdGVTdGF0ZSB0b1xyXG4gIC8vIHNlbmQgYWxvbmcgdGhlIHJlc3RvcmVTY3JvbGxQb3NpdGlvblxyXG4gIC8vIFNldCB0byB0cnVlIGlmIHdlIGhhdmUgYGh5ZHJhdGlvbkRhdGFgIHNpbmNlIHdlIGFzc3VtZSB3ZSB3ZXJlIFNTUidkIGFuZCB0aGF0XHJcbiAgLy8gU1NSIGRpZCB0aGUgaW5pdGlhbCBzY3JvbGwgcmVzdG9yYXRpb24uXHJcbiAgbGV0IGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xyXG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbiwgYmFzZW5hbWUpO1xyXG4gIGxldCBpbml0aWFsRXJyb3JzID0gbnVsbDtcclxuICBpZiAoaW5pdGlhbE1hdGNoZXMgPT0gbnVsbCAmJiAhcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25JbXBsKSB7XHJcbiAgICAvLyBJZiB3ZSBkbyBub3QgbWF0Y2ggYSB1c2VyLXByb3ZpZGVkLXJvdXRlLCBmYWxsIGJhY2sgdG8gdGhlIHJvb3RcclxuICAgIC8vIHRvIGFsbG93IHRoZSBlcnJvciBib3VuZGFyeSB0byB0YWtlIG92ZXJcclxuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XHJcbiAgICAgIHBhdGhuYW1lOiBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcclxuICAgIH0pO1xyXG4gICAgbGV0IHtcclxuICAgICAgbWF0Y2hlcyxcclxuICAgICAgcm91dGVcclxuICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xyXG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xyXG4gICAgaW5pdGlhbEVycm9ycyA9IHtcclxuICAgICAgW3JvdXRlLmlkXTogZXJyb3JcclxuICAgIH07XHJcbiAgfVxyXG4gIC8vIEluIFNQQSBhcHBzLCBpZiB0aGUgdXNlciBwcm92aWRlZCBhIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uIGltcGxlbWVudGF0aW9uIGFuZFxyXG4gIC8vIG91ciBpbml0aWFsIG1hdGNoIGlzIGEgc3BsYXQgcm91dGUsIGNsZWFyIHRoZW0gb3V0IHNvIHdlIHJ1biB0aHJvdWdoIGxhenlcclxuICAvLyBkaXNjb3Zlcnkgb24gaHlkcmF0aW9uIGluIGNhc2UgdGhlcmUncyBhIG1vcmUgYWNjdXJhdGUgbGF6eSByb3V0ZSBtYXRjaC5cclxuICAvLyBJbiBTU1IgYXBwcyAod2l0aCBgaHlkcmF0aW9uRGF0YWApLCB3ZSBleHBlY3QgdGhhdCB0aGUgc2VydmVyIHdpbGwgc2VuZFxyXG4gIC8vIHVwIHRoZSBwcm9wZXIgbWF0Y2hlZCByb3V0ZXMgc28gd2UgZG9uJ3Qgd2FudCB0byBydW4gbGF6eSBkaXNjb3Zlcnkgb25cclxuICAvLyBpbml0aWFsIGh5ZHJhdGlvbiBhbmQgd2FudCB0byBoeWRyYXRlIGludG8gdGhlIHNwbGF0IHJvdXRlLlxyXG4gIGlmIChpbml0aWFsTWF0Y2hlcyAmJiAhaW5pdC5oeWRyYXRpb25EYXRhKSB7XHJcbiAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKGluaXRpYWxNYXRjaGVzLCBkYXRhUm91dGVzLCBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpO1xyXG4gICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSkge1xyXG4gICAgICBpbml0aWFsTWF0Y2hlcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGxldCBpbml0aWFsaXplZDtcclxuICBpZiAoIWluaXRpYWxNYXRjaGVzKSB7XHJcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgaW5pdGlhbE1hdGNoZXMgPSBbXTtcclxuICAgIC8vIElmIHBhcnRpYWwgaHlkcmF0aW9uIGFuZCBmb2cgb2Ygd2FyIGlzIGVuYWJsZWQsIHdlIHdpbGwgYmUgcnVubmluZ1xyXG4gICAgLy8gYHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uYCBkdXJpbmcgaHlkcmF0aW9uIHNvIGluY2x1ZGUgYW55IHBhcnRpYWwgbWF0Y2hlcyBhc1xyXG4gICAgLy8gdGhlIGluaXRpYWwgbWF0Y2hlcyBzbyB3ZSBjYW4gcHJvcGVybHkgcmVuZGVyIGBIeWRyYXRlRmFsbGJhY2tgJ3NcclxuICAgIGlmIChmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbikge1xyXG4gICAgICBsZXQgZm9nT2ZXYXIgPSBjaGVja0ZvZ09mV2FyKG51bGwsIGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSk7XHJcbiAgICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xyXG4gICAgICAgIGluaXRpYWxNYXRjaGVzID0gZm9nT2ZXYXIubWF0Y2hlcztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaW5pdGlhbE1hdGNoZXMuc29tZShtID0+IG0ucm91dGUubGF6eSkpIHtcclxuICAgIC8vIEFsbCBpbml0aWFsTWF0Y2hlcyBuZWVkIHRvIGJlIGxvYWRlZCBiZWZvcmUgd2UncmUgcmVhZHkuICBJZiB3ZSBoYXZlIGxhenlcclxuICAgIC8vIGZ1bmN0aW9ucyBhcm91bmQgc3RpbGwgdGhlbiB3ZSdsbCBuZWVkIHRvIHJ1biB0aGVtIGluIGluaXRpYWxpemUoKVxyXG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICB9IGVsc2UgaWYgKCFpbml0aWFsTWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5sb2FkZXIpKSB7XHJcbiAgICAvLyBJZiB3ZSd2ZSBnb3Qgbm8gbG9hZGVycyB0byBydW4sIHRoZW4gd2UncmUgZ29vZCB0byBnb1xyXG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24pIHtcclxuICAgIC8vIElmIHBhcnRpYWwgaHlkcmF0aW9uIGlzIGVuYWJsZWQsIHdlJ3JlIGluaXRpYWxpemVkIHNvIGxvbmcgYXMgd2Ugd2VyZVxyXG4gICAgLy8gcHJvdmlkZWQgd2l0aCBoeWRyYXRpb25EYXRhIGZvciBldmVyeSByb3V0ZSB3aXRoIGEgbG9hZGVyLCBhbmQgbm8gbG9hZGVyc1xyXG4gICAgLy8gd2VyZSBtYXJrZWQgZm9yIGV4cGxpY2l0IGh5ZHJhdGlvblxyXG4gICAgbGV0IGxvYWRlckRhdGEgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSA6IG51bGw7XHJcbiAgICBsZXQgZXJyb3JzID0gaW5pdC5oeWRyYXRpb25EYXRhID8gaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyA6IG51bGw7XHJcbiAgICAvLyBJZiBlcnJvcnMgZXhpc3QsIGRvbid0IGNvbnNpZGVyIHJvdXRlcyBiZWxvdyB0aGUgYm91bmRhcnlcclxuICAgIGlmIChlcnJvcnMpIHtcclxuICAgICAgbGV0IGlkeCA9IGluaXRpYWxNYXRjaGVzLmZpbmRJbmRleChtID0+IGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgaW5pdGlhbGl6ZWQgPSBpbml0aWFsTWF0Y2hlcy5zbGljZSgwLCBpZHggKyAxKS5ldmVyeShtID0+ICFzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihtLnJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuZXZlcnkobSA9PiAhc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24obS5yb3V0ZSwgbG9hZGVyRGF0YSwgZXJyb3JzKSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFdpdGhvdXQgcGFydGlhbCBoeWRyYXRpb24gLSB3ZSdyZSBpbml0aWFsaXplZCBpZiB3ZSB3ZXJlIHByb3ZpZGVkIGFueVxyXG4gICAgLy8gaHlkcmF0aW9uRGF0YSAtIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIGNvbXBsZXRlXHJcbiAgICBpbml0aWFsaXplZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xyXG4gIH1cclxuICBsZXQgcm91dGVyO1xyXG4gIGxldCBzdGF0ZSA9IHtcclxuICAgIGhpc3RvcnlBY3Rpb246IGluaXQuaGlzdG9yeS5hY3Rpb24sXHJcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxyXG4gICAgbWF0Y2hlczogaW5pdGlhbE1hdGNoZXMsXHJcbiAgICBpbml0aWFsaXplZCxcclxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcclxuICAgIC8vIERvbid0IHJlc3RvcmUgb24gaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGlmIHdlIHdlcmUgU1NSJ2RcclxuICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGwgPyBmYWxzZSA6IG51bGwsXHJcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxyXG4gICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcclxuICAgIGxvYWRlckRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSB8fCB7fSxcclxuICAgIGFjdGlvbkRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSB8fCBudWxsLFxyXG4gICAgZXJyb3JzOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyB8fCBpbml0aWFsRXJyb3JzLFxyXG4gICAgZmV0Y2hlcnM6IG5ldyBNYXAoKSxcclxuICAgIGJsb2NrZXJzOiBuZXcgTWFwKClcclxuICB9O1xyXG4gIC8vIC0tIFN0YXRlZnVsIGludGVybmFsIHZhcmlhYmxlcyB0byBtYW5hZ2UgbmF2aWdhdGlvbnMgLS1cclxuICAvLyBDdXJyZW50IG5hdmlnYXRpb24gaW4gcHJvZ3Jlc3MgKHRvIGJlIGNvbW1pdHRlZCBpbiBjb21wbGV0ZU5hdmlnYXRpb24pXHJcbiAgbGV0IHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xyXG4gIC8vIFNob3VsZCB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHByZXZlbnQgdGhlIHNjcm9sbCByZXNldCBpZiBzY3JvbGwgY2Fubm90XHJcbiAgLy8gYmUgcmVzdG9yZWQ/XHJcbiAgbGV0IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcclxuICAvLyBBYm9ydENvbnRyb2xsZXIgZm9yIHRoZSBhY3RpdmUgbmF2aWdhdGlvblxyXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXI7XHJcbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gZW5hYmxlIGRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24/XHJcbiAgbGV0IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcclxuICAvLyBTdG9yZSBhcHBsaWVkIHZpZXcgdHJhbnNpdGlvbnMgc28gd2UgY2FuIGFwcGx5IHRoZW0gb24gUE9QXHJcbiAgbGV0IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgLy8gQ2xlYW51cCBmdW5jdGlvbiBmb3IgcGVyc2lzdGluZyBhcHBsaWVkIHRyYW5zaXRpb25zIHRvIHNlc3Npb25TdG9yYWdlXHJcbiAgbGV0IHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciA9IG51bGw7XHJcbiAgLy8gV2UgdXNlIHRoaXMgdG8gYXZvaWQgdG91Y2hpbmcgaGlzdG9yeSBpbiBjb21wbGV0ZU5hdmlnYXRpb24gaWYgYVxyXG4gIC8vIHJldmFsaWRhdGlvbiBpcyBlbnRpcmVseSB1bmludGVycnVwdGVkXHJcbiAgbGV0IGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xyXG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGZsYWcgdG8gZm9yY2UgcmV2YWxpZGF0aW9uIG9mIGFsbCBsb2FkZXJzOlxyXG4gIC8vICAtIHN1Ym1pc3Npb25zIChjb21wbGV0ZWQgb3IgaW50ZXJydXB0ZWQpXHJcbiAgLy8gIC0gdXNlUmV2YWxpZGF0b3IoKVxyXG4gIC8vICAtIFgtUmVtaXgtUmV2YWxpZGF0ZSAoZnJvbSByZWRpcmVjdClcclxuICBsZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xyXG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgcm91dGVzIHRoYXQgcmVxdWlyZSByZXZhbGlkYXRpb24gZHVlXHJcbiAgLy8gdG8gYSBjYW5jZWxsZWQgZGVmZXJyZWQgb24gYWN0aW9uIHN1Ym1pc3Npb25cclxuICBsZXQgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMgPSBbXTtcclxuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIGZldGNoZXIgbG9hZHMgdGhhdCB3ZXJlIGNhbmNlbGxlZCBieSBhblxyXG4gIC8vIGFjdGlvbiBuYXZpZ2F0aW9uIGFuZCByZXF1aXJlIHJldmFsaWRhdGlvblxyXG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSBuZXcgU2V0KCk7XHJcbiAgLy8gQWJvcnRDb250cm9sbGVycyBmb3IgYW55IGluLWZsaWdodCBmZXRjaGVyc1xyXG4gIGxldCBmZXRjaENvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xyXG4gIC8vIFRyYWNrIGxvYWRzIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHN0YXJ0ZWRcclxuICBsZXQgaW5jcmVtZW50aW5nTG9hZElkID0gMDtcclxuICAvLyBUcmFjayB0aGUgb3V0c3RhbmRpbmcgcGVuZGluZyBuYXZpZ2F0aW9uIGRhdGEgbG9hZCB0byBiZSBjb21wYXJlZCBhZ2FpbnN0XHJcbiAgLy8gdGhlIGdsb2JhbGx5IGluY3JlbWVudGluZyBsb2FkIHdoZW4gYSBmZXRjaGVyIGxvYWQgbGFuZHMgYWZ0ZXIgYSBjb21wbGV0ZWRcclxuICAvLyBuYXZpZ2F0aW9uXHJcbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XHJcbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgZGF0YSByZWxvYWRzIGFzIGEgcmVzdWx0IG9mIHRoZWlyIGFjdGlvbnNcclxuICBsZXQgZmV0Y2hSZWxvYWRJZHMgPSBuZXcgTWFwKCk7XHJcbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgcmVkaXJlY3QgbmF2aWdhdGlvbnNcclxuICBsZXQgZmV0Y2hSZWRpcmVjdElkcyA9IG5ldyBTZXQoKTtcclxuICAvLyBNb3N0IHJlY2VudCBocmVmL21hdGNoIGZvciBmZXRjaGVyLmxvYWQgY2FsbHMgZm9yIGZldGNoZXJzXHJcbiAgbGV0IGZldGNoTG9hZE1hdGNoZXMgPSBuZXcgTWFwKCk7XHJcbiAgLy8gUmVmLWNvdW50IG1vdW50ZWQgZmV0Y2hlcnMgc28gd2Uga25vdyB3aGVuIGl0J3Mgb2sgdG8gY2xlYW4gdGhlbSB1cFxyXG4gIGxldCBhY3RpdmVGZXRjaGVycyA9IG5ldyBNYXAoKTtcclxuICAvLyBGZXRjaGVycyB0aGF0IGhhdmUgcmVxdWVzdGVkIGEgZGVsZXRlIHdoZW4gdXNpbmcgdjdfZmV0Y2hlclBlcnNpc3QsXHJcbiAgLy8gdGhleSdsbCBiZSBvZmZpY2lhbGx5IHJlbW92ZWQgYWZ0ZXIgdGhleSByZXR1cm4gdG8gaWRsZVxyXG4gIGxldCBkZWxldGVkRmV0Y2hlcnMgPSBuZXcgU2V0KCk7XHJcbiAgLy8gU3RvcmUgRGVmZXJyZWREYXRhIGluc3RhbmNlcyBmb3IgYWN0aXZlIHJvdXRlIG1hdGNoZXMuICBXaGVuIGFcclxuICAvLyByb3V0ZSBsb2FkZXIgcmV0dXJucyBkZWZlcigpIHdlIHN0aWNrIG9uZSBpbiBoZXJlLiAgVGhlbiwgd2hlbiBhIG5lc3RlZFxyXG4gIC8vIHByb21pc2UgcmVzb2x2ZXMgd2UgdXBkYXRlIGxvYWRlckRhdGEuICBJZiBhIG5ldyBuYXZpZ2F0aW9uIHN0YXJ0cyB3ZVxyXG4gIC8vIGNhbmNlbCBhY3RpdmUgZGVmZXJyZWRzIGZvciBlbGltaW5hdGVkIHJvdXRlcy5cclxuICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcCgpO1xyXG4gIC8vIFN0b3JlIGJsb2NrZXIgZnVuY3Rpb25zIGluIGEgc2VwYXJhdGUgTWFwIG91dHNpZGUgb2Ygcm91dGVyIHN0YXRlIHNpbmNlXHJcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgVUkgc3RhdGUgaWYgdGhleSBjaGFuZ2VcclxuICBsZXQgYmxvY2tlckZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAvLyBGbGFnIHRvIGlnbm9yZSB0aGUgbmV4dCBoaXN0b3J5IHVwZGF0ZSwgc28gd2UgY2FuIHJldmVydCB0aGUgVVJMIGNoYW5nZSBvblxyXG4gIC8vIGEgUE9QIG5hdmlnYXRpb24gdGhhdCB3YXMgYmxvY2tlZCBieSB0aGUgdXNlciB3aXRob3V0IHRvdWNoaW5nIHJvdXRlciBzdGF0ZVxyXG4gIGxldCB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUgPSB1bmRlZmluZWQ7XHJcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBhbGwgc2lkZSBlZmZlY3RzIHNob3VsZCBiZSBraWNrZWQgb2ZmIGZyb20gaGVyZS5cclxuICAvLyBJbXBsZW1lbnRlZCBhcyBhIEZsdWVudCBBUEkgZm9yIGVhc2Ugb2Y6XHJcbiAgLy8gICBsZXQgcm91dGVyID0gY3JlYXRlUm91dGVyKGluaXQpLmluaXRpYWxpemUoKTtcclxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG4gICAgLy8gSWYgaGlzdG9yeSBpbmZvcm1zIHVzIG9mIGEgUE9QIG5hdmlnYXRpb24sIHN0YXJ0IHRoZSBuYXZpZ2F0aW9uIGJ1dCBkbyBub3QgdXBkYXRlXHJcbiAgICAvLyBzdGF0ZS4gIFdlJ2xsIHVwZGF0ZSBvdXIgb3duIHN0YXRlIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXHJcbiAgICB1bmxpc3Rlbkhpc3RvcnkgPSBpbml0Lmhpc3RvcnkubGlzdGVuKF9yZWYgPT4ge1xyXG4gICAgICBsZXQge1xyXG4gICAgICAgIGFjdGlvbjogaGlzdG9yeUFjdGlvbixcclxuICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICBkZWx0YVxyXG4gICAgICB9ID0gX3JlZjtcclxuICAgICAgLy8gSWdub3JlIHRoaXMgZXZlbnQgaWYgaXQgd2FzIGp1c3QgdXMgcmVzZXR0aW5nIHRoZSBVUkwgZnJvbSBhXHJcbiAgICAgIC8vIGJsb2NrZWQgUE9QIG5hdmlnYXRpb25cclxuICAgICAgaWYgKHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSkge1xyXG4gICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSgpO1xyXG4gICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgd2FybmluZyhibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDAgfHwgZGVsdGEgIT0gbnVsbCwgXCJZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBibG9ja2VyIG9uIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiBcIiArIFwidGhhdCB3YXMgbm90IGNyZWF0ZWQgYnkgQHJlbWl4LXJ1bi9yb3V0ZXIuIFRoaXMgd2lsbCBmYWlsIHNpbGVudGx5IGluIFwiICsgXCJwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciBcIiArIFwidmlhIGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgL2B3aW5kb3cubG9jYXRpb24uaGFzaGAgaW5zdGVhZCBvZiB1c2luZyBcIiArIFwicm91dGVyIG5hdmlnYXRpb24gQVBJcy4gIFRoaXMgY2FuIGFsc28gaGFwcGVuIGlmIHlvdSBhcmUgdXNpbmcgXCIgKyBcImNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIik7XHJcbiAgICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcclxuICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxyXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb24sXHJcbiAgICAgICAgaGlzdG9yeUFjdGlvblxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGJsb2NrZXJLZXkgJiYgZGVsdGEgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIFVSTCB0byBtYXRjaCB0aGUgY3VycmVudCBVSSwgYnV0IGRvbid0IHVwZGF0ZSByb3V0ZXIgc3RhdGVcclxuICAgICAgICBsZXQgbmV4dEhpc3RvcnlVcGRhdGVQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICB1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGluaXQuaGlzdG9yeS5nbyhkZWx0YSAqIC0xKTtcclxuICAgICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcclxuICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcclxuICAgICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcclxuICAgICAgICAgIGxvY2F0aW9uLFxyXG4gICAgICAgICAgcHJvY2VlZCgpIHtcclxuICAgICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XHJcbiAgICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxyXG4gICAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIGxvY2F0aW9uXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBSZS1kbyB0aGUgc2FtZSBQT1AgbmF2aWdhdGlvbiB3ZSBqdXN0IGJsb2NrZWQsIGFmdGVyIHRoZSB1cmxcclxuICAgICAgICAgICAgLy8gcmVzdG9yYXRpb24gaXMgYWxzbyBjb21wbGV0ZS4gIFNlZTpcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzExNjEzXHJcbiAgICAgICAgICAgIG5leHRIaXN0b3J5VXBkYXRlUHJvbWlzZS50aGVuKCgpID0+IGluaXQuaGlzdG9yeS5nbyhkZWx0YSkpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJlc2V0KCkge1xyXG4gICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcclxuICAgICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XHJcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKHtcclxuICAgICAgICAgICAgICBibG9ja2Vyc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbik7XHJcbiAgICB9KTtcclxuICAgIGlmIChpc0Jyb3dzZXIpIHtcclxuICAgICAgLy8gRklYTUU6IFRoaXMgZmVlbHMgZ3Jvc3MuICBIb3cgY2FuIHdlIGNsZWFudXAgdGhlIGxpbmVzIGJldHdlZW5cclxuICAgICAgLy8gc2Nyb2xsUmVzdG9yYXRpb24vYXBwbGllZFRyYW5zaXRpb25zIHBlcnNpc3RhbmNlP1xyXG4gICAgICByZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XHJcbiAgICAgIGxldCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyA9ICgpID0+IHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcclxuICAgICAgcm91dGVyV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XHJcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHJvdXRlcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLy8gS2ljayBvZmYgaW5pdGlhbCBkYXRhIGxvYWQgaWYgbmVlZGVkLiAgVXNlIFBvcCB0byBhdm9pZCBtb2RpZnlpbmcgaGlzdG9yeVxyXG4gICAgLy8gTm90ZSB3ZSBkb24ndCBkbyBhbnkgaGFuZGxpbmcgb2YgbGF6eSBoZXJlLiAgRm9yIFNQQSdzIGl0J2xsIGdldCBoYW5kbGVkXHJcbiAgICAvLyBpbiB0aGUgbm9ybWFsIG5hdmlnYXRpb24gZmxvdy4gIEZvciBTU1IgaXQncyBleHBlY3RlZCB0aGF0IGxhenkgbW9kdWxlcyBhcmVcclxuICAgIC8vIHJlc29sdmVkIHByaW9yIHRvIHJvdXRlciBjcmVhdGlvbiBzaW5jZSB3ZSBjYW4ndCBnbyBpbnRvIGEgZmFsbGJhY2tFbGVtZW50XHJcbiAgICAvLyBVSSBmb3IgU1NSJ2QgYXBwc1xyXG4gICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCkge1xyXG4gICAgICBzdGFydE5hdmlnYXRpb24oQWN0aW9uLlBvcCwgc3RhdGUubG9jYXRpb24sIHtcclxuICAgICAgICBpbml0aWFsSHlkcmF0aW9uOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJvdXRlcjtcclxuICB9XHJcbiAgLy8gQ2xlYW4gdXAgYSByb3V0ZXIgYW5kIGl0J3Mgc2lkZSBlZmZlY3RzXHJcbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuICAgIGlmICh1bmxpc3Rlbkhpc3RvcnkpIHtcclxuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgfVxyXG4gICAgc3Vic2NyaWJlcnMuY2xlYXIoKTtcclxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcclxuICAgIHN0YXRlLmJsb2NrZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlQmxvY2tlcihrZXkpKTtcclxuICB9XHJcbiAgLy8gU3Vic2NyaWJlIHRvIHN0YXRlIHVwZGF0ZXMgZm9yIHRoZSByb3V0ZXJcclxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm4pIHtcclxuICAgIHN1YnNjcmliZXJzLmFkZChmbik7XHJcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcclxuICB9XHJcbiAgLy8gVXBkYXRlIG91ciBzdGF0ZSBhbmQgbm90aWZ5IHRoZSBjYWxsaW5nIGNvbnRleHQgb2YgdGhlIGNoYW5nZVxyXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBvcHRzKSB7XHJcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIG9wdHMgPSB7fTtcclxuICAgIH1cclxuICAgIHN0YXRlID0gX2V4dGVuZHMoe30sIHN0YXRlLCBuZXdTdGF0ZSk7XHJcbiAgICAvLyBQcmVwIGZldGNoZXIgY2xlYW51cCBzbyB3ZSBjYW4gdGVsbCB0aGUgVUkgd2hpY2ggZmV0Y2hlciBkYXRhIGVudHJpZXNcclxuICAgIC8vIGNhbiBiZSByZW1vdmVkXHJcbiAgICBsZXQgY29tcGxldGVkRmV0Y2hlcnMgPSBbXTtcclxuICAgIGxldCBkZWxldGVkRmV0Y2hlcnNLZXlzID0gW107XHJcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XHJcbiAgICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xyXG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImlkbGVcIikge1xyXG4gICAgICAgICAgaWYgKGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAvLyBVbm1vdW50ZWQgZnJvbSB0aGUgVUkgYW5kIGNhbiBiZSB0b3RhbGx5IHJlbW92ZWRcclxuICAgICAgICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm5lZCB0byBpZGxlIGJ1dCBzdGlsbCBtb3VudGVkIGluIHRoZSBVSSwgc28gc2VtaS1yZW1haW5zIGZvclxyXG4gICAgICAgICAgICAvLyByZXZhbGlkYXRpb25zIGFuZCBzdWNoXHJcbiAgICAgICAgICAgIGNvbXBsZXRlZEZldGNoZXJzLnB1c2goa2V5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGEgbG9jYWwgY29weSBzbyB0aGF0IGlmIGZsdXNoU3luYyBpcyB1c2VkIGFuZCB3ZSBlbmQgdXBcclxuICAgIC8vIHJlbW92aW5nIGFuZCBhZGRpbmcgYSBuZXcgc3Vic2NyaWJlciBkdWUgdG8gdGhlIHVzZUNhbGxiYWNrIGRlcGVuZGVuY2llcyxcclxuICAgIC8vIHdlIGRvbid0IGdldCBvdXJzZWx2ZXMgaW50byBhIGxvb3AgY2FsbGluZyB0aGUgbmV3IHN1YnNjcmliZXIgaW1tZWRpYXRlbHlcclxuICAgIFsuLi5zdWJzY3JpYmVyc10uZm9yRWFjaChzdWJzY3JpYmVyID0+IHN1YnNjcmliZXIoc3RhdGUsIHtcclxuICAgICAgZGVsZXRlZEZldGNoZXJzOiBkZWxldGVkRmV0Y2hlcnNLZXlzLFxyXG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHM6IG9wdHMudmlld1RyYW5zaXRpb25PcHRzLFxyXG4gICAgICBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlXHJcbiAgICB9KSk7XHJcbiAgICAvLyBSZW1vdmUgaWRsZSBmZXRjaGVycyBmcm9tIHN0YXRlIHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCBpbi1mbGlnaHQgZmV0Y2hlcnMuXHJcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XHJcbiAgICAgIGNvbXBsZXRlZEZldGNoZXJzLmZvckVhY2goa2V5ID0+IHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpKTtcclxuICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5mb3JFYWNoKGtleSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBDb21wbGV0ZSBhIG5hdmlnYXRpb24gcmV0dXJuaW5nIHRoZSBzdGF0ZS5uYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIElETEVfTkFWSUdBVElPTlxyXG4gIC8vIGFuZCBzZXR0aW5nIHN0YXRlLltoaXN0b3J5QWN0aW9uL2xvY2F0aW9uL21hdGNoZXNdIHRvIHRoZSBuZXcgcm91dGUuXHJcbiAgLy8gLSBMb2NhdGlvbiBpcyBhIHJlcXVpcmVkIHBhcmFtXHJcbiAgLy8gLSBOYXZpZ2F0aW9uIHdpbGwgYWx3YXlzIGJlIHNldCB0byBJRExFX05BVklHQVRJT05cclxuICAvLyAtIENhbiBwYXNzIGFueSBvdGhlciBzdGF0ZSBpbiBuZXdTdGF0ZVxyXG4gIGZ1bmN0aW9uIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgbmV3U3RhdGUsIF90ZW1wKSB7XHJcbiAgICB2YXIgX2xvY2F0aW9uJHN0YXRlLCBfbG9jYXRpb24kc3RhdGUyO1xyXG4gICAgbGV0IHtcclxuICAgICAgZmx1c2hTeW5jXHJcbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XHJcbiAgICAvLyBEZWR1Y2UgaWYgd2UncmUgaW4gYSBsb2FkaW5nL2FjdGlvblJlbG9hZCBzdGF0ZTpcclxuICAgIC8vIC0gV2UgaGF2ZSBjb21taXR0ZWQgYWN0aW9uRGF0YSBpbiB0aGUgc3RvcmVcclxuICAgIC8vIC0gVGhlIGN1cnJlbnQgbmF2aWdhdGlvbiB3YXMgYSBtdXRhdGlvbiBzdWJtaXNzaW9uXHJcbiAgICAvLyAtIFdlJ3JlIHBhc3QgdGhlIHN1Ym1pdHRpbmcgc3RhdGUgYW5kIGludG8gdGhlIGxvYWRpbmcgc3RhdGVcclxuICAgIC8vIC0gVGhlIGxvY2F0aW9uIGJlaW5nIGxvYWRlZCBpcyBub3QgdGhlIHJlc3VsdCBvZiBhIHJlZGlyZWN0XHJcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPSBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiYgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmICgoX2xvY2F0aW9uJHN0YXRlID0gbG9jYXRpb24uc3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfbG9jYXRpb24kc3RhdGUuX2lzUmVkaXJlY3QpICE9PSB0cnVlO1xyXG4gICAgbGV0IGFjdGlvbkRhdGE7XHJcbiAgICBpZiAobmV3U3RhdGUuYWN0aW9uRGF0YSkge1xyXG4gICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGFjdGlvbkRhdGEgPSBuZXdTdGF0ZS5hY3Rpb25EYXRhO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEVtcHR5IGFjdGlvbkRhdGEgLT4gY2xlYXIgcHJpb3IgYWN0aW9uRGF0YSBkdWUgdG8gYW4gYWN0aW9uIGVycm9yXHJcbiAgICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXNBY3Rpb25SZWxvYWQpIHtcclxuICAgICAgLy8gS2VlcCB0aGUgY3VycmVudCBkYXRhIGlmIHdlJ3JlIHdyYXBwaW5nIHVwIHRoZSBhY3Rpb24gcmVsb2FkXHJcbiAgICAgIGFjdGlvbkRhdGEgPSBzdGF0ZS5hY3Rpb25EYXRhO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ2xlYXIgYWN0aW9uRGF0YSBvbiBhbnkgb3RoZXIgY29tcGxldGVkIG5hdmlnYXRpb25zXHJcbiAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gQWx3YXlzIHByZXNlcnZlIGFueSBleGlzdGluZyBsb2FkZXJEYXRhIGZyb20gcmUtdXNlZCByb3V0ZXNcclxuICAgIGxldCBsb2FkZXJEYXRhID0gbmV3U3RhdGUubG9hZGVyRGF0YSA/IG1lcmdlTG9hZGVyRGF0YShzdGF0ZS5sb2FkZXJEYXRhLCBuZXdTdGF0ZS5sb2FkZXJEYXRhLCBuZXdTdGF0ZS5tYXRjaGVzIHx8IFtdLCBuZXdTdGF0ZS5lcnJvcnMpIDogc3RhdGUubG9hZGVyRGF0YTtcclxuICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9uIHdlIGNhbiBhc3N1bWUgd2UgZ290IHRocm91Z2ggYWxsIGJsb2NrZXJzXHJcbiAgICAvLyBzbyB3ZSBjYW4gc3RhcnQgZnJlc2hcclxuICAgIGxldCBibG9ja2VycyA9IHN0YXRlLmJsb2NrZXJzO1xyXG4gICAgaWYgKGJsb2NrZXJzLnNpemUgPiAwKSB7XHJcbiAgICAgIGJsb2NrZXJzID0gbmV3IE1hcChibG9ja2Vycyk7XHJcbiAgICAgIGJsb2NrZXJzLmZvckVhY2goKF8sIGspID0+IGJsb2NrZXJzLnNldChrLCBJRExFX0JMT0NLRVIpKTtcclxuICAgIH1cclxuICAgIC8vIEFsd2F5cyByZXNwZWN0IHRoZSB1c2VyIGZsYWcuICBPdGhlcndpc2UgZG9uJ3QgcmVzZXQgb24gbXV0YXRpb25cclxuICAgIC8vIHN1Ym1pc3Npb24gbmF2aWdhdGlvbnMgdW5sZXNzIHRoZXkgcmVkaXJlY3RcclxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIHx8IHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJiAoKF9sb2NhdGlvbiRzdGF0ZTIgPSBsb2NhdGlvbi5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2NhdGlvbiRzdGF0ZTIuX2lzUmVkaXJlY3QpICE9PSB0cnVlO1xyXG4gICAgLy8gQ29tbWl0IGFueSBpbi1mbGlnaHQgcm91dGVzIGF0IHRoZSBlbmQgb2YgdGhlIEhNUiByZXZhbGlkYXRpb24gXCJuYXZpZ2F0aW9uXCJcclxuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcclxuICAgICAgZGF0YVJvdXRlcyA9IGluRmxpZ2h0RGF0YVJvdXRlcztcclxuICAgICAgaW5GbGlnaHREYXRhUm91dGVzID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgOyBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBBY3Rpb24uUG9wKSA7IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5QdXNoKSB7XHJcbiAgICAgIGluaXQuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5SZXBsYWNlKSB7XHJcbiAgICAgIGluaXQuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBsZXQgdmlld1RyYW5zaXRpb25PcHRzO1xyXG4gICAgLy8gT24gUE9QLCBlbmFibGUgdHJhbnNpdGlvbnMgaWYgdGhleSB3ZXJlIGVuYWJsZWQgb24gdGhlIG9yaWdpbmFsIG5hdmlnYXRpb25cclxuICAgIGlmIChwZW5kaW5nQWN0aW9uID09PSBBY3Rpb24uUG9wKSB7XHJcbiAgICAgIC8vIEZvcndhcmQgdGFrZXMgcHJlY2VkZW5jZSBzbyB0aGV5IGJlaGF2ZSBsaWtlIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXHJcbiAgICAgIGxldCBwcmlvclBhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xyXG4gICAgICBpZiAocHJpb3JQYXRocyAmJiBwcmlvclBhdGhzLmhhcyhsb2NhdGlvbi5wYXRobmFtZSkpIHtcclxuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XHJcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxyXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSBpZiAoYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHByZXZpb3VzIGZvcndhcmQgbmF2LCBhc3N1bWUgd2UncmUgcG9wcGluZyBiYWNrIHRvXHJcbiAgICAgICAgLy8gdGhlIG5ldyBsb2NhdGlvbiBhbmQgZW5hYmxlIGlmIHRoYXQgbG9jYXRpb24gcHJldmlvdXNseSBlbmFibGVkXHJcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xyXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBsb2NhdGlvbixcclxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcclxuICAgICAgLy8gU3RvcmUgdGhlIGFwcGxpZWQgdHJhbnNpdGlvbiBvbiBQVVNIL1JFUExBQ0VcclxuICAgICAgbGV0IHRvUGF0aHMgPSBhcHBsaWVkVmlld1RyYW5zaXRpb25zLmdldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSk7XHJcbiAgICAgIGlmICh0b1BhdGhzKSB7XHJcbiAgICAgICAgdG9QYXRocy5hZGQobG9jYXRpb24ucGF0aG5hbWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRvUGF0aHMgPSBuZXcgU2V0KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xyXG4gICAgICAgIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuc2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLCB0b1BhdGhzKTtcclxuICAgICAgfVxyXG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XHJcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcclxuICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTdGF0ZShfZXh0ZW5kcyh7fSwgbmV3U3RhdGUsIHtcclxuICAgICAgYWN0aW9uRGF0YSxcclxuICAgICAgbG9hZGVyRGF0YSxcclxuICAgICAgaGlzdG9yeUFjdGlvbjogcGVuZGluZ0FjdGlvbixcclxuICAgICAgbG9jYXRpb24sXHJcbiAgICAgIGluaXRpYWxpemVkOiB0cnVlLFxyXG4gICAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXHJcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXHJcbiAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbmV3U3RhdGUubWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzKSxcclxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxyXG4gICAgICBibG9ja2Vyc1xyXG4gICAgfSksIHtcclxuICAgICAgdmlld1RyYW5zaXRpb25PcHRzLFxyXG4gICAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyA9PT0gdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyBSZXNldCBzdGF0ZWZ1bCBuYXZpZ2F0aW9uIHZhcnNcclxuICAgIHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xyXG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xyXG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XHJcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XHJcbiAgICBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyA9IFtdO1xyXG4gIH1cclxuICAvLyBUcmlnZ2VyIGEgbmF2aWdhdGlvbiBldmVudCwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIG51bWVyaWNhbCBQT1Agb3IgYSBQVVNIXHJcbiAgLy8gcmVwbGFjZSB3aXRoIGFuIG9wdGlvbmFsIHN1Ym1pc3Npb25cclxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0cykge1xyXG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICBpbml0Lmhpc3RvcnkuZ28odG8pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcywgYmFzZW5hbWUsIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsIHRvLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgsIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnJvbVJvdXRlSWQsIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVsYXRpdmUpO1xyXG4gICAgbGV0IHtcclxuICAgICAgcGF0aCxcclxuICAgICAgc3VibWlzc2lvbixcclxuICAgICAgZXJyb3JcclxuICAgIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoZnV0dXJlLnY3X25vcm1hbGl6ZUZvcm1NZXRob2QsIGZhbHNlLCBub3JtYWxpemVkUGF0aCwgb3B0cyk7XHJcbiAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhdGUubG9jYXRpb247XHJcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XHJcbiAgICAvLyBXaGVuIHVzaW5nIG5hdmlnYXRlIGFzIGEgUFVTSC9SRVBMQUNFIHdlIGFyZW4ndCByZWFkaW5nIGFuIGFscmVhZHktZW5jb2RlZFxyXG4gICAgLy8gVVJMIGZyb20gd2luZG93LmxvY2F0aW9uLCBzbyB3ZSBuZWVkIHRvIGVuY29kZSBpdCBoZXJlIHNvIHRoZSBiZWhhdmlvclxyXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcclxuICAgIC8vIHRoZSBzYW1lIGVuY29kaW5nIHdlJ2QgZ2V0IGZyb20gYSBoaXN0b3J5LnB1c2hTdGF0ZS93aW5kb3cubG9jYXRpb24gcmVhZFxyXG4gICAgLy8gd2l0aG91dCBoYXZpbmcgdG8gdG91Y2ggaGlzdG9yeVxyXG4gICAgbmV4dExvY2F0aW9uID0gX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwgaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbikpO1xyXG4gICAgbGV0IHVzZXJSZXBsYWNlID0gb3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCA/IG9wdHMucmVwbGFjZSA6IHVuZGVmaW5lZDtcclxuICAgIGxldCBoaXN0b3J5QWN0aW9uID0gQWN0aW9uLlB1c2g7XHJcbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcclxuICAgICAgaGlzdG9yeUFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xyXG4gICAgfSBlbHNlIGlmICh1c2VyUmVwbGFjZSA9PT0gZmFsc2UpIDsgZWxzZSBpZiAoc3VibWlzc2lvbiAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSAmJiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoKSB7XHJcbiAgICAgIC8vIEJ5IGRlZmF1bHQgb24gc3VibWlzc2lvbnMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gd2UgUkVQTEFDRSBzbyB0aGF0XHJcbiAgICAgIC8vIHVzZXJzIGRvbid0IGhhdmUgdG8gZG91YmxlLWNsaWNrIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgdG8gdGhlIHByaW9yXHJcbiAgICAgIC8vIGxvY2F0aW9uLiAgSWYgdGhlIHVzZXIgcmVkaXJlY3RzIHRvIGEgZGlmZmVyZW50IGxvY2F0aW9uIGZyb20gdGhlXHJcbiAgICAgIC8vIGFjdGlvbi9sb2FkZXIgdGhpcyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSByZWRpcmVjdCB3aWxsIGJlIGEgUFVTSFxyXG4gICAgICBoaXN0b3J5QWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XHJcbiAgICB9XHJcbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHMgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSA6IHVuZGVmaW5lZDtcclxuICAgIGxldCBmbHVzaFN5bmMgPSAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWU7XHJcbiAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XHJcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcclxuICAgICAgbmV4dExvY2F0aW9uLFxyXG4gICAgICBoaXN0b3J5QWN0aW9uXHJcbiAgICB9KTtcclxuICAgIGlmIChibG9ja2VyS2V5KSB7XHJcbiAgICAgIC8vIFB1dCB0aGUgYmxvY2tlciBpbnRvIGEgYmxvY2tlZCBzdGF0ZVxyXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcclxuICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXHJcbiAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcclxuICAgICAgICBwcm9jZWVkKCkge1xyXG4gICAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XHJcbiAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcclxuICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICByZXNldDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIC8vIFNlbmQgdGhlIHNhbWUgbmF2aWdhdGlvbiB0aHJvdWdoXHJcbiAgICAgICAgICBuYXZpZ2F0ZSh0bywgb3B0cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXNldCgpIHtcclxuICAgICAgICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xyXG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XHJcbiAgICAgICAgICB1cGRhdGVTdGF0ZSh7XHJcbiAgICAgICAgICAgIGJsb2NrZXJzXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXdhaXQgc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIG5leHRMb2NhdGlvbiwge1xyXG4gICAgICBzdWJtaXNzaW9uLFxyXG4gICAgICAvLyBTZW5kIHRocm91Z2ggdGhlIGZvcm1EYXRhIHNlcmlhbGl6YXRpb24gZXJyb3IgaWYgd2UgaGF2ZSBvbmUgc28gd2UgY2FuXHJcbiAgICAgIC8vIHJlbmRlciBhdCB0aGUgcmlnaHQgZXJyb3IgYm91bmRhcnkgYWZ0ZXIgd2UgbWF0Y2ggcm91dGVzXHJcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXHJcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcclxuICAgICAgcmVwbGFjZTogb3B0cyAmJiBvcHRzLnJlcGxhY2UsXHJcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudmlld1RyYW5zaXRpb24sXHJcbiAgICAgIGZsdXNoU3luY1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8vIFJldmFsaWRhdGUgYWxsIGN1cnJlbnQgbG9hZGVycy4gIElmIGEgbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzcyBvciBpZiB0aGlzXHJcbiAgLy8gaXMgaW50ZXJydXB0ZWQgYnkgYSBuYXZpZ2F0aW9uLCBhbGxvdyB0aGlzIHRvIFwic3VjY2VlZFwiIGJ5IGNhbGxpbmcgYWxsXHJcbiAgLy8gbG9hZGVycyBkdXJpbmcgdGhlIG5leHQgbG9hZGVyIHJvdW5kXHJcbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcclxuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XHJcbiAgICB1cGRhdGVTdGF0ZSh7XHJcbiAgICAgIHJldmFsaWRhdGlvbjogXCJsb2FkaW5nXCJcclxuICAgIH0pO1xyXG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHN1Ym1pdHRpbmcgYW4gYWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHN0YXJ0IGEgbmV3XHJcbiAgICAvLyBuYXZpZ2F0aW9uLCB3ZSdsbCBqdXN0IGxldCB0aGUgZm9sbG93IHVwIGxvYWRlciBleGVjdXRpb24gY2FsbCBhbGwgbG9hZGVyc1xyXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwic3VibWl0dGluZ1wiKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBpbiBhbiBpZGxlIHN0YXRlLCBzdGFydCBhIG5ldyBuYXZpZ2F0aW9uIGZvciB0aGUgY3VycmVudFxyXG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxyXG4gICAgLy8gdXBkYXRlIGluIGNvbXBsZXRlTmF2aWdhdGlvblxyXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XHJcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xyXG4gICAgICAgIHN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbjogdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSdyZSBjdXJyZW50bHkgaW4gYSBsb2FkaW5nIHN0YXRlLCBqdXN0IHN0YXJ0IGEgbmV3XHJcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXHJcbiAgICAvLyByZXZhbGlkYXRpb24gc28gdGhhdCBoaXN0b3J5IGNvcnJlY3RseSB1cGRhdGVzIG9uY2UgdGhlIG5hdmlnYXRpb24gY29tcGxldGVzXHJcbiAgICBzdGFydE5hdmlnYXRpb24ocGVuZGluZ0FjdGlvbiB8fCBzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XHJcbiAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvbixcclxuICAgICAgLy8gUHJveHkgdGhyb3VnaCBhbnkgcmVuZGluZyB2aWV3IHRyYW5zaXRpb25cclxuICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPT09IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyBTdGFydCBhIG5hdmlnYXRpb24gdG8gdGhlIGdpdmVuIGFjdGlvbi9sb2NhdGlvbi4gIENhbiBvcHRpb25hbGx5IHByb3ZpZGUgYVxyXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcclxuICAvLyBuYXZpZ2F0aW9uXHJcbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIGxvY2F0aW9uLCBvcHRzKSB7XHJcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcclxuICAgIC8vIHVuaW50ZXJydXB0ZWQgcmV2YWxpZGF0aW9ucyB1bmxlc3MgdG9sZCBvdGhlcndpc2UsIHNpbmNlIHdlIHdhbnQgdGhpc1xyXG4gICAgLy8gbmV3IG5hdmlnYXRpb24gdG8gdXBkYXRlIGhpc3Rvcnkgbm9ybWFsbHlcclxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XHJcbiAgICBwZW5kaW5nQWN0aW9uID0gaGlzdG9yeUFjdGlvbjtcclxuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcclxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGV2ZXJ5IHRpbWUgd2Ugc3RhcnQgYSBuZXcgbmF2aWdhdGlvbixcclxuICAgIC8vIGFuZCB0cmFjayB3aGV0aGVyIHdlIHNob3VsZCByZXNldCBzY3JvbGwgb24gY29tcGxldGlvblxyXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcclxuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XHJcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gKG9wdHMgJiYgb3B0cy5lbmFibGVWaWV3VHJhbnNpdGlvbikgPT09IHRydWU7XHJcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcclxuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG9wdHMgJiYgb3B0cy5vdmVycmlkZU5hdmlnYXRpb247XHJcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xyXG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcclxuICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIGxvY2F0aW9uLnBhdGhuYW1lKTtcclxuICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xyXG4gICAgICBtYXRjaGVzID0gZm9nT2ZXYXIubWF0Y2hlcztcclxuICAgIH1cclxuICAgIC8vIFNob3J0IGNpcmN1aXQgd2l0aCBhIDQwNCBvbiB0aGUgcm9vdCBlcnJvciBib3VuZGFyeSBpZiB3ZSBtYXRjaCBub3RoaW5nXHJcbiAgICBpZiAoIW1hdGNoZXMpIHtcclxuICAgICAgbGV0IHtcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBub3RGb3VuZE1hdGNoZXMsXHJcbiAgICAgICAgcm91dGVcclxuICAgICAgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChsb2NhdGlvbi5wYXRobmFtZSk7XHJcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xyXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcclxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcclxuICAgICAgICBlcnJvcnM6IHtcclxuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB7XHJcbiAgICAgICAgZmx1c2hTeW5jXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGl0J3Mgb25seSBhIGhhc2ggY2hhbmdlIGFuZCBub3QgYSByZXZhbGlkYXRpb24gb3JcclxuICAgIC8vIG11dGF0aW9uIHN1Ym1pc3Npb24uXHJcbiAgICAvL1xyXG4gICAgLy8gSWdub3JlIG9uIGluaXRpYWwgcGFnZSBsb2FkcyBiZWNhdXNlIHNpbmNlIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiB3aWxsIGFsd2F5c1xyXG4gICAgLy8gYmUgXCJzYW1lIGhhc2hcIi4gIEZvciBleGFtcGxlLCBvbiAvcGFnZSNoYXNoIGFuZCBzdWJtaXQgYSA8Rm9ybSBtZXRob2Q9XCJwb3N0XCI+XHJcbiAgICAvLyB3aGljaCB3aWxsIGRlZmF1bHQgdG8gYSBuYXZpZ2F0aW9uIHRvIC9wYWdlXHJcbiAgICBpZiAoc3RhdGUuaW5pdGlhbGl6ZWQgJiYgIWlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgJiYgaXNIYXNoQ2hhbmdlT25seShzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24pICYmICEob3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChvcHRzLnN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpKSB7XHJcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwge1xyXG4gICAgICAgIG1hdGNoZXNcclxuICAgICAgfSwge1xyXG4gICAgICAgIGZsdXNoU3luY1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gQ3JlYXRlIGEgY29udHJvbGxlci9SZXF1ZXN0IGZvciB0aGlzIG5hdmlnYXRpb25cclxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGxldCByZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBsb2NhdGlvbiwgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbCwgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24pO1xyXG4gICAgbGV0IHBlbmRpbmdBY3Rpb25SZXN1bHQ7XHJcbiAgICBpZiAob3B0cyAmJiBvcHRzLnBlbmRpbmdFcnJvcikge1xyXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZ0Vycm9yLCBpdCBtZWFucyB0aGUgdXNlciBhdHRlbXB0ZWQgYSBHRVQgc3VibWlzc2lvblxyXG4gICAgICAvLyB3aXRoIGJpbmFyeSBGb3JtRGF0YSBzbyBhc3NpZ24gaGVyZSBhbmQgc2tpcCB0byBoYW5kbGVMb2FkZXJzLiAgVGhhdFxyXG4gICAgICAvLyB3YXkgd2UgaGFuZGxlIGNhbGxpbmcgbG9hZGVycyBhYm92ZSB0aGUgYm91bmRhcnkgZXRjLiAgSXQncyBub3QgcmVhbGx5XHJcbiAgICAgIC8vIGRpZmZlcmVudCBmcm9tIGFuIGFjdGlvbkVycm9yIGluIHRoYXQgc2Vuc2UuXHJcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBbZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzKS5yb3V0ZS5pZCwge1xyXG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXHJcbiAgICAgICAgZXJyb3I6IG9wdHMucGVuZGluZ0Vycm9yXHJcbiAgICAgIH1dO1xyXG4gICAgfSBlbHNlIGlmIChvcHRzICYmIG9wdHMuc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKG9wdHMuc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xyXG4gICAgICAvLyBDYWxsIGFjdGlvbiBpZiB3ZSByZWNlaXZlZCBhbiBhY3Rpb24gc3VibWlzc2lvblxyXG4gICAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYXdhaXQgaGFuZGxlQWN0aW9uKHJlcXVlc3QsIGxvY2F0aW9uLCBvcHRzLnN1Ym1pc3Npb24sIG1hdGNoZXMsIGZvZ09mV2FyLmFjdGl2ZSwge1xyXG4gICAgICAgIHJlcGxhY2U6IG9wdHMucmVwbGFjZSxcclxuICAgICAgICBmbHVzaFN5bmNcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChhY3Rpb25SZXN1bHQuc2hvcnRDaXJjdWl0ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgd2UgcmVjZWl2ZWQgYSA0MDQgZnJvbSBoYW5kbGVBY3Rpb24sIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBsYXppbHlcclxuICAgICAgLy8gZGlzY292ZXIgdGhlIGRlc3RpbmF0aW9uIHJvdXRlIHNvIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBsb2FkZXJzXHJcbiAgICAgIGlmIChhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdCkge1xyXG4gICAgICAgIGxldCBbcm91dGVJZCwgcmVzdWx0XSA9IGFjdGlvblJlc3VsdC5wZW5kaW5nQWN0aW9uUmVzdWx0O1xyXG4gICAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkgJiYgaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSAmJiByZXN1bHQuZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XHJcbiAgICAgICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcclxuICAgICAgICAgICAgbWF0Y2hlczogYWN0aW9uUmVzdWx0Lm1hdGNoZXMsXHJcbiAgICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxyXG4gICAgICAgICAgICBlcnJvcnM6IHtcclxuICAgICAgICAgICAgICBbcm91dGVJZF06IHJlc3VsdC5lcnJvclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbWF0Y2hlcyA9IGFjdGlvblJlc3VsdC5tYXRjaGVzIHx8IG1hdGNoZXM7XHJcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcclxuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcclxuICAgICAgZmx1c2hTeW5jID0gZmFsc2U7XHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gZG8gZm9nIG9mIHdhciBtYXRjaGluZyBhZ2FpbiBvbiBsb2FkZXIgZXhlY3V0aW9uXHJcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcclxuICAgICAgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgcmVxdWVzdC51cmwsIHJlcXVlc3Quc2lnbmFsKTtcclxuICAgIH1cclxuICAgIC8vIENhbGwgbG9hZGVyc1xyXG4gICAgbGV0IHtcclxuICAgICAgc2hvcnRDaXJjdWl0ZWQsXHJcbiAgICAgIG1hdGNoZXM6IHVwZGF0ZWRNYXRjaGVzLFxyXG4gICAgICBsb2FkZXJEYXRhLFxyXG4gICAgICBlcnJvcnNcclxuICAgIH0gPSBhd2FpdCBoYW5kbGVMb2FkZXJzKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCBmb2dPZldhci5hY3RpdmUsIGxvYWRpbmdOYXZpZ2F0aW9uLCBvcHRzICYmIG9wdHMuc3VibWlzc2lvbiwgb3B0cyAmJiBvcHRzLmZldGNoZXJTdWJtaXNzaW9uLCBvcHRzICYmIG9wdHMucmVwbGFjZSwgb3B0cyAmJiBvcHRzLmluaXRpYWxIeWRyYXRpb24gPT09IHRydWUsIGZsdXNoU3luYywgcGVuZGluZ0FjdGlvblJlc3VsdCk7XHJcbiAgICBpZiAoc2hvcnRDaXJjdWl0ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gQ2xlYW4gdXAgbm93IHRoYXQgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWZcclxuICAgIC8vIHdlIHNob3J0IGNpcmN1aXRlZCBiZWNhdXNlIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciB3aWxsIGhhdmUgYWxyZWFkeVxyXG4gICAgLy8gYmVlbiBhc3NpZ25lZCB0byBhIG5ldyBjb250cm9sbGVyIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXHJcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBfZXh0ZW5kcyh7XHJcbiAgICAgIG1hdGNoZXM6IHVwZGF0ZWRNYXRjaGVzIHx8IG1hdGNoZXNcclxuICAgIH0sIGdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCksIHtcclxuICAgICAgbG9hZGVyRGF0YSxcclxuICAgICAgZXJyb3JzXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIC8vIENhbGwgdGhlIGFjdGlvbiBtYXRjaGVkIGJ5IHRoZSBsZWFmIHJvdXRlIGZvciB0aGlzIG5hdmlnYXRpb24gYW5kIGhhbmRsZVxyXG4gIC8vIHJlZGlyZWN0cy9lcnJvcnNcclxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24ocmVxdWVzdCwgbG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMsIGlzRm9nT2ZXYXIsIG9wdHMpIHtcclxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcclxuICAgICAgb3B0cyA9IHt9O1xyXG4gICAgfVxyXG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcclxuICAgIC8vIFB1dCB1cyBpbiBhIHN1Ym1pdHRpbmcgc3RhdGVcclxuICAgIGxldCBuYXZpZ2F0aW9uID0gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xyXG4gICAgdXBkYXRlU3RhdGUoe1xyXG4gICAgICBuYXZpZ2F0aW9uXHJcbiAgICB9LCB7XHJcbiAgICAgIGZsdXNoU3luYzogb3B0cy5mbHVzaFN5bmMgPT09IHRydWVcclxuICAgIH0pO1xyXG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcclxuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMobWF0Y2hlcywgbG9jYXRpb24ucGF0aG5hbWUsIHJlcXVlc3Quc2lnbmFsKTtcclxuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMpLnJvdXRlLmlkO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBtYXRjaGVzOiBkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcyxcclxuICAgICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtib3VuZGFyeUlkLCB7XHJcbiAgICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXHJcbiAgICAgICAgICAgIGVycm9yOiBkaXNjb3ZlclJlc3VsdC5lcnJvclxyXG4gICAgICAgICAgfV1cclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgIG5vdEZvdW5kTWF0Y2hlcyxcclxuICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgcm91dGVcclxuICAgICAgICB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KGxvY2F0aW9uLnBhdGhuYW1lKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxyXG4gICAgICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW3JvdXRlLmlkLCB7XHJcbiAgICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXHJcbiAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICB9XVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENhbGwgb3VyIGFjdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHRcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBsZXQgYWN0aW9uTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XHJcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xyXG4gICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcclxuICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcclxuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXHJcbiAgICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXHJcbiAgICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXCJhY3Rpb25cIiwgc3RhdGUsIHJlcXVlc3QsIFthY3Rpb25NYXRjaF0sIG1hdGNoZXMsIG51bGwpO1xyXG4gICAgICByZXN1bHQgPSByZXN1bHRzW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTtcclxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XHJcbiAgICAgIGxldCByZXBsYWNlO1xyXG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xyXG4gICAgICAgIHJlcGxhY2UgPSBvcHRzLnJlcGxhY2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGlkbid0IGV4cGxpY2l0eSBpbmRpY2F0ZSByZXBsYWNlIGJlaGF2aW9yLCByZXBsYWNlIGlmXHJcbiAgICAgICAgLy8gd2UgcmVkaXJlY3RlZCB0byB0aGUgZXhhY3Qgc2FtZSBsb2NhdGlvbiB3ZSdyZSBjdXJyZW50bHkgYXQgdG8gYXZvaWRcclxuICAgICAgICAvLyBkb3VibGUgYmFjay1idXR0b25zXHJcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihyZXN1bHQucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKSwgbmV3IFVSTChyZXF1ZXN0LnVybCksIGJhc2VuYW1lKTtcclxuICAgICAgICByZXBsYWNlID0gbG9jYXRpb24gPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoO1xyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlc3VsdCwgdHJ1ZSwge1xyXG4gICAgICAgIHN1Ym1pc3Npb24sXHJcbiAgICAgICAgcmVwbGFjZVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xyXG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xyXG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XHJcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xyXG4gICAgICAvLyB0byBjYWxsIGFuZCB3aWxsIGNvbW1pdCBpdCB3aGVuIHdlIGNvbXBsZXRlIHRoZSBuYXZpZ2F0aW9uXHJcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XHJcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGFsbCBzdWJtaXNzaW9ucyB0byB0aGUgY3VycmVudCBsb2NhdGlvbiBhcmUgUkVQTEFDRVxyXG4gICAgICAvLyBuYXZpZ2F0aW9ucywgYnV0IGlmIHRoZSBhY3Rpb24gdGhyZXcgYW4gZXJyb3IgdGhhdCdsbCBiZSByZW5kZXJlZCBpblxyXG4gICAgICAvLyBhbiBlcnJvckVsZW1lbnQsIHdlIGZhbGwgYmFjayB0byBQVVNIIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSB0aGVcclxuICAgICAgLy8gYmFjayBidXR0b24gdG8gZ2V0IGJhY2sgdG8gdGhlIHByZS1zdWJtaXNzaW9uIGZvcm0gbG9jYXRpb24gdG8gdHJ5XHJcbiAgICAgIC8vIGFnYWluXHJcbiAgICAgIGlmICgob3B0cyAmJiBvcHRzLnJlcGxhY2UpICE9PSB0cnVlKSB7XHJcbiAgICAgICAgcGVuZGluZ0FjdGlvbiA9IEFjdGlvbi5QdXNoO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbWF0Y2hlcyxcclxuICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbWF0Y2hlcyxcclxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdDogW2FjdGlvbk1hdGNoLnJvdXRlLmlkLCByZXN1bHRdXHJcbiAgICB9O1xyXG4gIH1cclxuICAvLyBDYWxsIGFsbCBhcHBsaWNhYmxlIGxvYWRlcnMgZm9yIHRoZSBnaXZlbiBtYXRjaGVzLCBoYW5kbGluZyByZWRpcmVjdHMsXHJcbiAgLy8gZXJyb3JzLCBldGMuXHJcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgaXNGb2dPZldhciwgb3ZlcnJpZGVOYXZpZ2F0aW9uLCBzdWJtaXNzaW9uLCBmZXRjaGVyU3VibWlzc2lvbiwgcmVwbGFjZSwgaW5pdGlhbEh5ZHJhdGlvbiwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XHJcbiAgICAvLyBGaWd1cmUgb3V0IHRoZSByaWdodCBuYXZpZ2F0aW9uIHdlIHdhbnQgdG8gdXNlIGZvciBkYXRhIGxvYWRpbmdcclxuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG92ZXJyaWRlTmF2aWdhdGlvbiB8fCBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XHJcbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlZGlyZWN0IGZyb20gYW4gYWN0aW9uIHdlIGRvbid0IGhhdmUgYSBcInN1Ym1pc3Npb25cIiBidXRcclxuICAgIC8vIHdlIGhhdmUgaXQgb24gdGhlIGxvYWRpbmcgbmF2aWdhdGlvbiBzbyB1c2UgdGhhdCBpZiBhdmFpbGFibGVcclxuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvbiB8fCBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obG9hZGluZ05hdmlnYXRpb24pO1xyXG4gICAgLy8gSWYgdGhpcyBpcyBhbiB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbiwgd2UgcmVtYWluIGluIG91ciBjdXJyZW50IGlkbGVcclxuICAgIC8vIHN0YXRlLiAgSWYgbm90LCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBvdXIgbG9hZGluZyBzdGF0ZSBhbmQgbG9hZCBkYXRhLFxyXG4gICAgLy8gcHJlc2VydmluZyBhbnkgbmV3IGFjdGlvbiBkYXRhIG9yIGV4aXN0aW5nIGFjdGlvbiBkYXRhIChpbiB0aGUgY2FzZSBvZlxyXG4gICAgLy8gYSByZXZhbGlkYXRpb24gaW50ZXJydXB0aW5nIGFuIGFjdGlvblJlbG9hZClcclxuICAgIC8vIElmIHdlIGhhdmUgcGFydGlhbEh5ZHJhdGlvbiBlbmFibGVkLCB0aGVuIGRvbid0IHVwZGF0ZSB0aGUgc3RhdGUgZm9yIHRoZVxyXG4gICAgLy8gaW5pdGlhbCBkYXRhIGxvYWQgc2luY2UgaXQncyBub3QgYSBcIm5hdmlnYXRpb25cIlxyXG4gICAgbGV0IHNob3VsZFVwZGF0ZU5hdmlnYXRpb25TdGF0ZSA9ICFpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gJiYgKCFmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiB8fCAhaW5pdGlhbEh5ZHJhdGlvbik7XHJcbiAgICAvLyBXaGVuIGZvZyBvZiB3YXIgaXMgZW5hYmxlZCwgd2UgZW50ZXIgb3VyIGBsb2FkaW5nYCBzdGF0ZSBlYXJsaWVyIHNvIHdlXHJcbiAgICAvLyBjYW4gZGlzY292ZXIgbmV3IHJvdXRlcyBkdXJpbmcgdGhlIGBsb2FkaW5nYCBzdGF0ZS4gIFdlIHNraXAgdGhpcyBpZlxyXG4gICAgLy8gd2UndmUgYWxyZWFkeSBydW4gYWN0aW9ucyBzaW5jZSB3ZSB3b3VsZCBoYXZlIGRvbmUgb3VyIG1hdGNoaW5nIGFscmVhZHkuXHJcbiAgICAvLyBJZiB0aGUgY2hpbGRyZW4oKSBmdW5jdGlvbiB0aHJldyB0aGVuLCB3ZSB3YW50IHRvIHByb2NlZWQgd2l0aCB0aGVcclxuICAgIC8vIHBhcnRpYWwgbWF0Y2hlcyBpdCBkaXNjb3ZlcmVkLlxyXG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcclxuICAgICAgaWYgKHNob3VsZFVwZGF0ZU5hdmlnYXRpb25TdGF0ZSkge1xyXG4gICAgICAgIGxldCBhY3Rpb25EYXRhID0gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCk7XHJcbiAgICAgICAgdXBkYXRlU3RhdGUoX2V4dGVuZHMoe1xyXG4gICAgICAgICAgbmF2aWdhdGlvbjogbG9hZGluZ05hdmlnYXRpb25cclxuICAgICAgICB9LCBhY3Rpb25EYXRhICE9PSB1bmRlZmluZWQgPyB7XHJcbiAgICAgICAgICBhY3Rpb25EYXRhXHJcbiAgICAgICAgfSA6IHt9KSwge1xyXG4gICAgICAgICAgZmx1c2hTeW5jXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMobWF0Y2hlcywgbG9jYXRpb24ucGF0aG5hbWUsIHJlcXVlc3Quc2lnbmFsKTtcclxuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMpLnJvdXRlLmlkO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBtYXRjaGVzOiBkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcyxcclxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxyXG4gICAgICAgICAgZXJyb3JzOiB7XHJcbiAgICAgICAgICAgIFtib3VuZGFyeUlkXTogZGlzY292ZXJSZXN1bHQuZXJyb3JcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgbm90Rm91bmRNYXRjaGVzLFxyXG4gICAgICAgICAgcm91dGVcclxuICAgICAgICB9ID0gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KGxvY2F0aW9uLnBhdGhuYW1lKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxyXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXHJcbiAgICAgICAgICBlcnJvcnM6IHtcclxuICAgICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcclxuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChpbml0Lmhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBhY3RpdmVTdWJtaXNzaW9uLCBsb2NhdGlvbiwgZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gJiYgaW5pdGlhbEh5ZHJhdGlvbiA9PT0gdHJ1ZSwgZnV0dXJlLnY3X3NraXBBY3Rpb25FcnJvclJldmFsaWRhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsIGNhbmNlbGxlZEZldGNoZXJMb2FkcywgZGVsZXRlZEZldGNoZXJzLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xyXG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXHJcbiAgICAvLyBhYm91dCB0byByZWxvYWQuICBOb3RlIHRoYXQgaWYgdGhpcyBpcyBhbiBhY3Rpb24gcmVsb2FkIHdlIHdvdWxkIGhhdmVcclxuICAgIC8vIGFscmVhZHkgY2FuY2VsbGVkIGFsbCBwZW5kaW5nIGRlZmVycmVkcyBzbyB0aGlzIHdvdWxkIGJlIGEgbm8tb3BcclxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhyb3V0ZUlkID0+ICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHwgbWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSk7XHJcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xyXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuXHJcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDAgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XHJcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgX2V4dGVuZHMoe1xyXG4gICAgICAgIG1hdGNoZXMsXHJcbiAgICAgICAgbG9hZGVyRGF0YToge30sXHJcbiAgICAgICAgLy8gQ29tbWl0IHBlbmRpbmcgZXJyb3IgaWYgd2UncmUgc2hvcnQgY2lyY3VpdGluZ1xyXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xyXG4gICAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yXHJcbiAgICAgICAgfSA6IG51bGxcclxuICAgICAgfSwgZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSwgdXBkYXRlZEZldGNoZXJzID8ge1xyXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxyXG4gICAgICB9IDoge30pLCB7XHJcbiAgICAgICAgZmx1c2hTeW5jXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlKSB7XHJcbiAgICAgIGxldCB1cGRhdGVzID0ge307XHJcbiAgICAgIGlmICghaXNGb2dPZldhcikge1xyXG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIG5hdmlnYXRpb24vYWN0aW9uTkRhdGEgaWYgd2UgZGlkbid0IGFscmVhZHkgZG8gaXQgYWJvdmVcclxuICAgICAgICB1cGRhdGVzLm5hdmlnYXRpb24gPSBsb2FkaW5nTmF2aWdhdGlvbjtcclxuICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IGdldFVwZGF0ZWRBY3Rpb25EYXRhKHBlbmRpbmdBY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgIGlmIChhY3Rpb25EYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHVwZGF0ZXMuYWN0aW9uRGF0YSA9IGFjdGlvbkRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdXBkYXRlcy5mZXRjaGVycyA9IGdldFVwZGF0ZWRSZXZhbGlkYXRpbmdGZXRjaGVycyhyZXZhbGlkYXRpbmdGZXRjaGVycyk7XHJcbiAgICAgIH1cclxuICAgICAgdXBkYXRlU3RhdGUodXBkYXRlcywge1xyXG4gICAgICAgIGZsdXNoU3luY1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4ge1xyXG4gICAgICBhYm9ydEZldGNoZXIocmYua2V5KTtcclxuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcclxuICAgICAgICAvLyBGZXRjaGVycyB1c2UgYW4gaW5kZXBlbmRlbnQgQWJvcnRDb250cm9sbGVyIHNvIHRoYXQgYWJvcnRpbmcgYSBmZXRjaGVyXHJcbiAgICAgICAgLy8gKHZpYSBkZWxldGVGZXRjaGVyKSBkb2VzIG5vdCBhYm9ydCB0aGUgdHJpZ2dlcmluZyBuYXZpZ2F0aW9uIHRoYXRcclxuICAgICAgICAvLyB0cmlnZ2VyZWQgdGhlIHJldmFsaWRhdGlvblxyXG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcmYuY29udHJvbGxlcik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gUHJveHkgbmF2aWdhdGlvbiBhYm9ydCB0aHJvdWdoIHRvIHJldmFsaWRhdGlvbiBmZXRjaGVyc1xyXG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goZiA9PiBhYm9ydEZldGNoZXIoZi5rZXkpKTtcclxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcclxuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zKTtcclxuICAgIH1cclxuICAgIGxldCB7XHJcbiAgICAgIGxvYWRlclJlc3VsdHMsXHJcbiAgICAgIGZldGNoZXJSZXN1bHRzXHJcbiAgICB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVycywgcmVxdWVzdCk7XHJcbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBDbGVhbiB1cCBfYWZ0ZXJfIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWQuICBEb24ndCBjbGVhbiB1cCBpZiB3ZSBzaG9ydFxyXG4gICAgLy8gY2lyY3VpdGVkIGJlY2F1c2UgZmV0Y2hDb250cm9sbGVycyB3b3VsZCBoYXZlIGJlZW4gYWJvcnRlZCBhbmRcclxuICAgIC8vIHJlYXNzaWduZWQgdG8gbmV3IGNvbnRyb2xsZXJzIGZvciB0aGUgbmV4dCBuYXZpZ2F0aW9uXHJcbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XHJcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHJmLmtleSkpO1xyXG4gICAgLy8gSWYgYW55IGxvYWRlcnMgcmV0dXJuZWQgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXHJcbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QobG9hZGVyUmVzdWx0cyk7XHJcbiAgICBpZiAocmVkaXJlY3QpIHtcclxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVkaXJlY3QucmVzdWx0LCB0cnVlLCB7XHJcbiAgICAgICAgcmVwbGFjZVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QoZmV0Y2hlclJlc3VsdHMpO1xyXG4gICAgaWYgKHJlZGlyZWN0KSB7XHJcbiAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxyXG4gICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxyXG4gICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xyXG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChyZWRpcmVjdC5rZXkpO1xyXG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXF1ZXN0LCByZWRpcmVjdC5yZXN1bHQsIHRydWUsIHtcclxuICAgICAgICByZXBsYWNlXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xyXG4gICAgbGV0IHtcclxuICAgICAgbG9hZGVyRGF0YSxcclxuICAgICAgZXJyb3JzXHJcbiAgICB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoc3RhdGUsIG1hdGNoZXMsIGxvYWRlclJlc3VsdHMsIHBlbmRpbmdBY3Rpb25SZXN1bHQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cywgYWN0aXZlRGVmZXJyZWRzKTtcclxuICAgIC8vIFdpcmUgdXAgc3Vic2NyaWJlcnMgdG8gdXBkYXRlIGxvYWRlckRhdGEgYXMgcHJvbWlzZXMgc2V0dGxlXHJcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGVmZXJyZWREYXRhLCByb3V0ZUlkKSA9PiB7XHJcbiAgICAgIGRlZmVycmVkRGF0YS5zdWJzY3JpYmUoYWJvcnRlZCA9PiB7XHJcbiAgICAgICAgLy8gTm90ZTogTm8gbmVlZCB0byB1cGRhdGVTdGF0ZSBoZXJlIHNpbmNlIHRoZSBUcmFja2VkUHJvbWlzZSBvblxyXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaXMgc3RhYmxlIGFjcm9zcyByZXNvbHZlL3JlamVjdFxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGluc3RhbmNlIGlmIHdlIHdlcmUgYWJvcnRlZCBvciBpZiBwcm9taXNlcyBoYXZlIHNldHRsZWRcclxuICAgICAgICBpZiAoYWJvcnRlZCB8fCBkZWZlcnJlZERhdGEuZG9uZSkge1xyXG4gICAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBQcmVzZXJ2ZSBTU1IgZXJyb3JzIGR1cmluZyBwYXJ0aWFsIGh5ZHJhdGlvblxyXG4gICAgaWYgKGZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uICYmIGluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUuZXJyb3JzKSB7XHJcbiAgICAgIGVycm9ycyA9IF9leHRlbmRzKHt9LCBzdGF0ZS5lcnJvcnMsIGVycm9ycyk7XHJcbiAgICB9XHJcbiAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xyXG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKTtcclxuICAgIGxldCBzaG91bGRVcGRhdGVGZXRjaGVycyA9IHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcclxuICAgIHJldHVybiBfZXh0ZW5kcyh7XHJcbiAgICAgIG1hdGNoZXMsXHJcbiAgICAgIGxvYWRlckRhdGEsXHJcbiAgICAgIGVycm9yc1xyXG4gICAgfSwgc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPyB7XHJcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxyXG4gICAgfSA6IHt9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCkge1xyXG4gICAgaWYgKHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgIWlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkpIHtcclxuICAgICAgLy8gVGhpcyBpcyBjYXN0IHRvIGBhbnlgIGN1cnJlbnRseSBiZWNhdXNlIGBSb3V0ZURhdGFgdXNlcyBhbnkgYW5kIGl0XHJcbiAgICAgIC8vIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlIHRvIHVzZSBhbnkuXHJcbiAgICAgIC8vIFRPRE86IHY3IC0gY2hhbmdlIGBSb3V0ZURhdGFgIHRvIHVzZSBgdW5rbm93bmAgaW5zdGVhZCBvZiBgYW55YFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmFjdGlvbkRhdGEpIHtcclxuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldFVwZGF0ZWRSZXZhbGlkYXRpbmdGZXRjaGVycyhyZXZhbGlkYXRpbmdGZXRjaGVycykge1xyXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiB7XHJcbiAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XHJcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIodW5kZWZpbmVkLCBmZXRjaGVyID8gZmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKTtcclxuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHJmLmtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKTtcclxuICB9XHJcbiAgLy8gVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXQgZm9yIHRoZSBnaXZlbiBmZXRjaGVyIGtleVxyXG4gIGZ1bmN0aW9uIGZldGNoKGtleSwgcm91dGVJZCwgaHJlZiwgb3B0cykge1xyXG4gICAgaWYgKGlzU2VydmVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJvdXRlci5mZXRjaCgpIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArIFwiWW91IGFyZSBsaWtlbHkgY2FsbGluZyBhIHVzZUZldGNoZXIoKSBtZXRob2QgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICsgXCJUcnkgbW92aW5nIGl0IHRvIGEgdXNlRWZmZWN0IG9yIGEgY2FsbGJhY2suXCIpO1xyXG4gICAgfVxyXG4gICAgYWJvcnRGZXRjaGVyKGtleSk7XHJcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlO1xyXG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XHJcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcywgYmFzZW5hbWUsIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsIGhyZWYsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCwgcm91dGVJZCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWxhdGl2ZSk7XHJcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xyXG4gICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgbm9ybWFsaXplZFBhdGgpO1xyXG4gICAgaWYgKGZvZ09mV2FyLmFjdGl2ZSAmJiBmb2dPZldhci5tYXRjaGVzKSB7XHJcbiAgICAgIG1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xyXG4gICAgfVxyXG4gICAgaWYgKCFtYXRjaGVzKSB7XHJcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XHJcbiAgICAgICAgcGF0aG5hbWU6IG5vcm1hbGl6ZWRQYXRoXHJcbiAgICAgIH0pLCB7XHJcbiAgICAgICAgZmx1c2hTeW5jXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQge1xyXG4gICAgICBwYXRoLFxyXG4gICAgICBzdWJtaXNzaW9uLFxyXG4gICAgICBlcnJvclxyXG4gICAgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhmdXR1cmUudjdfbm9ybWFsaXplRm9ybU1ldGhvZCwgdHJ1ZSwgbm9ybWFsaXplZFBhdGgsIG9wdHMpO1xyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7XHJcbiAgICAgICAgZmx1c2hTeW5jXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBwYXRoKTtcclxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XHJcbiAgICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcclxuICAgICAgaGFuZGxlRmV0Y2hlckFjdGlvbihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBmb2dPZldhci5hY3RpdmUsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gU3RvcmUgb2ZmIHRoZSBtYXRjaCBzbyB3ZSBjYW4gY2FsbCBpdCdzIHNob3VsZFJldmFsaWRhdGUgb24gc3Vic2VxdWVudFxyXG4gICAgLy8gcmV2YWxpZGF0aW9uc1xyXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5zZXQoa2V5LCB7XHJcbiAgICAgIHJvdXRlSWQsXHJcbiAgICAgIHBhdGhcclxuICAgIH0pO1xyXG4gICAgaGFuZGxlRmV0Y2hlckxvYWRlcihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBmb2dPZldhci5hY3RpdmUsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKTtcclxuICB9XHJcbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIGZvciB0aGUgbWF0Y2hlZCBmZXRjaGVyLnN1Ym1pdCgpLCBhbmQgdGhlbiBoYW5kbGUgcmVkaXJlY3RzLFxyXG4gIC8vIGVycm9ycywgYW5kIHJldmFsaWRhdGlvblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgcmVxdWVzdE1hdGNoZXMsIGlzRm9nT2ZXYXIsIGZsdXNoU3luYywgcHJldmVudFNjcm9sbFJlc2V0LCBzdWJtaXNzaW9uKSB7XHJcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xyXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcclxuICAgIGZ1bmN0aW9uIGRldGVjdEFuZEhhbmRsZTQwNUVycm9yKG0pIHtcclxuICAgICAgaWYgKCFtLnJvdXRlLmFjdGlvbiAmJiAhbS5yb3V0ZS5sYXp5KSB7XHJcbiAgICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcclxuICAgICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxyXG4gICAgICAgICAgcGF0aG5hbWU6IHBhdGgsXHJcbiAgICAgICAgICByb3V0ZUlkOiByb3V0ZUlkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIHtcclxuICAgICAgICAgIGZsdXNoU3luY1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghaXNGb2dPZldhciAmJiBkZXRlY3RBbmRIYW5kbGU0MDVFcnJvcihtYXRjaCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gUHV0IHRoaXMgZmV0Y2hlciBpbnRvIGl0J3Mgc3VibWl0dGluZyBzdGF0ZVxyXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xyXG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0U3VibWl0dGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyKSwge1xyXG4gICAgICBmbHVzaFN5bmNcclxuICAgIH0pO1xyXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIHBhdGgsIGFib3J0Q29udHJvbGxlci5zaWduYWwsIHN1Ym1pc3Npb24pO1xyXG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcclxuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMocmVxdWVzdE1hdGNoZXMsIHBhdGgsIGZldGNoUmVxdWVzdC5zaWduYWwpO1xyXG4gICAgICBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJhYm9ydGVkXCIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XHJcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZGlzY292ZXJSZXN1bHQuZXJyb3IsIHtcclxuICAgICAgICAgIGZsdXNoU3luY1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xyXG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XHJcbiAgICAgICAgICBwYXRobmFtZTogcGF0aFxyXG4gICAgICAgIH0pLCB7XHJcbiAgICAgICAgICBmbHVzaFN5bmNcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVxdWVzdE1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xyXG4gICAgICAgIG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gocmVxdWVzdE1hdGNoZXMsIHBhdGgpO1xyXG4gICAgICAgIGlmIChkZXRlY3RBbmRIYW5kbGU0MDVFcnJvcihtYXRjaCkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcclxuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcclxuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcclxuICAgIGxldCBhY3Rpb25SZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcImFjdGlvblwiLCBzdGF0ZSwgZmV0Y2hSZXF1ZXN0LCBbbWF0Y2hdLCByZXF1ZXN0TWF0Y2hlcywga2V5KTtcclxuICAgIGxldCBhY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcclxuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvd24gZmV0Y2hlclxyXG4gICAgICAvLyByZS1zdWJtaXQgd2hpY2ggd291bGQgaGF2ZSBwdXQgX25ld18gY29udHJvbGxlciBpcyBpbiBmZXRjaENvbnRyb2xsZXJzXHJcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcclxuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIFdoZW4gdXNpbmcgdjdfZmV0Y2hlclBlcnNpc3QsIHdlIGRvbid0IHdhbnQgZXJyb3JzIGJ1YmJsaW5nIHVwIHRvIHRoZSBVSVxyXG4gICAgLy8gb3IgcmVkaXJlY3RzIHByb2Nlc3NlZCBmb3IgdW5tb3VudGVkIGZldGNoZXJzIHNvIHdlIGp1c3QgcmV2ZXJ0IHRoZW0gdG9cclxuICAgIC8vIGlkbGVcclxuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QgJiYgZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XHJcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkgfHwgaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XHJcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIExldCBTdWNjZXNzUmVzdWx0J3MgZmFsbCB0aHJvdWdoIGZvciByZXZhbGlkYXRpb25cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcclxuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XHJcbiAgICAgICAgICAvLyBBIG5ldyBuYXZpZ2F0aW9uIHdhcyBraWNrZWQgb2ZmIGFmdGVyIG91ciBhY3Rpb24gc3RhcnRlZCwgc28gdGhhdFxyXG4gICAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvbi4gIFdlIGFscmVhZHlcclxuICAgICAgICAgIC8vIHNldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkIHNvIGFsbCBsb2FkZXJzIGZvciB0aGUgbmV3IHJvdXRlIHNob3VsZFxyXG4gICAgICAgICAgLy8gZmlyZSB1bmxlc3Mgb3B0ZWQgb3V0IHZpYSBzaG91bGRSZXZhbGlkYXRlXHJcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcclxuICAgICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24pKTtcclxuICAgICAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihmZXRjaFJlcXVlc3QsIGFjdGlvblJlc3VsdCwgZmFsc2UsIHtcclxuICAgICAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb246IHN1Ym1pc3Npb24sXHJcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXHJcbiAgICAgIGlmIChpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcclxuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBhY3Rpb25SZXN1bHQuZXJyb3IpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xyXG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xyXG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBTdGFydCB0aGUgZGF0YSBsb2FkIGZvciBjdXJyZW50IG1hdGNoZXMsIG9yIHRoZSBuZXh0IGxvY2F0aW9uIGlmIHdlJ3JlXHJcbiAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgbmF2aWdhdGlvblxyXG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb247XHJcbiAgICBsZXQgcmV2YWxpZGF0aW9uUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgbmV4dExvY2F0aW9uLCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xyXG4gICAgbGV0IG1hdGNoZXMgPSBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIiA/IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCBiYXNlbmFtZSkgOiBzdGF0ZS5tYXRjaGVzO1xyXG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XHJcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XHJcbiAgICBmZXRjaFJlbG9hZElkcy5zZXQoa2V5LCBsb2FkSWQpO1xyXG4gICAgbGV0IGxvYWRGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgYWN0aW9uUmVzdWx0LmRhdGEpO1xyXG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xyXG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKGluaXQuaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIG5leHRMb2NhdGlvbiwgZmFsc2UsIGZ1dHVyZS52N19za2lwQWN0aW9uRXJyb3JSZXZhbGlkYXRpb24sIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQsIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMsIGRlbGV0ZWRGZXRjaGVycywgZmV0Y2hMb2FkTWF0Y2hlcywgZmV0Y2hSZWRpcmVjdElkcywgcm91dGVzVG9Vc2UsIGJhc2VuYW1lLCBbbWF0Y2gucm91dGUuaWQsIGFjdGlvblJlc3VsdF0pO1xyXG4gICAgLy8gUHV0IGFsbCByZXZhbGlkYXRpbmcgZmV0Y2hlcnMgaW50byB0aGUgbG9hZGluZyBzdGF0ZSwgZXhjZXB0IGZvciB0aGVcclxuICAgIC8vIGN1cnJlbnQgZmV0Y2hlciB3aGljaCB3ZSB3YW50IHRvIGtlZXAgaW4gaXQncyBjdXJyZW50IGxvYWRpbmcgc3RhdGUgd2hpY2hcclxuICAgIC8vIGNvbnRhaW5zIGl0J3MgYWN0aW9uIHN1Ym1pc3Npb24gaW5mbyArIGFjdGlvbiBkYXRhXHJcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5maWx0ZXIocmYgPT4gcmYua2V5ICE9PSBrZXkpLmZvckVhY2gocmYgPT4ge1xyXG4gICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XHJcbiAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xyXG4gICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHVuZGVmaW5lZCwgZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB1bmRlZmluZWQpO1xyXG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xyXG4gICAgICBhYm9ydEZldGNoZXIoc3RhbGVLZXkpO1xyXG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xyXG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHN0YWxlS2V5LCByZi5jb250cm9sbGVyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB1cGRhdGVTdGF0ZSh7XHJcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxyXG4gICAgfSk7XHJcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT4gcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiBhYm9ydEZldGNoZXIocmYua2V5KSk7XHJcbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xyXG4gICAgbGV0IHtcclxuICAgICAgbG9hZGVyUmVzdWx0cyxcclxuICAgICAgZmV0Y2hlclJlc3VsdHNcclxuICAgIH0gPSBhd2FpdCBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoc3RhdGUsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCByZXZhbGlkYXRpb25SZXF1ZXN0KTtcclxuICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zKTtcclxuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xyXG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcclxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gociA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyLmtleSkpO1xyXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KGxvYWRlclJlc3VsdHMpO1xyXG4gICAgaWYgKHJlZGlyZWN0KSB7XHJcbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihyZXZhbGlkYXRpb25SZXF1ZXN0LCByZWRpcmVjdC5yZXN1bHQsIGZhbHNlLCB7XHJcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QoZmV0Y2hlclJlc3VsdHMpO1xyXG4gICAgaWYgKHJlZGlyZWN0KSB7XHJcbiAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxyXG4gICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxyXG4gICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xyXG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChyZWRpcmVjdC5rZXkpO1xyXG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmV2YWxpZGF0aW9uUmVxdWVzdCwgcmVkaXJlY3QucmVzdWx0LCBmYWxzZSwge1xyXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXHJcbiAgICBsZXQge1xyXG4gICAgICBsb2FkZXJEYXRhLFxyXG4gICAgICBlcnJvcnNcclxuICAgIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShzdGF0ZSwgbWF0Y2hlcywgbG9hZGVyUmVzdWx0cywgdW5kZWZpbmVkLCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMsIGFjdGl2ZURlZmVycmVkcyk7XHJcbiAgICAvLyBTaW5jZSB3ZSBsZXQgcmV2YWxpZGF0aW9ucyBjb21wbGV0ZSBldmVuIGlmIHRoZSBzdWJtaXR0aW5nIGZldGNoZXIgd2FzXHJcbiAgICAvLyBkZWxldGVkLCBvbmx5IHB1dCBpdCBiYWNrIHRvIGlkbGUgaWYgaXQgaGFzbid0IGJlZW4gZGVsZXRlZFxyXG4gICAgaWYgKHN0YXRlLmZldGNoZXJzLmhhcyhrZXkpKSB7XHJcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcclxuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xyXG4gICAgfVxyXG4gICAgYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcclxuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW4gYSBuYXZpZ2F0aW9uIGxvYWRpbmcgc3RhdGUgYW5kIHRoaXMgZmV0Y2hlciBpc1xyXG4gICAgLy8gbW9yZSByZWNlbnQgdGhhbiB0aGUgbmF2aWdhdGlvbiwgd2Ugd2FudCB0aGUgbmV3ZXIgZGF0YSBzbyBhYm9ydCB0aGVcclxuICAgIC8vIG5hdmlnYXRpb24gYW5kIGNvbXBsZXRlIGl0IHdpdGggdGhlIGZldGNoZXIgZGF0YVxyXG4gICAgaWYgKHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGxvYWRJZCA+IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKSB7XHJcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xyXG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgIGNvbXBsZXRlTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCB7XHJcbiAgICAgICAgbWF0Y2hlcyxcclxuICAgICAgICBsb2FkZXJEYXRhLFxyXG4gICAgICAgIGVycm9ycyxcclxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgd2l0aCB0aGUgZmV0Y2hlciBkYXRhLCBwcmVzZXJ2aW5nIGFueSBleGlzdGluZ1xyXG4gICAgICAvLyBsb2FkZXJEYXRhIGZvciBsb2FkZXJzIHRoYXQgZGlkIG5vdCBuZWVkIHRvIHJlbG9hZC4gIFdlIGhhdmUgdG9cclxuICAgICAgLy8gbWFudWFsbHkgbWVyZ2UgaGVyZSBzaW5jZSB3ZSBhcmVuJ3QgZ29pbmcgdGhyb3VnaCBjb21wbGV0ZU5hdmlnYXRpb25cclxuICAgICAgdXBkYXRlU3RhdGUoe1xyXG4gICAgICAgIGVycm9ycyxcclxuICAgICAgICBsb2FkZXJEYXRhOiBtZXJnZUxvYWRlckRhdGEoc3RhdGUubG9hZGVyRGF0YSwgbG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSxcclxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcclxuICAgICAgfSk7XHJcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gQ2FsbCB0aGUgbWF0Y2hlZCBsb2FkZXIgZm9yIGZldGNoZXIubG9hZCgpLCBoYW5kbGluZyByZWRpcmVjdHMsIGVycm9ycywgZXRjLlxyXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgaXNGb2dPZldhciwgZmx1c2hTeW5jLCBwcmV2ZW50U2Nyb2xsUmVzZXQsIHN1Ym1pc3Npb24pIHtcclxuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcclxuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKSwge1xyXG4gICAgICBmbHVzaFN5bmNcclxuICAgIH0pO1xyXG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIHBhdGgsIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcclxuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMobWF0Y2hlcywgcGF0aCwgZmV0Y2hSZXF1ZXN0LnNpZ25hbCk7XHJcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBkaXNjb3ZlclJlc3VsdC5lcnJvciwge1xyXG4gICAgICAgICAgZmx1c2hTeW5jXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XHJcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcclxuICAgICAgICAgIHBhdGhuYW1lOiBwYXRoXHJcbiAgICAgICAgfSksIHtcclxuICAgICAgICAgIGZsdXNoU3luY1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXRjaGVzID0gZGlzY292ZXJSZXN1bHQubWF0Y2hlcztcclxuICAgICAgICBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDYWxsIHRoZSBsb2FkZXIgZm9yIHRoaXMgZmV0Y2hlciByb3V0ZSBtYXRjaFxyXG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xyXG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xyXG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFwibG9hZGVyXCIsIHN0YXRlLCBmZXRjaFJlcXVlc3QsIFttYXRjaF0sIG1hdGNoZXMsIGtleSk7XHJcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XHJcbiAgICAvLyBEZWZlcnJlZCBpc24ndCBzdXBwb3J0ZWQgZm9yIGZldGNoZXIgbG9hZHMsIGF3YWl0IGV2ZXJ5dGhpbmcgYW5kIHRyZWF0IGl0XHJcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xyXG4gICAgLy8gZmV0Y2hlciBnZXRzIGFib3J0ZWQsIHNvIHdlIGp1c3QgbGVhdmUgcmVzdWx0IHVudG91Y2hlZCBhbmQgc2hvcnQgY2lyY3VpdFxyXG4gICAgLy8gYmVsb3cgaWYgdGhhdCBoYXBwZW5zXHJcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XHJcbiAgICAgIHJlc3VsdCA9IChhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgZmV0Y2hSZXF1ZXN0LnNpZ25hbCwgdHJ1ZSkpIHx8IHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdXIgb3VyIG93biBmZXRjaGVyXHJcbiAgICAvLyByZS1sb2FkIHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xyXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xyXG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBXZSBkb24ndCB3YW50IGVycm9ycyBidWJibGluZyB1cCBvciByZWRpcmVjdHMgZm9sbG93ZWQgZm9yIHVubW91bnRlZFxyXG4gICAgLy8gZmV0Y2hlcnMsIHNvIHNob3J0IGNpcmN1aXQgaGVyZSBpZiBpdCB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBVSVxyXG4gICAgaWYgKGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xyXG4gICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgdGhlIGxvYWRlciB0aHJldyBhIHJlZGlyZWN0IFJlc3BvbnNlLCBzdGFydCBhIG5ldyBSRVBMQUNFIG5hdmlnYXRpb25cclxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcclxuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcclxuICAgICAgICAvLyBBIG5ldyBuYXZpZ2F0aW9uIHdhcyBraWNrZWQgb2ZmIGFmdGVyIG91ciBsb2FkZXIgc3RhcnRlZCwgc28gdGhhdFxyXG4gICAgICAgIC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHJlZGlyZWN0IG5hdmlnYXRpb25cclxuICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcclxuICAgICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihmZXRjaFJlcXVlc3QsIHJlc3VsdCwgZmFsc2UsIHtcclxuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cclxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcclxuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgcmVzdWx0LmVycm9yKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcclxuICAgIC8vIFB1dCB0aGUgZmV0Y2hlciBiYWNrIGludG8gYW4gaWRsZSBzdGF0ZVxyXG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBoYW5kbGUgcmVkaXJlY3RzIHJldHVybmVkIGZyb20gYW4gYWN0aW9uIG9yIGxvYWRlci5cclxuICAgKiBOb3JtYWxseSwgYSByZWRpcmVjdCBcInJlcGxhY2VzXCIgdGhlIG5hdmlnYXRpb24gdGhhdCB0cmlnZ2VyZWQgaXQuICBTbywgZm9yXHJcbiAgICogZXhhbXBsZTpcclxuICAgKlxyXG4gICAqICAtIHVzZXIgaXMgb24gL2FcclxuICAgKiAgLSB1c2VyIGNsaWNrcyBhIGxpbmsgdG8gL2JcclxuICAgKiAgLSBsb2FkZXIgZm9yIC9iIHJlZGlyZWN0cyB0byAvY1xyXG4gICAqXHJcbiAgICogSW4gYSBub24tSlMgYXBwIHRoZSBicm93c2VyIHdvdWxkIHRyYWNrIHRoZSBpbi1mbGlnaHQgbmF2aWdhdGlvbiB0byAvYiBhbmRcclxuICAgKiB0aGVuIHJlcGxhY2UgaXQgd2l0aCAvYyB3aGVuIGl0IGVuY291bnRlcmVkIHRoZSByZWRpcmVjdCByZXNwb25zZS4gIEluXHJcbiAgICogdGhlIGVuZCBpdCB3b3VsZCBvbmx5IGV2ZXIgdXBkYXRlIHRoZSBVUkwgYmFyIHdpdGggL2MuXHJcbiAgICpcclxuICAgKiBJbiBjbGllbnQtc2lkZSByb3V0aW5nIHVzaW5nIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUsIHdlIGFpbSB0byBlbXVsYXRlXHJcbiAgICogdGhpcyBiZWhhdmlvciBhbmQgd2UgYWxzbyBkbyBub3QgdXBkYXRlIGhpc3RvcnkgdW50aWwgdGhlIGVuZCBvZiB0aGVcclxuICAgKiBuYXZpZ2F0aW9uIChpbmNsdWRpbmcgcHJvY2Vzc2VkIHJlZGlyZWN0cykuICBUaGlzIG1lYW5zIHRoYXQgd2UgbmV2ZXJcclxuICAgKiBhY3R1YWxseSB0b3VjaCBoaXN0b3J5IHVudGlsIHdlJ3ZlIHByb2Nlc3NlZCByZWRpcmVjdHMsIHNvIHdlIGp1c3QgdXNlXHJcbiAgICogdGhlIGhpc3RvcnkgYWN0aW9uIGZyb20gdGhlIG9yaWdpbmFsIG5hdmlnYXRpb24gKFBVU0ggb3IgUkVQTEFDRSkuXHJcbiAgICovXHJcbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVkaXJlY3QsIGlzTmF2aWdhdGlvbiwgX3RlbXAyKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBzdWJtaXNzaW9uLFxyXG4gICAgICBmZXRjaGVyU3VibWlzc2lvbixcclxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxyXG4gICAgICByZXBsYWNlXHJcbiAgICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcclxuICAgIGlmIChyZWRpcmVjdC5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSkge1xyXG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGxldCBsb2NhdGlvbiA9IHJlZGlyZWN0LnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XHJcbiAgICBpbnZhcmlhbnQobG9jYXRpb24sIFwiRXhwZWN0ZWQgYSBMb2NhdGlvbiBoZWFkZXIgb24gdGhlIHJlZGlyZWN0IFJlc3BvbnNlXCIpO1xyXG4gICAgbG9jYXRpb24gPSBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uLCBuZXcgVVJMKHJlcXVlc3QudXJsKSwgYmFzZW5hbWUpO1xyXG4gICAgbGV0IHJlZGlyZWN0TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihzdGF0ZS5sb2NhdGlvbiwgbG9jYXRpb24sIHtcclxuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcclxuICAgIH0pO1xyXG4gICAgaWYgKGlzQnJvd3Nlcikge1xyXG4gICAgICBsZXQgaXNEb2N1bWVudFJlbG9hZCA9IGZhbHNlO1xyXG4gICAgICBpZiAocmVkaXJlY3QucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiKSkge1xyXG4gICAgICAgIC8vIEhhcmQgcmVsb2FkIGlmIHRoZSByZXNwb25zZSBjb250YWluZWQgWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcclxuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIGlmIChBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcclxuICAgICAgICBjb25zdCB1cmwgPSBpbml0Lmhpc3RvcnkuY3JlYXRlVVJMKGxvY2F0aW9uKTtcclxuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID1cclxuICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiBpdCdzIGFuIGFic29sdXRlIFVSTCB0byBhIG5ldyBvcmlnaW5cclxuICAgICAgICB1cmwub3JpZ2luICE9PSByb3V0ZXJXaW5kb3cubG9jYXRpb24ub3JpZ2luIHx8XHJcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcclxuICAgICAgICBzdHJpcEJhc2VuYW1lKHVybC5wYXRobmFtZSwgYmFzZW5hbWUpID09IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcclxuICAgICAgICBpZiAocmVwbGFjZSkge1xyXG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLnJlcGxhY2UobG9jYXRpb24pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24uYXNzaWduKGxvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXHJcbiAgICAvLyByZWRpcmVjdCB1bnRpbCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBzZXR0bGVkXHJcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgbGV0IHJlZGlyZWN0SGlzdG9yeUFjdGlvbiA9IHJlcGxhY2UgPT09IHRydWUgfHwgcmVkaXJlY3QucmVzcG9uc2UuaGVhZGVycy5oYXMoXCJYLVJlbWl4LVJlcGxhY2VcIikgPyBBY3Rpb24uUmVwbGFjZSA6IEFjdGlvbi5QdXNoO1xyXG4gICAgLy8gVXNlIHRoZSBpbmNvbWluZyBzdWJtaXNzaW9uIGlmIHByb3ZpZGVkLCBmYWxsYmFjayBvbiB0aGUgYWN0aXZlIG9uZSBpblxyXG4gICAgLy8gc3RhdGUubmF2aWdhdGlvblxyXG4gICAgbGV0IHtcclxuICAgICAgZm9ybU1ldGhvZCxcclxuICAgICAgZm9ybUFjdGlvbixcclxuICAgICAgZm9ybUVuY1R5cGVcclxuICAgIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xyXG4gICAgaWYgKCFzdWJtaXNzaW9uICYmICFmZXRjaGVyU3VibWlzc2lvbiAmJiBmb3JtTWV0aG9kICYmIGZvcm1BY3Rpb24gJiYgZm9ybUVuY1R5cGUpIHtcclxuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcclxuICAgIH1cclxuICAgIC8vIElmIHRoaXMgd2FzIGEgMzA3LzMwOCBzdWJtaXNzaW9uIHdlIHdhbnQgdG8gcHJlc2VydmUgdGhlIEhUVFAgbWV0aG9kIGFuZFxyXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxyXG4gICAgLy8gcmVkaXJlY3RlZCBsb2NhdGlvblxyXG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uO1xyXG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3QucmVzcG9uc2Uuc3RhdHVzKSAmJiBhY3RpdmVTdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2QoYWN0aXZlU3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xyXG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XHJcbiAgICAgICAgc3VibWlzc2lvbjogX2V4dGVuZHMoe30sIGFjdGl2ZVN1Ym1pc3Npb24sIHtcclxuICAgICAgICAgIGZvcm1BY3Rpb246IGxvY2F0aW9uXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgLy8gUHJlc2VydmUgdGhlc2UgZmxhZ3MgYWNyb3NzIHJlZGlyZWN0c1xyXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcHJldmVudFNjcm9sbFJlc2V0IHx8IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXHJcbiAgICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IGlzTmF2aWdhdGlvbiA/IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgOiB1bmRlZmluZWRcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbmF2aWdhdGlvbiBzdWJtaXNzaW9uLCB3ZSB3aWxsIHByZXNlcnZlIGl0IHRocm91Z2ggdGhlXHJcbiAgICAgIC8vIHJlZGlyZWN0IG5hdmlnYXRpb25cclxuICAgICAgbGV0IG92ZXJyaWRlTmF2aWdhdGlvbiA9IGdldExvYWRpbmdOYXZpZ2F0aW9uKHJlZGlyZWN0TG9jYXRpb24sIHN1Ym1pc3Npb24pO1xyXG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XHJcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uLFxyXG4gICAgICAgIC8vIFNlbmQgZmV0Y2hlciBzdWJtaXNzaW9ucyB0aHJvdWdoIGZvciBzaG91bGRSZXZhbGlkYXRlXHJcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXHJcbiAgICAgICAgLy8gUHJlc2VydmUgdGhlc2UgZmxhZ3MgYWNyb3NzIHJlZGlyZWN0c1xyXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcHJldmVudFNjcm9sbFJlc2V0IHx8IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXHJcbiAgICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IGlzTmF2aWdhdGlvbiA/IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgOiB1bmRlZmluZWRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIFV0aWxpdHkgd3JhcHBlciBmb3IgY2FsbGluZyBkYXRhU3RyYXRlZ3kgY2xpZW50LXNpZGUgd2l0aG91dCBoYXZpbmcgdG9cclxuICAvLyBwYXNzIGFyb3VuZCB0aGUgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgZXRjLlxyXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3kodHlwZSwgc3RhdGUsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGZldGNoZXJLZXkpIHtcclxuICAgIGxldCByZXN1bHRzO1xyXG4gICAgbGV0IGRhdGFSZXN1bHRzID0ge307XHJcbiAgICB0cnkge1xyXG4gICAgICByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneUltcGwoZGF0YVN0cmF0ZWd5SW1wbCwgdHlwZSwgc3RhdGUsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIGZldGNoZXJLZXksIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBJZiB0aGUgb3V0ZXIgZGF0YVN0cmF0ZWd5IG1ldGhvZCB0aHJvd3MsIGp1c3QgcmV0dXJuIHRoZSBlcnJvciBmb3IgYWxsXHJcbiAgICAgIC8vIG1hdGNoZXMgLSBhbmQgaXQnbGwgbmF0dXJhbGx5IGJ1YmJsZSB0byB0aGUgcm9vdFxyXG4gICAgICBtYXRjaGVzVG9Mb2FkLmZvckVhY2gobSA9PiB7XHJcbiAgICAgICAgZGF0YVJlc3VsdHNbbS5yb3V0ZS5pZF0gPSB7XHJcbiAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxyXG4gICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgW3JvdXRlSWQsIHJlc3VsdF0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0cykpIHtcclxuICAgICAgaWYgKGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHRSZXN1bHQocmVzdWx0KSkge1xyXG4gICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5yZXN1bHQ7XHJcbiAgICAgICAgZGF0YVJlc3VsdHNbcm91dGVJZF0gPSB7XHJcbiAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLnJlZGlyZWN0LFxyXG4gICAgICAgICAgcmVzcG9uc2U6IG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UsIHJlcXVlc3QsIHJvdXRlSWQsIG1hdGNoZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkYXRhUmVzdWx0c1tyb3V0ZUlkXSA9IGF3YWl0IGNvbnZlcnREYXRhU3RyYXRlZ3lSZXN1bHRUb0RhdGFSZXN1bHQocmVzdWx0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xyXG4gIH1cclxuICBhc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEoc3RhdGUsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIGZldGNoZXJzVG9Mb2FkLCByZXF1ZXN0KSB7XHJcbiAgICBsZXQgY3VycmVudE1hdGNoZXMgPSBzdGF0ZS5tYXRjaGVzO1xyXG4gICAgLy8gS2ljayBvZmYgbG9hZGVycyBhbmQgZmV0Y2hlcnMgaW4gcGFyYWxsZWxcclxuICAgIGxldCBsb2FkZXJSZXN1bHRzUHJvbWlzZSA9IGNhbGxEYXRhU3RyYXRlZ3koXCJsb2FkZXJcIiwgc3RhdGUsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIG51bGwpO1xyXG4gICAgbGV0IGZldGNoZXJSZXN1bHRzUHJvbWlzZSA9IFByb21pc2UuYWxsKGZldGNoZXJzVG9Mb2FkLm1hcChhc3luYyBmID0+IHtcclxuICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcImxvYWRlclwiLCBzdGF0ZSwgY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBmLnBhdGgsIGYuY29udHJvbGxlci5zaWduYWwpLCBbZi5tYXRjaF0sIGYubWF0Y2hlcywgZi5rZXkpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2YubWF0Y2gucm91dGUuaWRdO1xyXG4gICAgICAgIC8vIEZldGNoZXIgcmVzdWx0cyBhcmUga2V5ZWQgYnkgZmV0Y2hlciBrZXkgZnJvbSBoZXJlIG9uIG91dCwgbm90IHJvdXRlSWRcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgW2Yua2V5XTogcmVzdWx0XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgIFtmLmtleV06IHtcclxuICAgICAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcclxuICAgICAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XHJcbiAgICAgICAgICAgICAgcGF0aG5hbWU6IGYucGF0aFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IGF3YWl0IGxvYWRlclJlc3VsdHNQcm9taXNlO1xyXG4gICAgbGV0IGZldGNoZXJSZXN1bHRzID0gKGF3YWl0IGZldGNoZXJSZXN1bHRzUHJvbWlzZSkucmVkdWNlKChhY2MsIHIpID0+IE9iamVjdC5hc3NpZ24oYWNjLCByKSwge30pO1xyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Jlc29sdmVOYXZpZ2F0aW9uRGVmZXJyZWRSZXN1bHRzKG1hdGNoZXMsIGxvYWRlclJlc3VsdHMsIHJlcXVlc3Quc2lnbmFsLCBjdXJyZW50TWF0Y2hlcywgc3RhdGUubG9hZGVyRGF0YSksIHJlc29sdmVGZXRjaGVyRGVmZXJyZWRSZXN1bHRzKG1hdGNoZXMsIGZldGNoZXJSZXN1bHRzLCBmZXRjaGVyc1RvTG9hZCldKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxvYWRlclJlc3VsdHMsXHJcbiAgICAgIGZldGNoZXJSZXN1bHRzXHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpIHtcclxuICAgIC8vIEV2ZXJ5IGludGVycnVwdGlvbiB0cmlnZ2VycyBhIHJldmFsaWRhdGlvblxyXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XHJcbiAgICAvLyBDYW5jZWwgcGVuZGluZyByb3V0ZS1sZXZlbCBkZWZlcnJlZHMgYW5kIG1hcmsgY2FuY2VsbGVkIHJvdXRlcyBmb3JcclxuICAgIC8vIHJldmFsaWRhdGlvblxyXG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMucHVzaCguLi5jYW5jZWxBY3RpdmVEZWZlcnJlZHMoKSk7XHJcbiAgICAvLyBBYm9ydCBpbi1mbGlnaHQgZmV0Y2hlciBsb2Fkc1xyXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcclxuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcclxuICAgICAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMuYWRkKGtleSk7XHJcbiAgICAgIH1cclxuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZmV0Y2hlciwgb3B0cykge1xyXG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xyXG4gICAgICBvcHRzID0ge307XHJcbiAgICB9XHJcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcclxuICAgIHVwZGF0ZVN0YXRlKHtcclxuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXHJcbiAgICB9LCB7XHJcbiAgICAgIGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIG9wdHMpIHtcclxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcclxuICAgICAgb3B0cyA9IHt9O1xyXG4gICAgfVxyXG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xyXG4gICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xyXG4gICAgdXBkYXRlU3RhdGUoe1xyXG4gICAgICBlcnJvcnM6IHtcclxuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IGVycm9yXHJcbiAgICAgIH0sXHJcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxyXG4gICAgfSwge1xyXG4gICAgICBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldEZldGNoZXIoa2V5KSB7XHJcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XHJcbiAgICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSArIDEpO1xyXG4gICAgICAvLyBJZiB0aGlzIGZldGNoZXIgd2FzIHByZXZpb3VzbHkgbWFya2VkIGZvciBkZWxldGlvbiwgdW5tYXJrIGl0IHNpbmNlIHdlXHJcbiAgICAgIC8vIGhhdmUgYSBuZXcgaW5zdGFuY2VcclxuICAgICAgaWYgKGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xyXG4gICAgICAgIGRlbGV0ZWRGZXRjaGVycy5kZWxldGUoa2V5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcclxuICB9XHJcbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlcihrZXkpIHtcclxuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XHJcbiAgICAvLyBEb24ndCBhYm9ydCB0aGUgY29udHJvbGxlciBpZiB0aGlzIGlzIGEgZGVsZXRpb24gb2YgYSBmZXRjaGVyLnN1Ym1pdCgpXHJcbiAgICAvLyBpbiBpdCdzIGxvYWRpbmcgcGhhc2Ugc2luY2UgLSB3ZSBkb24ndCB3YW50IHRvIGFib3J0IHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICAvLyByZXZhbGlkYXRpb24gYW5kIHdhbnQgdGhlbSB0byBjb21wbGV0ZSBhbmQgbGFuZFxyXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkgJiYgIShmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGZldGNoUmVsb2FkSWRzLmhhcyhrZXkpKSkge1xyXG4gICAgICBhYm9ydEZldGNoZXIoa2V5KTtcclxuICAgIH1cclxuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XHJcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcclxuICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XHJcbiAgICBkZWxldGVkRmV0Y2hlcnMuZGVsZXRlKGtleSk7XHJcbiAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMuZGVsZXRlKGtleSk7XHJcbiAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlckFuZFVwZGF0ZVN0YXRlKGtleSkge1xyXG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xyXG4gICAgICBsZXQgY291bnQgPSAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgLSAxO1xyXG4gICAgICBpZiAoY291bnQgPD0gMCkge1xyXG4gICAgICAgIGFjdGl2ZUZldGNoZXJzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIGRlbGV0ZWRGZXRjaGVycy5hZGQoa2V5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCBjb3VudCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVN0YXRlKHtcclxuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleSkge1xyXG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xyXG4gICAgaWYgKGNvbnRyb2xsZXIpIHtcclxuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXMpIHtcclxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xyXG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihmZXRjaGVyLmRhdGEpO1xyXG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKSB7XHJcbiAgICBsZXQgZG9uZUtleXMgPSBbXTtcclxuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBmYWxzZTtcclxuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XHJcbiAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XHJcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBcIkV4cGVjdGVkIGZldGNoZXI6IFwiICsga2V5KTtcclxuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XHJcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcclxuICAgICAgICBkb25lS2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgdXBkYXRlZEZldGNoZXJzID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWFya0ZldGNoZXJzRG9uZShkb25lS2V5cyk7XHJcbiAgICByZXR1cm4gdXBkYXRlZEZldGNoZXJzO1xyXG4gIH1cclxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZCkge1xyXG4gICAgbGV0IHllZXRlZEtleXMgPSBbXTtcclxuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xyXG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xyXG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XHJcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIFwiRXhwZWN0ZWQgZmV0Y2hlcjogXCIgKyBrZXkpO1xyXG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xyXG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XHJcbiAgICAgICAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWFya0ZldGNoZXJzRG9uZSh5ZWV0ZWRLZXlzKTtcclxuICAgIHJldHVybiB5ZWV0ZWRLZXlzLmxlbmd0aCA+IDA7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldEJsb2NrZXIoa2V5LCBmbikge1xyXG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XHJcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcclxuICAgICAgYmxvY2tlckZ1bmN0aW9ucy5zZXQoa2V5LCBmbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmxvY2tlcjtcclxuICB9XHJcbiAgZnVuY3Rpb24gZGVsZXRlQmxvY2tlcihrZXkpIHtcclxuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xyXG4gICAgYmxvY2tlckZ1bmN0aW9ucy5kZWxldGUoa2V5KTtcclxuICB9XHJcbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXHJcbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlcihrZXksIG5ld0Jsb2NrZXIpIHtcclxuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xyXG4gICAgLy8gUG9vciBtYW5zIHN0YXRlIG1hY2hpbmUgOilcclxuICAgIC8vIGh0dHBzOi8vbWVybWFpZC5saXZlL2VkaXQjcGFrbzplTnFWa2M5T3d6QU14bDhsOG5uakFZckV0RElPSEVCSWd3dktKVFJlR3kzX2xEcElxTzI3azZhd01HMFhjckxsbno4N253ZG9uRVNvZ0tYWEJ1RTc5cnE3NVhaTzMteUhkczBSSlZ1djcwWXJQbFVyQ0VlMkhmck9SUzNydWJxWmZ1aHRwZzVDOXdrNXRaNFZLY1JVcTg4cTlaOFJTMC00OGNFMWlISmtMMHVnYkh1Rkx1czlMNnNwWnk4blg5TVAyQ05kb21WYXBvc3F1M2ZHYXlUOFQ4LWpKUXdoZXBvX1V0cGdCUWFERVVvbTA0ZFpoQU4xYUpCRGxVS0pCeEUxY2VCMlNtajBNbG4tSUJXNUFGVTJkd1Vpa3R0XzJRYXEyZEJmYUtkRXVwODVVVjdZZC1kS2psbmthYmwyUHZyMERUa1RyZU1cclxuICAgIGludmFyaWFudChibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiwgXCJJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogXCIgKyBibG9ja2VyLnN0YXRlICsgXCIgLT4gXCIgKyBuZXdCbG9ja2VyLnN0YXRlKTtcclxuICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xyXG4gICAgYmxvY2tlcnMuc2V0KGtleSwgbmV3QmxvY2tlcik7XHJcbiAgICB1cGRhdGVTdGF0ZSh7XHJcbiAgICAgIGJsb2NrZXJzXHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKF9yZWYyKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBjdXJyZW50TG9jYXRpb24sXHJcbiAgICAgIG5leHRMb2NhdGlvbixcclxuICAgICAgaGlzdG9yeUFjdGlvblxyXG4gICAgfSA9IF9yZWYyO1xyXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcclxuICAgIC8vIGFueSBjb21wZWxsaW5nIHVzZSBjYXNlcyBmb3IgbXVsdGktYmxvY2tlciB5ZXRcclxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPiAxKSB7XHJcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XHJcbiAgICB9XHJcbiAgICBsZXQgZW50cmllcyA9IEFycmF5LmZyb20oYmxvY2tlckZ1bmN0aW9ucy5lbnRyaWVzKCkpO1xyXG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xyXG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XHJcbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xyXG4gICAgICAvLyBJZiB0aGUgYmxvY2tlciBpcyBjdXJyZW50bHkgcHJvY2VlZGluZywgd2UgZG9uJ3QgbmVlZCB0byByZS1jaGVja1xyXG4gICAgICAvLyBpdCBhbmQgY2FuIGxldCB0aGlzIG5hdmlnYXRpb24gY29udGludWVcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2Uga25vdyB3ZSdyZSB1bmJsb2NrZWQvYmxvY2tlZCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRoZVxyXG4gICAgLy8gdXNlci1wcm92aWRlZCBibG9ja2VyIGZ1bmN0aW9uXHJcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHtcclxuICAgICAgY3VycmVudExvY2F0aW9uLFxyXG4gICAgICBuZXh0TG9jYXRpb24sXHJcbiAgICAgIGhpc3RvcnlBY3Rpb25cclxuICAgIH0pKSB7XHJcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQocGF0aG5hbWUpIHtcclxuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XHJcbiAgICAgIHBhdGhuYW1lXHJcbiAgICB9KTtcclxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xyXG4gICAgbGV0IHtcclxuICAgICAgbWF0Y2hlcyxcclxuICAgICAgcm91dGVcclxuICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlc1RvVXNlKTtcclxuICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyBkZWZlcnJlZCBvbiA0MDRzIHNpbmNlIHdlIGRvbid0IGtlZXAgYW55IHJvdXRlc1xyXG4gICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBub3RGb3VuZE1hdGNoZXM6IG1hdGNoZXMsXHJcbiAgICAgIHJvdXRlLFxyXG4gICAgICBlcnJvclxyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gY2FuY2VsQWN0aXZlRGVmZXJyZWRzKHByZWRpY2F0ZSkge1xyXG4gICAgbGV0IGNhbmNlbGxlZFJvdXRlSWRzID0gW107XHJcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGZkLCByb3V0ZUlkKSA9PiB7XHJcbiAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZShyb3V0ZUlkKSkge1xyXG4gICAgICAgIC8vIENhbmNlbCB0aGUgZGVmZXJyZWQgLSBidXQgZG8gbm90IHJlbW92ZSBmcm9tIGFjdGl2ZURlZmVycmVkcyBoZXJlIC1cclxuICAgICAgICAvLyB3ZSByZWx5IG9uIHRoZSBzdWJzY3JpYmVycyB0byBkbyB0aGF0IHNvIG91ciB0ZXN0cyBjYW4gYXNzZXJ0IHByb3BlclxyXG4gICAgICAgIC8vIGNsZWFudXAgdmlhIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkc1xyXG4gICAgICAgIGRmZC5jYW5jZWwoKTtcclxuICAgICAgICBjYW5jZWxsZWRSb3V0ZUlkcy5wdXNoKHJvdXRlSWQpO1xyXG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5kZWxldGUocm91dGVJZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNhbmNlbGxlZFJvdXRlSWRzO1xyXG4gIH1cclxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXHJcbiAgLy8gdXNlZCBieSB0aGUgPFNjcm9sbFJlc3RvcmF0aW9uPiBjb21wb25lbnRcclxuICBmdW5jdGlvbiBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihwb3NpdGlvbnMsIGdldFBvc2l0aW9uLCBnZXRLZXkpIHtcclxuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xyXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBnZXRQb3NpdGlvbjtcclxuICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gZ2V0S2V5IHx8IG51bGw7XHJcbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbiwgc2luY2Ugd2UgbWlzcyB0aGUgYm9hdCBvblxyXG4gICAgLy8gdGhlIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBiZWNhdXNlIHdlJ3ZlIG5vdCB5ZXQgcmVuZGVyZWQgPFNjcm9sbFJlc3RvcmF0aW9uLz5cclxuICAgIC8vIGFuZCB0aGVyZWZvcmUgaGF2ZSBubyBzYXZlZFNjcm9sbFBvc2l0aW9ucyBhdmFpbGFibGVcclxuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xyXG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xyXG4gICAgICBsZXQgeSA9IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xyXG4gICAgICBpZiAoeSAhPSBudWxsKSB7XHJcbiAgICAgICAgdXBkYXRlU3RhdGUoe1xyXG4gICAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiB5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gbnVsbDtcclxuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xyXG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpIHtcclxuICAgIGlmIChnZXRTY3JvbGxSZXN0b3JhdGlvbktleSkge1xyXG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24sIG1hdGNoZXMubWFwKG0gPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgc3RhdGUubG9hZGVyRGF0YSkpKTtcclxuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYXRpb24ua2V5O1xyXG4gIH1cclxuICBmdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcclxuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucyAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xyXG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcclxuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcclxuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucykge1xyXG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcclxuICAgICAgbGV0IHkgPSBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldO1xyXG4gICAgICBpZiAodHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIHBhdGhuYW1lKSB7XHJcbiAgICBpZiAocGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25JbXBsKSB7XHJcbiAgICAgIGlmICghbWF0Y2hlcykge1xyXG4gICAgICAgIGxldCBmb2dNYXRjaGVzID0gbWF0Y2hSb3V0ZXNJbXBsKHJvdXRlc1RvVXNlLCBwYXRobmFtZSwgYmFzZW5hbWUsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICBtYXRjaGVzOiBmb2dNYXRjaGVzIHx8IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWF0Y2hlc1swXS5wYXJhbXMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIC8vIElmIHdlIG1hdGNoZWQgYSBkeW5hbWljIHBhcmFtIG9yIGEgc3BsYXQsIGl0IG1pZ2h0IG9ubHkgYmUgYmVjYXVzZVxyXG4gICAgICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgZGlzY292ZXJlZCBvdGhlciByb3V0ZXMgdGhhdCB3b3VsZCBtYXRjaCB3aXRoIGFcclxuICAgICAgICAgIC8vIGhpZ2hlciBzY29yZS4gIENhbGwgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24ganVzdCB0byBiZSBzdXJlXHJcbiAgICAgICAgICBsZXQgcGFydGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwocm91dGVzVG9Vc2UsIHBhdGhuYW1lLCBiYXNlbmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgICAgIG1hdGNoZXM6IHBhcnRpYWxNYXRjaGVzXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYWN0aXZlOiBmYWxzZSxcclxuICAgICAgbWF0Y2hlczogbnVsbFxyXG4gICAgfTtcclxuICB9XHJcbiAgYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJSb3V0ZXMobWF0Y2hlcywgcGF0aG5hbWUsIHNpZ25hbCkge1xyXG4gICAgaWYgKCFwYXRjaFJvdXRlc09uTmF2aWdhdGlvbkltcGwpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcclxuICAgICAgICBtYXRjaGVzXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBsZXQgcGFydGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgbGV0IGlzTm9uSE1SID0gaW5GbGlnaHREYXRhUm91dGVzID09IG51bGw7XHJcbiAgICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xyXG4gICAgICBsZXQgbG9jYWxNYW5pZmVzdCA9IG1hbmlmZXN0O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uSW1wbCh7XHJcbiAgICAgICAgICBwYXRoOiBwYXRobmFtZSxcclxuICAgICAgICAgIG1hdGNoZXM6IHBhcnRpYWxNYXRjaGVzLFxyXG4gICAgICAgICAgcGF0Y2g6IChyb3V0ZUlkLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHJldHVybjtcclxuICAgICAgICAgICAgcGF0Y2hSb3V0ZXNJbXBsKHJvdXRlSWQsIGNoaWxkcmVuLCByb3V0ZXNUb1VzZSwgbG9jYWxNYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXHJcbiAgICAgICAgICBlcnJvcjogZSxcclxuICAgICAgICAgIHBhcnRpYWxNYXRjaGVzXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGluIHRoZSBtaWRkbGUgb2YgYW4gSE1SIHJldmFsaWRhdGlvbiBhbmQgd2UgY2hhbmdlZCB0aGVcclxuICAgICAgICAvLyByb3V0ZXMsIHByb3ZpZGUgYSBuZXcgaWRlbnRpdHkgc28gd2hlbiB3ZSBgdXBkYXRlU3RhdGVgIGF0IHRoZSBlbmQgb2ZcclxuICAgICAgICAvLyB0aGlzIG5hdmlnYXRpb24vZmV0Y2ggYHJvdXRlci5yb3V0ZXNgIHdpbGwgYmUgYSBuZXcgaWRlbnRpdHkgYW5kXHJcbiAgICAgICAgLy8gdHJpZ2dlciBhIHJlLXJ1biBvZiBtZW1vaXplZCBgcm91dGVyLnJvdXRlc2AgZGVwZW5kZW5jaWVzLlxyXG4gICAgICAgIC8vIEhNUiB3aWxsIGFscmVhZHkgdXBkYXRlIHRoZSBpZGVudGl0eSBhbmQgcmVmbG93IHdoZW4gaXQgbGFuZHNcclxuICAgICAgICAvLyBgaW5GbGlnaHREYXRhUm91dGVzYCBpbiBgY29tcGxldGVOYXZpZ2F0aW9uYFxyXG4gICAgICAgIGlmIChpc05vbkhNUiAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgIGRhdGFSb3V0ZXMgPSBbLi4uZGF0YVJvdXRlc107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB0eXBlOiBcImFib3J0ZWRcIlxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG5ld01hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgcGF0aG5hbWUsIGJhc2VuYW1lKTtcclxuICAgICAgaWYgKG5ld01hdGNoZXMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXHJcbiAgICAgICAgICBtYXRjaGVzOiBuZXdNYXRjaGVzXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgbmV3UGFydGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlc0ltcGwocm91dGVzVG9Vc2UsIHBhdGhuYW1lLCBiYXNlbmFtZSwgdHJ1ZSk7XHJcbiAgICAgIC8vIEF2b2lkIGxvb3BzIGlmIHRoZSBzZWNvbmQgcGFzcyByZXN1bHRzIGluIHRoZSBzYW1lIHBhcnRpYWwgbWF0Y2hlc1xyXG4gICAgICBpZiAoIW5ld1BhcnRpYWxNYXRjaGVzIHx8IHBhcnRpYWxNYXRjaGVzLmxlbmd0aCA9PT0gbmV3UGFydGlhbE1hdGNoZXMubGVuZ3RoICYmIHBhcnRpYWxNYXRjaGVzLmV2ZXJ5KChtLCBpKSA9PiBtLnJvdXRlLmlkID09PSBuZXdQYXJ0aWFsTWF0Y2hlc1tpXS5yb3V0ZS5pZCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXHJcbiAgICAgICAgICBtYXRjaGVzOiBudWxsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBwYXJ0aWFsTWF0Y2hlcyA9IG5ld1BhcnRpYWxNYXRjaGVzO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBfaW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzKSB7XHJcbiAgICBtYW5pZmVzdCA9IHt9O1xyXG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhuZXdSb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllcywgdW5kZWZpbmVkLCBtYW5pZmVzdCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHBhdGNoUm91dGVzKHJvdXRlSWQsIGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgaXNOb25ITVIgPSBpbkZsaWdodERhdGFSb3V0ZXMgPT0gbnVsbDtcclxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xyXG4gICAgcGF0Y2hSb3V0ZXNJbXBsKHJvdXRlSWQsIGNoaWxkcmVuLCByb3V0ZXNUb1VzZSwgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcyk7XHJcbiAgICAvLyBJZiB3ZSBhcmUgbm90IGluIHRoZSBtaWRkbGUgb2YgYW4gSE1SIHJldmFsaWRhdGlvbiBhbmQgd2UgY2hhbmdlZCB0aGVcclxuICAgIC8vIHJvdXRlcywgcHJvdmlkZSBhIG5ldyBpZGVudGl0eSBhbmQgdHJpZ2dlciBhIHJlZmxvdyB2aWEgYHVwZGF0ZVN0YXRlYFxyXG4gICAgLy8gdG8gcmUtcnVuIG1lbW9pemVkIGByb3V0ZXIucm91dGVzYCBkZXBlbmRlbmNpZXMuXHJcbiAgICAvLyBITVIgd2lsbCBhbHJlYWR5IHVwZGF0ZSB0aGUgaWRlbnRpdHkgYW5kIHJlZmxvdyB3aGVuIGl0IGxhbmRzXHJcbiAgICAvLyBgaW5GbGlnaHREYXRhUm91dGVzYCBpbiBgY29tcGxldGVOYXZpZ2F0aW9uYFxyXG4gICAgaWYgKGlzTm9uSE1SKSB7XHJcbiAgICAgIGRhdGFSb3V0ZXMgPSBbLi4uZGF0YVJvdXRlc107XHJcbiAgICAgIHVwZGF0ZVN0YXRlKHt9KTtcclxuICAgIH1cclxuICB9XHJcbiAgcm91dGVyID0ge1xyXG4gICAgZ2V0IGJhc2VuYW1lKCkge1xyXG4gICAgICByZXR1cm4gYmFzZW5hbWU7XHJcbiAgICB9LFxyXG4gICAgZ2V0IGZ1dHVyZSgpIHtcclxuICAgICAgcmV0dXJuIGZ1dHVyZTtcclxuICAgIH0sXHJcbiAgICBnZXQgc3RhdGUoKSB7XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH0sXHJcbiAgICBnZXQgcm91dGVzKCkge1xyXG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcclxuICAgIH0sXHJcbiAgICBnZXQgd2luZG93KCkge1xyXG4gICAgICByZXR1cm4gcm91dGVyV2luZG93O1xyXG4gICAgfSxcclxuICAgIGluaXRpYWxpemUsXHJcbiAgICBzdWJzY3JpYmUsXHJcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcclxuICAgIG5hdmlnYXRlLFxyXG4gICAgZmV0Y2gsXHJcbiAgICByZXZhbGlkYXRlLFxyXG4gICAgLy8gUGFzc3Rocm91Z2ggdG8gaGlzdG9yeS1hd2FyZSBjcmVhdGVIcmVmIHVzZWQgYnkgdXNlSHJlZiBzbyB3ZSBnZXQgcHJvcGVyXHJcbiAgICAvLyBoYXNoLWF3YXJlIFVSTHMgaW4gRE9NIHBhdGhzXHJcbiAgICBjcmVhdGVIcmVmOiB0byA9PiBpbml0Lmhpc3RvcnkuY3JlYXRlSHJlZih0byksXHJcbiAgICBlbmNvZGVMb2NhdGlvbjogdG8gPT4gaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKHRvKSxcclxuICAgIGdldEZldGNoZXIsXHJcbiAgICBkZWxldGVGZXRjaGVyOiBkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUsXHJcbiAgICBkaXNwb3NlLFxyXG4gICAgZ2V0QmxvY2tlcixcclxuICAgIGRlbGV0ZUJsb2NrZXIsXHJcbiAgICBwYXRjaFJvdXRlcyxcclxuICAgIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IGZldGNoQ29udHJvbGxlcnMsXHJcbiAgICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IGFjdGl2ZURlZmVycmVkcyxcclxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxyXG4gICAgLy8gdXBkYXRpbmcgdGhlIHRyZWUgd2hpbGUgdmFsaWRhdGluZyB0aGUgdXBkYXRlIGFsZ29yaXRobS5cclxuICAgIF9pbnRlcm5hbFNldFJvdXRlc1xyXG4gIH07XHJcbiAgcmV0dXJuIHJvdXRlcjtcclxufVxyXG4vLyNlbmRyZWdpb25cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8jcmVnaW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJcclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuY29uc3QgVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCA9IFN5bWJvbChcImRlZmVycmVkXCIpO1xyXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKHJvdXRlcywgb3B0cykge1xyXG4gIGludmFyaWFudChyb3V0ZXMubGVuZ3RoID4gMCwgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCIpO1xyXG4gIGxldCBtYW5pZmVzdCA9IHt9O1xyXG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xyXG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM7XHJcbiAgaWYgKG9wdHMgIT0gbnVsbCAmJiBvcHRzLm1hcFJvdXRlUHJvcGVydGllcykge1xyXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXM7XHJcbiAgfSBlbHNlIGlmIChvcHRzICE9IG51bGwgJiYgb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5KSB7XHJcbiAgICAvLyBJZiB0aGV5IGFyZSBzdGlsbCB1c2luZyB0aGUgZGVwcmVjYXRlZCB2ZXJzaW9uLCB3cmFwIGl0IHdpdGggdGhlIG5ldyBBUElcclxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5O1xyXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gcm91dGUgPT4gKHtcclxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZGV0ZWN0RXJyb3JCb3VuZGFyeShyb3V0ZSlcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzO1xyXG4gIH1cclxuICAvLyBDb25maWcgZHJpdmVuIGJlaGF2aW9yIGZsYWdzXHJcbiAgbGV0IGZ1dHVyZSA9IF9leHRlbmRzKHtcclxuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZSxcclxuICAgIHY3X3Rocm93QWJvcnRSZWFzb246IGZhbHNlXHJcbiAgfSwgb3B0cyA/IG9wdHMuZnV0dXJlIDogbnVsbCk7XHJcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcclxuICAvKipcclxuICAgKiBUaGUgcXVlcnkoKSBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGRvY3VtZW50IHJlcXVlc3RzLCBpbiB3aGljaCB3ZSB3YW50IHRvXHJcbiAgICogY2FsbCBhbiBvcHRpb25hbCBhY3Rpb24gYW5kIHBvdGVudGlhbGx5IG11bHRpcGxlIGxvYWRlcnMgZm9yIGFsbCBuZXN0ZWRcclxuICAgKiByb3V0ZXMuICBJdCByZXR1cm5zIGEgU3RhdGljSGFuZGxlckNvbnRleHQgb2JqZWN0LCB3aGljaCBpcyB2ZXJ5IHNpbWlsYXJcclxuICAgKiB0byB0aGUgcm91dGVyIHN0YXRlIChsb2NhdGlvbiwgbG9hZGVyRGF0YSwgYWN0aW9uRGF0YSwgZXJyb3JzLCBldGMuKSBhbmRcclxuICAgKiBhbHNvIGFkZHMgU1NSLXNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHN0YXR1c0NvZGUgYW5kIGhlYWRlcnNcclxuICAgKiBmcm9tIGFjdGlvbi9sb2FkZXJzIFJlc3BvbnNlcy5cclxuICAgKlxyXG4gICAqIEl0IF9zaG91bGRfIG5ldmVyIHRocm93IGFuZCBzaG91bGQgcmVwb3J0IGFsbCBlcnJvcnMgdGhyb3VnaCB0aGVcclxuICAgKiByZXR1cm5lZCBjb250ZXh0LmVycm9ycyBvYmplY3QsIHByb3Blcmx5IGFzc29jaWF0aW5nIGVycm9ycyB0byB0aGVpciBlcnJvclxyXG4gICAqIGJvdW5kYXJ5LiAgQWRkaXRpb25hbGx5LCBpdCB0cmFja3MgX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgd2hpY2ggY2FuIGJlXHJcbiAgICogdXNlZCB0byBlbXVsYXRlIFJlYWN0IGVycm9yIGJvdW5kYXJpZXMgZHVyaW5nIFNTciBieSBwZXJmb3JtaW5nIGEgc2Vjb25kXHJcbiAgICogcGFzcyBvbmx5IGRvd24gdG8gdGhlIGJvdW5kYXJ5SWQuXHJcbiAgICpcclxuICAgKiBUaGUgb25lIGV4Y2VwdGlvbiB3aGVyZSB3ZSBkbyBub3QgcmV0dXJuIGEgU3RhdGljSGFuZGxlckNvbnRleHQgaXMgd2hlbiBhXHJcbiAgICogcmVkaXJlY3QgcmVzcG9uc2UgaXMgcmV0dXJuZWQgb3IgdGhyb3duIGZyb20gYW55IGFjdGlvbi9sb2FkZXIuICBXZVxyXG4gICAqIHByb3BhZ2F0ZSB0aGF0IG91dCBhbmQgcmV0dXJuIHRoZSByYXcgUmVzcG9uc2Ugc28gdGhlIEhUVFAgc2VydmVyIGNhblxyXG4gICAqIHJldHVybiBpdCBkaXJlY3RseS5cclxuICAgKlxyXG4gICAqIC0gYG9wdHMucmVxdWVzdENvbnRleHRgIGlzIGFuIG9wdGlvbmFsIHNlcnZlciBjb250ZXh0IHRoYXQgd2lsbCBiZSBwYXNzZWRcclxuICAgKiAgIHRvIGFjdGlvbnMvbG9hZGVycyBpbiB0aGUgYGNvbnRleHRgIHBhcmFtZXRlclxyXG4gICAqIC0gYG9wdHMuc2tpcExvYWRlckVycm9yQnViYmxpbmdgIGlzIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHdpbGwgcHJldmVudFxyXG4gICAqICAgdGhlIGJ1YmJsaW5nIG9mIGVycm9ycyB3aGljaCBhbGxvd3Mgc2luZ2xlLWZldGNoLXR5cGUgaW1wbGVtZW50YXRpb25zXHJcbiAgICogICB3aGVyZSB0aGUgY2xpZW50IHdpbGwgaGFuZGxlIHRoZSBidWJibGluZyBhbmQgd2UgbWF5IG5lZWQgdG8gcmV0dXJuIGRhdGFcclxuICAgKiAgIGZvciB0aGUgaGFuZGxpbmcgcm91dGVcclxuICAgKi9cclxuICBhc3luYyBmdW5jdGlvbiBxdWVyeShyZXF1ZXN0LCBfdGVtcDMpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxyXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcclxuICAgICAgZGF0YVN0cmF0ZWd5XHJcbiAgICB9ID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMztcclxuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcclxuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcclxuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xyXG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xyXG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcclxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcclxuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcclxuICAgICAgICBtZXRob2RcclxuICAgICAgfSk7XHJcbiAgICAgIGxldCB7XHJcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXHJcbiAgICAgICAgcm91dGVcclxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYmFzZW5hbWUsXHJcbiAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXHJcbiAgICAgICAgbG9hZGVyRGF0YToge30sXHJcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcclxuICAgICAgICBlcnJvcnM6IHtcclxuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXHJcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXHJcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXHJcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XHJcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XHJcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXHJcbiAgICAgIH0pO1xyXG4gICAgICBsZXQge1xyXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcclxuICAgICAgICByb3V0ZVxyXG4gICAgICB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBiYXNlbmFtZSxcclxuICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXHJcbiAgICAgICAgbG9hZGVyRGF0YToge30sXHJcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcclxuICAgICAgICBlcnJvcnM6IHtcclxuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXHJcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXHJcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXHJcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5IHx8IG51bGwsIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID09PSB0cnVlLCBudWxsKTtcclxuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8vIFdoZW4gcmV0dXJuaW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0LCB3ZSBwYXRjaCBiYWNrIGluIHRoZSBsb2NhdGlvbiBoZXJlXHJcbiAgICAvLyBzaW5jZSB3ZSBuZWVkIGl0IGZvciBSZWFjdCBDb250ZXh0LiAgQnV0IHRoaXMgaGVscHMga2VlcCBvdXIgc3VibWl0IGFuZFxyXG4gICAgLy8gbG9hZFJvdXRlRGF0YSBvcGVyYXRpbmcgb24gYSBSZXF1ZXN0IGluc3RlYWQgb2YgYSBMb2NhdGlvblxyXG4gICAgcmV0dXJuIF9leHRlbmRzKHtcclxuICAgICAgbG9jYXRpb24sXHJcbiAgICAgIGJhc2VuYW1lXHJcbiAgICB9LCByZXN1bHQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUaGUgcXVlcnlSb3V0ZSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgdGFyZ2V0ZWQgcm91dGUgcmVxdWVzdHMsIGVpdGhlclxyXG4gICAqIGZvciBmZXRjaCA/X2RhdGEgcmVxdWVzdHMgb3IgcmVzb3VyY2Ugcm91dGUgcmVxdWVzdHMuICBJbiB0aGlzIGNhc2UsIHdlXHJcbiAgICogYXJlIG9ubHkgZXZlciBjYWxsaW5nIGEgc2luZ2xlIGFjdGlvbiBvciBsb2FkZXIsIGFuZCB3ZSBhcmUgcmV0dXJuaW5nIHRoZVxyXG4gICAqIHJldHVybmVkIHZhbHVlIGRpcmVjdGx5LiAgSW4gbW9zdCBjYXNlcywgdGhpcyB3aWxsIGJlIGEgUmVzcG9uc2UgcmV0dXJuZWRcclxuICAgKiBmcm9tIHRoZSBhY3Rpb24vbG9hZGVyLCBidXQgaXQgbWF5IGJlIGEgcHJpbWl0aXZlIG9yIG90aGVyIHZhbHVlIGFzIHdlbGwgLVxyXG4gICAqIGFuZCBpbiBzdWNoIGNhc2VzIHRoZSBjYWxsaW5nIGNvbnRleHQgc2hvdWxkIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxyXG4gICAqXHJcbiAgICogV2UgZG8gcmVzcGVjdCB0aGUgdGhyb3cvcmV0dXJuIGRpZmZlcmVudGlhdGlvbiwgc28gaWYgYW4gYWN0aW9uL2xvYWRlclxyXG4gICAqIHRocm93cywgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHRocm93IHRoZSB2YWx1ZS4gIFRoaXMgaXMgaW1wb3J0YW50IHNvIHdlXHJcbiAgICogY2FuIGRvIHByb3BlciBib3VuZGFyeSBpZGVudGlmaWNhdGlvbiBpbiBSZW1peCB3aGVyZSBhIHRocm93biBSZXNwb25zZVxyXG4gICAqIG11c3QgZ28gdG8gdGhlIENhdGNoIEJvdW5kYXJ5IGJ1dCBhIHJldHVybmVkIFJlc3BvbnNlIGlzIGhhcHB5LXBhdGguXHJcbiAgICpcclxuICAgKiBPbmUgdGhpbmcgdG8gbm90ZSBpcyB0aGF0IGFueSBSb3V0ZXItaW5pdGlhdGVkIEVycm9ycyB0aGF0IG1ha2Ugc2Vuc2VcclxuICAgKiB0byBhc3NvY2lhdGUgd2l0aCBhIHN0YXR1cyBjb2RlIHdpbGwgYmUgdGhyb3duIGFzIGFuIEVycm9yUmVzcG9uc2VcclxuICAgKiBpbnN0YW5jZSB3aGljaCBpbmNsdWRlIHRoZSByYXcgRXJyb3IsIHN1Y2ggdGhhdCB0aGUgY2FsbGluZyBjb250ZXh0IGNhblxyXG4gICAqIHNlcmlhbGl6ZSB0aGUgZXJyb3IgYXMgdGhleSBzZWUgZml0IHdoaWxlIGluY2x1ZGluZyB0aGUgcHJvcGVyIHJlc3BvbnNlXHJcbiAgICogY29kZS4gIEV4YW1wbGVzIGhlcmUgYXJlIDQwNCBhbmQgNDA1IGVycm9ycyB0aGF0IG9jY3VyIHByaW9yIHRvIHJlYWNoaW5nXHJcbiAgICogYW55IHVzZXItZGVmaW5lZCBsb2FkZXJzLlxyXG4gICAqXHJcbiAgICogLSBgb3B0cy5yb3V0ZUlkYCBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhlIHNwZWNpZmljIHJvdXRlIGhhbmRsZXIgdG8gY2FsbC5cclxuICAgKiAgIElmIG5vdCBwcm92aWRlZCB0aGUgaGFuZGxlciB3aWxsIGRldGVybWluZSB0aGUgcHJvcGVyIHJvdXRlIGJ5IG1hdGNoaW5nXHJcbiAgICogICBhZ2FpbnN0IGByZXF1ZXN0LnVybGBcclxuICAgKiAtIGBvcHRzLnJlcXVlc3RDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBzZXJ2ZXIgY29udGV4dCB0aGF0IHdpbGwgYmUgcGFzc2VkXHJcbiAgICogICAgdG8gYWN0aW9ucy9sb2FkZXJzIGluIHRoZSBgY29udGV4dGAgcGFyYW1ldGVyXHJcbiAgICovXHJcbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShyZXF1ZXN0LCBfdGVtcDQpIHtcclxuICAgIGxldCB7XHJcbiAgICAgIHJvdXRlSWQsXHJcbiAgICAgIHJlcXVlc3RDb250ZXh0LFxyXG4gICAgICBkYXRhU3RyYXRlZ3lcclxuICAgIH0gPSBfdGVtcDQgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA0O1xyXG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xyXG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xyXG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XHJcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XHJcbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxyXG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIiAmJiBtZXRob2QgIT09IFwiT1BUSU9OU1wiKSB7XHJcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XHJcbiAgICAgICAgbWV0aG9kXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xyXG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xyXG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxldCBtYXRjaCA9IHJvdXRlSWQgPyBtYXRjaGVzLmZpbmQobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSA6IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcclxuICAgIGlmIChyb3V0ZUlkICYmICFtYXRjaCkge1xyXG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xyXG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcclxuICAgICAgICByb3V0ZUlkXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmICghbWF0Y2gpIHtcclxuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGl0IEkgZG9uJ3QgdGhpbms/XHJcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XHJcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSB8fCBudWxsLCBmYWxzZSwgbWF0Y2gpO1xyXG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0LmVycm9ycylbMF0gOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBJZiB3ZSBnb3QgYmFjayByZXN1bHQuZXJyb3JzLCB0aGF0IG1lYW5zIHRoZSBsb2FkZXIvYWN0aW9uIHRocmV3XHJcbiAgICAgIC8vIF9zb21ldGhpbmdfIHRoYXQgd2Fzbid0IGEgUmVzcG9uc2UsIGJ1dCBpdCdzIG5vdCBndWFyYW50ZWVkL3JlcXVpcmVkXHJcbiAgICAgIC8vIHRvIGJlIGFuIGBpbnN0YW5jZW9mIEVycm9yYCBlaXRoZXIsIHNvIHdlIGhhdmUgdG8gdXNlIHRocm93IGhlcmUgdG9cclxuICAgICAgLy8gcHJlc2VydmUgdGhlIFwiZXJyb3JcIiBzdGF0ZSBvdXRzaWRlIG9mIHF1ZXJ5SW1wbC5cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICAvLyBQaWNrIG9mZiB0aGUgcmlnaHQgc3RhdGUgdmFsdWUgdG8gcmV0dXJuXHJcbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmFjdGlvbkRhdGEpWzBdO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3VsdC5sb2FkZXJEYXRhKSB7XHJcbiAgICAgIHZhciBfcmVzdWx0JGFjdGl2ZURlZmVycmU7XHJcbiAgICAgIGxldCBkYXRhID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XHJcbiAgICAgIGlmICgoX3Jlc3VsdCRhY3RpdmVEZWZlcnJlID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkcykgIT0gbnVsbCAmJiBfcmVzdWx0JGFjdGl2ZURlZmVycmVbbWF0Y2gucm91dGUuaWRdKSB7XHJcbiAgICAgICAgZGF0YVtVTlNBRkVfREVGRVJSRURfU1lNQk9MXSA9IHJlc3VsdC5hY3RpdmVEZWZlcnJlZHNbbWF0Y2gucm91dGUuaWRdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgcm91dGVNYXRjaCkge1xyXG4gICAgaW52YXJpYW50KHJlcXVlc3Quc2lnbmFsLCBcInF1ZXJ5KCkvcXVlcnlSb3V0ZSgpIHJlcXVlc3RzIG11c3QgY29udGFpbiBhbiBBYm9ydENvbnRyb2xsZXIgc2lnbmFsXCIpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGlzTXV0YXRpb25NZXRob2QocmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VibWl0KHJlcXVlc3QsIG1hdGNoZXMsIHJvdXRlTWF0Y2ggfHwgZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgcm91dGVNYXRjaCAhPSBudWxsKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCByb3V0ZU1hdGNoKTtcclxuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IF9leHRlbmRzKHt9LCByZXN1bHQsIHtcclxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxyXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBJZiB0aGUgdXNlciB0aHJldy9yZXR1cm5lZCBhIFJlc3BvbnNlIGluIGNhbGxMb2FkZXJPckFjdGlvbiBmb3IgYVxyXG4gICAgICAvLyBgcXVlcnlSb3V0ZWAgY2FsbCwgd2UgdGhyb3cgdGhlIGBEYXRhU3RyYXRlZ3lSZXN1bHRgIHRvIGJhaWwgb3V0IGVhcmx5XHJcbiAgICAgIC8vIGFuZCB0aGVuIHJldHVybiBvciB0aHJvdyB0aGUgcmF3IFJlc3BvbnNlIGhlcmUgYWNjb3JkaW5nbHlcclxuICAgICAgaWYgKGlzRGF0YVN0cmF0ZWd5UmVzdWx0KGUpICYmIGlzUmVzcG9uc2UoZS5yZXN1bHQpKSB7XHJcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xyXG4gICAgICAgICAgdGhyb3cgZS5yZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlLnJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICAvLyBSZWRpcmVjdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBzaW5jZSB0aGV5IGRvbid0IHByb3BhZ2F0ZSB0byBjYXRjaFxyXG4gICAgICAvLyBib3VuZGFyaWVzXHJcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoZSkpIHtcclxuICAgICAgICByZXR1cm4gZTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG4gIH1cclxuICBhc3luYyBmdW5jdGlvbiBzdWJtaXQocmVxdWVzdCwgbWF0Y2hlcywgYWN0aW9uTWF0Y2gsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCBpc1JvdXRlUmVxdWVzdCkge1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XHJcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XHJcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcclxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXHJcbiAgICAgICAgcm91dGVJZDogYWN0aW9uTWF0Y2gucm91dGUuaWRcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxyXG4gICAgICAgIGVycm9yXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXCJhY3Rpb25cIiwgcmVxdWVzdCwgW2FjdGlvbk1hdGNoXSwgbWF0Y2hlcywgaXNSb3V0ZVJlcXVlc3QsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3kpO1xyXG4gICAgICByZXN1bHQgPSByZXN1bHRzW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTtcclxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QsIGZ1dHVyZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcclxuICAgICAgLy8gVWhoaGggLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHdlIHNob3VsZCBhbHdheXMgdGhyb3cgdGhlc2UgZnJvbVxyXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcclxuICAgICAgLy8gY2FuIGdldCBiYWNrIG9uIHRoZSBcInRocm93IGFsbCByZWRpcmVjdCByZXNwb25zZXNcIiB0cmFpbiBoZXJlIHNob3VsZFxyXG4gICAgICAvLyB0aGlzIGV2ZXIgaGFwcGVuIDovXHJcbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XHJcbiAgICAgICAgc3RhdHVzOiByZXN1bHQucmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XHJcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XHJcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXHJcbiAgICAgICAgZXJyb3JcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xyXG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXHJcbiAgICAgIC8vIGlzUm91dGVSZXF1ZXN0IHNob3VsZCB0aHJvdyBhbnkgUmVzcG9uc2UgcmVjZWl2ZWQgaW4gY2FsbExvYWRlck9yQWN0aW9uXHJcbiAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcclxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxyXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxyXG4gICAgICAgIGFjdGlvbkRhdGE6IHtcclxuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcnM6IG51bGwsXHJcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxyXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIG9yIHZhbHVlXHJcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxyXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxyXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxyXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXHJcbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XHJcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcclxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXHJcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcclxuICAgIH0pO1xyXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xyXG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcclxuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxyXG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID8gYWN0aW9uTWF0Y2ggOiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcclxuICAgICAgbGV0IGNvbnRleHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKGxvYWRlclJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCBudWxsLCBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XSk7XHJcbiAgICAgIC8vIGFjdGlvbiBzdGF0dXMgY29kZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHN0YXR1cyBjb2Rlc1xyXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcclxuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgPyByZXN1bHQuc3RhdHVzQ29kZSA6IDUwMCxcclxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxyXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IF9leHRlbmRzKHt9LCByZXN1bHQuaGVhZGVycyA/IHtcclxuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzXHJcbiAgICAgICAgfSA6IHt9KVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxldCBjb250ZXh0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShsb2FkZXJSZXF1ZXN0LCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgbnVsbCk7XHJcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHQsIHtcclxuICAgICAgYWN0aW9uRGF0YToge1xyXG4gICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXHJcbiAgICAgIH1cclxuICAgIH0sIHJlc3VsdC5zdGF0dXNDb2RlID8ge1xyXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZVxyXG4gICAgfSA6IHt9LCB7XHJcbiAgICAgIGFjdGlvbkhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzID8ge1xyXG4gICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzXHJcbiAgICAgIH0gOiB7fVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcclxuICAgIGxldCBpc1JvdXRlUmVxdWVzdCA9IHJvdXRlTWF0Y2ggIT0gbnVsbDtcclxuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnlSb3V0ZSgpKVxyXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICEocm91dGVNYXRjaCAhPSBudWxsICYmIHJvdXRlTWF0Y2gucm91dGUubG9hZGVyKSAmJiAhKHJvdXRlTWF0Y2ggIT0gbnVsbCAmJiByb3V0ZU1hdGNoLnJvdXRlLmxhenkpKSB7XHJcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XHJcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcclxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXHJcbiAgICAgICAgcm91dGVJZDogcm91dGVNYXRjaCA9PSBudWxsID8gdm9pZCAwIDogcm91dGVNYXRjaC5yb3V0ZS5pZFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGxldCByZXF1ZXN0TWF0Y2hlcyA9IHJvdXRlTWF0Y2ggPyBbcm91dGVNYXRjaF0gOiBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShtYXRjaGVzLCBwZW5kaW5nQWN0aW9uUmVzdWx0WzBdKSA6IG1hdGNoZXM7XHJcbiAgICBsZXQgbWF0Y2hlc1RvTG9hZCA9IHJlcXVlc3RNYXRjaGVzLmZpbHRlcihtID0+IG0ucm91dGUubG9hZGVyIHx8IG0ucm91dGUubGF6eSk7XHJcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW4gKHF1ZXJ5KCkpXHJcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBtYXRjaGVzLFxyXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XHJcbiAgICAgICAgbG9hZGVyRGF0YTogbWF0Y2hlcy5yZWR1Y2UoKGFjYywgbSkgPT4gT2JqZWN0LmFzc2lnbihhY2MsIHtcclxuICAgICAgICAgIFttLnJvdXRlLmlkXTogbnVsbFxyXG4gICAgICAgIH0pLCB7fSksXHJcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7XHJcbiAgICAgICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3JcclxuICAgICAgICB9IDogbnVsbCxcclxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXHJcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXHJcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXCJsb2FkZXJcIiwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcywgaXNSb3V0ZVJlcXVlc3QsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3kpO1xyXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpO1xyXG4gICAgfVxyXG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcclxuICAgIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwKCk7XHJcbiAgICBsZXQgY29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEobWF0Y2hlcywgcmVzdWx0cywgcGVuZGluZ0FjdGlvblJlc3VsdCwgYWN0aXZlRGVmZXJyZWRzLCBza2lwTG9hZGVyRXJyb3JCdWJibGluZyk7XHJcbiAgICAvLyBBZGQgYSBudWxsIGZvciBhbnkgbm9uLWxvYWRlciBtYXRjaGVzIGZvciBwcm9wZXIgcmV2YWxpZGF0aW9uIG9uIHRoZSBjbGllbnRcclxuICAgIGxldCBleGVjdXRlZExvYWRlcnMgPSBuZXcgU2V0KG1hdGNoZXNUb0xvYWQubWFwKG1hdGNoID0+IG1hdGNoLnJvdXRlLmlkKSk7XHJcbiAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xyXG4gICAgICBpZiAoIWV4ZWN1dGVkTG9hZGVycy5oYXMobWF0Y2gucm91dGUuaWQpKSB7XHJcbiAgICAgICAgY29udGV4dC5sb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBjb250ZXh0LCB7XHJcbiAgICAgIG1hdGNoZXMsXHJcbiAgICAgIGFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLnNpemUgPiAwID8gT2JqZWN0LmZyb21FbnRyaWVzKGFjdGl2ZURlZmVycmVkcy5lbnRyaWVzKCkpIDogbnVsbFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8vIFV0aWxpdHkgd3JhcHBlciBmb3IgY2FsbGluZyBkYXRhU3RyYXRlZ3kgc2VydmVyLXNpZGUgd2l0aG91dCBoYXZpbmcgdG9cclxuICAvLyBwYXNzIGFyb3VuZCB0aGUgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgZXRjLlxyXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3kodHlwZSwgcmVxdWVzdCwgbWF0Y2hlc1RvTG9hZCwgbWF0Y2hlcywgaXNSb3V0ZVJlcXVlc3QsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3kpIHtcclxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneUltcGwoZGF0YVN0cmF0ZWd5IHx8IGRlZmF1bHREYXRhU3RyYXRlZ3ksIHR5cGUsIG51bGwsIHJlcXVlc3QsIG1hdGNoZXNUb0xvYWQsIG1hdGNoZXMsIG51bGwsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIHJlcXVlc3RDb250ZXh0KTtcclxuICAgIGxldCBkYXRhUmVzdWx0cyA9IHt9O1xyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hlcy5tYXAoYXN5bmMgbWF0Y2ggPT4ge1xyXG4gICAgICBpZiAoIShtYXRjaC5yb3V0ZS5pZCBpbiByZXN1bHRzKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XHJcbiAgICAgIGlmIChpc1JlZGlyZWN0RGF0YVN0cmF0ZWd5UmVzdWx0UmVzdWx0KHJlc3VsdCkpIHtcclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQucmVzdWx0O1xyXG4gICAgICAgIC8vIFRocm93IHJlZGlyZWN0cyBhbmQgbGV0IHRoZSBzZXJ2ZXIgaGFuZGxlIHRoZW0gd2l0aCBhbiBIVFRQIHJlZGlyZWN0XHJcbiAgICAgICAgdGhyb3cgbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSwgcmVxdWVzdCwgbWF0Y2gucm91dGUuaWQsIG1hdGNoZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIGlzUm91dGVSZXF1ZXN0KSB7XHJcbiAgICAgICAgLy8gRm9yIFNTUiBzaW5nbGUtcm91dGUgcmVxdWVzdHMsIHdlIHdhbnQgdG8gaGFuZCBSZXNwb25zZXMgYmFja1xyXG4gICAgICAgIC8vIGRpcmVjdGx5IHdpdGhvdXQgdW53cmFwcGluZ1xyXG4gICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICBkYXRhUmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF0gPSBhd2FpdCBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KHJlc3VsdCk7XHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gZGF0YVJlc3VsdHM7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBkYXRhUm91dGVzLFxyXG4gICAgcXVlcnksXHJcbiAgICBxdWVyeVJvdXRlXHJcbiAgfTtcclxufVxyXG4vLyNlbmRyZWdpb25cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8jcmVnaW9uIEhlbHBlcnNcclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGV4aXN0aW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0IGFuZCBhbiBlcnJvciB0aHJvd24gYXQgcmVuZGVyIHRpbWUsXHJcbiAqIHByb3ZpZGUgYW4gdXBkYXRlZCBTdGF0aWNIYW5kbGVyQ29udGV4dCBzdWl0YWJsZSBmb3IgYSBzZWNvbmQgU1NSIHJlbmRlclxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihyb3V0ZXMsIGNvbnRleHQsIGVycm9yKSB7XHJcbiAgbGV0IG5ld0NvbnRleHQgPSBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xyXG4gICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gZXJyb3Iuc3RhdHVzIDogNTAwLFxyXG4gICAgZXJyb3JzOiB7XHJcbiAgICAgIFtjb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZF06IGVycm9yXHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG5ld0NvbnRleHQ7XHJcbn1cclxuZnVuY3Rpb24gdGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yKHJlcXVlc3QsIGlzUm91dGVSZXF1ZXN0LCBmdXR1cmUpIHtcclxuICBpZiAoZnV0dXJlLnY3X3Rocm93QWJvcnRSZWFzb24gJiYgcmVxdWVzdC5zaWduYWwucmVhc29uICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHRocm93IHJlcXVlc3Quc2lnbmFsLnJlYXNvbjtcclxuICB9XHJcbiAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XHJcbiAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArIFwiKCkgY2FsbCBhYm9ydGVkOiBcIiArIHJlcXVlc3QubWV0aG9kICsgXCIgXCIgKyByZXF1ZXN0LnVybCk7XHJcbn1cclxuZnVuY3Rpb24gaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSB7XHJcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiAoXCJmb3JtRGF0YVwiIGluIG9wdHMgJiYgb3B0cy5mb3JtRGF0YSAhPSBudWxsIHx8IFwiYm9keVwiIGluIG9wdHMgJiYgb3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvKGxvY2F0aW9uLCBtYXRjaGVzLCBiYXNlbmFtZSwgcHJlcGVuZEJhc2VuYW1lLCB0bywgdjdfcmVsYXRpdmVTcGxhdFBhdGgsIGZyb21Sb3V0ZUlkLCByZWxhdGl2ZSkge1xyXG4gIGxldCBjb250ZXh0dWFsTWF0Y2hlcztcclxuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcclxuICBpZiAoZnJvbVJvdXRlSWQpIHtcclxuICAgIC8vIEdyYWIgbWF0Y2hlcyB1cCB0byB0aGUgY2FsbGluZyByb3V0ZSBzbyBvdXIgcm91dGUtcmVsYXRpdmUgbG9naWMgaXNcclxuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjb3JyZWN0IHNvdXJjZSByb3V0ZVxyXG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBbXTtcclxuICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcclxuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XHJcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCA9PT0gZnJvbVJvdXRlSWQpIHtcclxuICAgICAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2g7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY29udGV4dHVhbE1hdGNoZXMgPSBtYXRjaGVzO1xyXG4gICAgYWN0aXZlUm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcclxuICB9XHJcbiAgLy8gUmVzb2x2ZSB0aGUgcmVsYXRpdmUgcGF0aFxyXG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKHRvID8gdG8gOiBcIi5cIiwgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhjb250ZXh0dWFsTWF0Y2hlcywgdjdfcmVsYXRpdmVTcGxhdFBhdGgpLCBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsIHJlbGF0aXZlID09PSBcInBhdGhcIik7XHJcbiAgLy8gV2hlbiBgdG9gIGlzIG5vdCBzcGVjaWZpZWQgd2UgaW5oZXJpdCBzZWFyY2gvaGFzaCBmcm9tIHRoZSBjdXJyZW50XHJcbiAgLy8gbG9jYXRpb24sIHVubGlrZSB3aGVuIHRvPVwiLlwiIGFuZCB3ZSBqdXN0IGluaGVyaXQgdGhlIHBhdGguXHJcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xyXG4gIGlmICh0byA9PSBudWxsKSB7XHJcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcclxuICAgIHBhdGguaGFzaCA9IGxvY2F0aW9uLmhhc2g7XHJcbiAgfVxyXG4gIC8vIEFjY291bnQgZm9yIGA/aW5kZXhgIHBhcmFtcyB3aGVuIHJvdXRpbmcgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb25cclxuICBpZiAoKHRvID09IG51bGwgfHwgdG8gPT09IFwiXCIgfHwgdG8gPT09IFwiLlwiKSAmJiBhY3RpdmVSb3V0ZU1hdGNoKSB7XHJcbiAgICBsZXQgbmFrZWRJbmRleCA9IGhhc05ha2VkSW5kZXhRdWVyeShwYXRoLnNlYXJjaCk7XHJcbiAgICBpZiAoYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiAhbmFrZWRJbmRleCkge1xyXG4gICAgICAvLyBBZGQgb25lIHdoZW4gd2UncmUgdGFyZ2V0aW5nIGFuIGluZGV4IHJvdXRlXHJcbiAgICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcclxuICAgIH0gZWxzZSBpZiAoIWFjdGl2ZVJvdXRlTWF0Y2gucm91dGUuaW5kZXggJiYgbmFrZWRJbmRleCkge1xyXG4gICAgICAvLyBSZW1vdmUgZXhpc3Rpbmcgb25lcyB3aGVuIHdlJ3JlIG5vdFxyXG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XHJcbiAgICAgIGxldCBpbmRleFZhbHVlcyA9IHBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcclxuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xyXG4gICAgICBpbmRleFZhbHVlcy5maWx0ZXIodiA9PiB2KS5mb3JFYWNoKHYgPT4gcGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHYpKTtcclxuICAgICAgbGV0IHFzID0gcGFyYW1zLnRvU3RyaW5nKCk7XHJcbiAgICAgIHBhdGguc2VhcmNoID0gcXMgPyBcIj9cIiArIHFzIDogXCJcIjtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZS4gIElmXHJcbiAgLy8gdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93c1xyXG4gIC8vIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZSBvZiBhIHRyYWlsaW5nIHNsYXNoXHJcbiAgLy8gb24gcm9vdCBhY3Rpb25zXHJcbiAgaWYgKHByZXBlbmRCYXNlbmFtZSAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcclxuICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcclxufVxyXG4vLyBOb3JtYWxpemUgbmF2aWdhdGlvbiBvcHRpb25zIGJ5IGNvbnZlcnRpbmcgZm9ybU1ldGhvZD1HRVQgZm9ybURhdGEgb2JqZWN0cyB0b1xyXG4vLyBVUkxTZWFyY2hQYXJhbXMgc28gdGhleSBiZWhhdmUgaWRlbnRpY2FsbHkgdG8gbGlua3Mgd2l0aCBxdWVyeSBwYXJhbXNcclxuZnVuY3Rpb24gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKG5vcm1hbGl6ZUZvcm1NZXRob2QsIGlzRmV0Y2hlciwgcGF0aCwgb3B0cykge1xyXG4gIC8vIFJldHVybiBsb2NhdGlvbiB2ZXJiYXRpbSBvbiBub24tc3VibWlzc2lvbiBuYXZpZ2F0aW9uc1xyXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGF0aFxyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAmJiAhaXNWYWxpZE1ldGhvZChvcHRzLmZvcm1NZXRob2QpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwYXRoLFxyXG4gICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcclxuICAgICAgICBtZXRob2Q6IG9wdHMuZm9ybU1ldGhvZFxyXG4gICAgICB9KVxyXG4gICAgfTtcclxuICB9XHJcbiAgbGV0IGdldEludmFsaWRCb2R5RXJyb3IgPSAoKSA9PiAoe1xyXG4gICAgcGF0aCxcclxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xyXG4gICAgICB0eXBlOiBcImludmFsaWQtYm9keVwiXHJcbiAgICB9KVxyXG4gIH0pO1xyXG4gIC8vIENyZWF0ZSBhIFN1Ym1pc3Npb24gb24gbm9uLUdFVCBuYXZpZ2F0aW9uc1xyXG4gIGxldCByYXdGb3JtTWV0aG9kID0gb3B0cy5mb3JtTWV0aG9kIHx8IFwiZ2V0XCI7XHJcbiAgbGV0IGZvcm1NZXRob2QgPSBub3JtYWxpemVGb3JtTWV0aG9kID8gcmF3Rm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpIDogcmF3Rm9ybU1ldGhvZC50b0xvd2VyQ2FzZSgpO1xyXG4gIGxldCBmb3JtQWN0aW9uID0gc3RyaXBIYXNoRnJvbVBhdGgocGF0aCk7XHJcbiAgaWYgKG9wdHMuYm9keSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcclxuICAgICAgLy8gdGV4dCBvbmx5IHN1cHBvcnQgUE9TVC9QVVQvUEFUQ0gvREVMRVRFIHN1Ym1pc3Npb25zXHJcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHRleHQgPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gb3B0cy5ib2R5IDogb3B0cy5ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEgfHwgb3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID9cclxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjcGxhaW4tdGV4dC1mb3JtLWRhdGFcclxuICAgICAgQXJyYXkuZnJvbShvcHRzLmJvZHkuZW50cmllcygpKS5yZWR1Y2UoKGFjYywgX3JlZjMpID0+IHtcclxuICAgICAgICBsZXQgW25hbWUsIHZhbHVlXSA9IF9yZWYzO1xyXG4gICAgICAgIHJldHVybiBcIlwiICsgYWNjICsgbmFtZSArIFwiPVwiICsgdmFsdWUgKyBcIlxcblwiO1xyXG4gICAgICB9LCBcIlwiKSA6IFN0cmluZyhvcHRzLmJvZHkpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgc3VibWlzc2lvbjoge1xyXG4gICAgICAgICAgZm9ybU1ldGhvZCxcclxuICAgICAgICAgIGZvcm1BY3Rpb24sXHJcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcclxuICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICBqc29uOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xyXG4gICAgICAvLyBqc29uIG9ubHkgc3VwcG9ydHMgUE9TVC9QVVQvUEFUQ0gvREVMRVRFIHN1Ym1pc3Npb25zXHJcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQganNvbiA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKG9wdHMuYm9keSkgOiBvcHRzLmJvZHk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICBzdWJtaXNzaW9uOiB7XHJcbiAgICAgICAgICAgIGZvcm1NZXRob2QsXHJcbiAgICAgICAgICAgIGZvcm1BY3Rpb24sXHJcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxyXG4gICAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBqc29uLFxyXG4gICAgICAgICAgICB0ZXh0OiB1bmRlZmluZWRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpbnZhcmlhbnQodHlwZW9mIEZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCIsIFwiRm9ybURhdGEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xyXG4gIGxldCBzZWFyY2hQYXJhbXM7XHJcbiAgbGV0IGZvcm1EYXRhO1xyXG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XHJcbiAgICBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmZvcm1EYXRhKTtcclxuICAgIGZvcm1EYXRhID0gb3B0cy5mb3JtRGF0YTtcclxuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XHJcbiAgICBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmJvZHkpO1xyXG4gICAgZm9ybURhdGEgPSBvcHRzLmJvZHk7XHJcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcclxuICAgIHNlYXJjaFBhcmFtcyA9IG9wdHMuYm9keTtcclxuICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcclxuICB9IGVsc2UgaWYgKG9wdHMuYm9keSA9PSBudWxsKSB7XHJcbiAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XHJcbiAgICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcclxuICAgIH1cclxuICB9XHJcbiAgbGV0IHN1Ym1pc3Npb24gPSB7XHJcbiAgICBmb3JtTWV0aG9kLFxyXG4gICAgZm9ybUFjdGlvbixcclxuICAgIGZvcm1FbmNUeXBlOiBvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcclxuICAgIGZvcm1EYXRhLFxyXG4gICAganNvbjogdW5kZWZpbmVkLFxyXG4gICAgdGV4dDogdW5kZWZpbmVkXHJcbiAgfTtcclxuICBpZiAoaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwYXRoLFxyXG4gICAgICBzdWJtaXNzaW9uXHJcbiAgICB9O1xyXG4gIH1cclxuICAvLyBGbGF0dGVuIHN1Ym1pc3Npb24gb250byBVUkxTZWFyY2hQYXJhbXMgZm9yIEdFVCBzdWJtaXNzaW9uc1xyXG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xyXG4gIC8vIE9uIEdFVCBuYXZpZ2F0aW9uIHN1Ym1pc3Npb25zIHdlIGNhbiBkcm9wIHRoZSA/aW5kZXggcGFyYW0gZnJvbSB0aGVcclxuICAvLyByZXN1bHRpbmcgbG9jYXRpb24gc2luY2UgYWxsIGxvYWRlcnMgd2lsbCBydW4uICBCdXQgZmV0Y2hlciBHRVQgc3VibWlzc2lvbnNcclxuICAvLyBvbmx5IHJ1biBhIHNpbmdsZSBsb2FkZXIgc28gd2UgbmVlZCB0byBwcmVzZXJ2ZSBhbnkgaW5jb21pbmcgP2luZGV4IHBhcmFtc1xyXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xyXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIFwiXCIpO1xyXG4gIH1cclxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IFwiP1wiICsgc2VhcmNoUGFyYW1zO1xyXG4gIHJldHVybiB7XHJcbiAgICBwYXRoOiBjcmVhdGVQYXRoKHBhcnNlZFBhdGgpLFxyXG4gICAgc3VibWlzc2lvblxyXG4gIH07XHJcbn1cclxuLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGF0L2JlbG93IGFueSBjYXVnaHQgZXJyb3IgYXMgdGhleSBhcmVuJ3QgZ29pbmcgdG9cclxuLy8gcmVuZGVyIHNvIHdlIGRvbid0IG5lZWQgdG8gbG9hZCB0aGVtXHJcbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQsIGluY2x1ZGVCb3VuZGFyeSkge1xyXG4gIGlmIChpbmNsdWRlQm91bmRhcnkgPT09IHZvaWQgMCkge1xyXG4gICAgaW5jbHVkZUJvdW5kYXJ5ID0gZmFsc2U7XHJcbiAgfVxyXG4gIGxldCBpbmRleCA9IG1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCA9PT0gYm91bmRhcnlJZCk7XHJcbiAgaWYgKGluZGV4ID49IDApIHtcclxuICAgIHJldHVybiBtYXRjaGVzLnNsaWNlKDAsIGluY2x1ZGVCb3VuZGFyeSA/IGluZGV4ICsgMSA6IGluZGV4KTtcclxuICB9XHJcbiAgcmV0dXJuIG1hdGNoZXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWF0Y2hlc1RvTG9hZChoaXN0b3J5LCBzdGF0ZSwgbWF0Y2hlcywgc3VibWlzc2lvbiwgbG9jYXRpb24sIGluaXRpYWxIeWRyYXRpb24sIHNraXBBY3Rpb25FcnJvclJldmFsaWRhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsIGNhbmNlbGxlZEZldGNoZXJMb2FkcywgZGVsZXRlZEZldGNoZXJzLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcclxuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0FjdGlvblJlc3VsdCA/IGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhIDogdW5kZWZpbmVkO1xyXG4gIGxldCBjdXJyZW50VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RhdGUubG9jYXRpb24pO1xyXG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xyXG4gIC8vIFBpY2sgbmF2aWdhdGlvbiBtYXRjaGVzIHRoYXQgYXJlIG5ldC1uZXcgb3IgcXVhbGlmeSBmb3IgcmV2YWxpZGF0aW9uXHJcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXM7XHJcbiAgaWYgKGluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUuZXJyb3JzKSB7XHJcbiAgICAvLyBPbiBpbml0aWFsIGh5ZHJhdGlvbiwgb25seSBjb25zaWRlciBtYXRjaGVzIHVwIHRvIF9hbmQgaW5jbHVkaW5nXyB0aGUgYm91bmRhcnkuXHJcbiAgICAvLyBUaGlzIGlzIGluY2x1c2l2ZSB0byBoYW5kbGUgY2FzZXMgd2hlcmUgYSBzZXJ2ZXIgbG9hZGVyIHJhbiBzdWNjZXNzZnVsbHksXHJcbiAgICAvLyBhIGNoaWxkIHNlcnZlciBsb2FkZXIgYnViYmxlZCB1cCB0byB0aGlzIHJvdXRlLCBidXQgdGhpcyByb3V0ZSBoYXNcclxuICAgIC8vIGBjbGllbnRMb2FkZXIuaHlkcmF0ZWAgc28gd2Ugd2FudCB0byBzdGlsbCBydW4gdGhlIGBjbGllbnRMb2FkZXJgIHNvIHRoYXRcclxuICAgIC8vIHdlIGhhdmUgYSBjb21wbGV0ZSB2ZXJzaW9uIG9mIGBsb2FkZXJEYXRhYFxyXG4gICAgYm91bmRhcnlNYXRjaGVzID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgT2JqZWN0LmtleXMoc3RhdGUuZXJyb3JzKVswXSwgdHJ1ZSk7XHJcbiAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkpIHtcclxuICAgIC8vIElmIGFuIGFjdGlvbiB0aHJldyBhbiBlcnJvciwgd2UgY2FsbCBsb2FkZXJzIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZyB0aGVcclxuICAgIC8vIGJvdW5kYXJ5XHJcbiAgICBib3VuZGFyeU1hdGNoZXMgPSBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShtYXRjaGVzLCBwZW5kaW5nQWN0aW9uUmVzdWx0WzBdKTtcclxuICB9XHJcbiAgLy8gRG9uJ3QgcmV2YWxpZGF0ZSBsb2FkZXJzIGJ5IGRlZmF1bHQgYWZ0ZXIgYWN0aW9uIDR4eC81eHggcmVzcG9uc2VzXHJcbiAgLy8gd2hlbiB0aGUgZmxhZyBpcyBlbmFibGVkLiAgVGhleSBjYW4gc3RpbGwgb3B0LWludG8gcmV2YWxpZGF0aW9uIHZpYVxyXG4gIC8vIGBzaG91bGRSZXZhbGlkYXRlYCB2aWEgYGFjdGlvblJlc3VsdGBcclxuICBsZXQgYWN0aW9uU3RhdHVzID0gcGVuZGluZ0FjdGlvblJlc3VsdCA/IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uc3RhdHVzQ29kZSA6IHVuZGVmaW5lZDtcclxuICBsZXQgc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA9IHNraXBBY3Rpb25FcnJvclJldmFsaWRhdGlvbiAmJiBhY3Rpb25TdGF0dXMgJiYgYWN0aW9uU3RhdHVzID49IDQwMDtcclxuICBsZXQgbmF2aWdhdGlvbk1hdGNoZXMgPSBib3VuZGFyeU1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIHJvdXRlXHJcbiAgICB9ID0gbWF0Y2g7XHJcbiAgICBpZiAocm91dGUubGF6eSkge1xyXG4gICAgICAvLyBXZSBoYXZlbid0IGxvYWRlZCB0aGlzIHJvdXRlIHlldCBzbyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgZ290IGEgbG9hZGVyIVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChyb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5pdGlhbEh5ZHJhdGlvbikge1xyXG4gICAgICByZXR1cm4gc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24ocm91dGUsIHN0YXRlLmxvYWRlckRhdGEsIHN0YXRlLmVycm9ycyk7XHJcbiAgICB9XHJcbiAgICAvLyBBbHdheXMgY2FsbCB0aGUgbG9hZGVyIG9uIG5ldyByb3V0ZSBpbnN0YW5jZXMgYW5kIHBlbmRpbmcgZGVmZXIgY2FuY2VsbGF0aW9uc1xyXG4gICAgaWYgKGlzTmV3TG9hZGVyKHN0YXRlLmxvYWRlckRhdGEsIHN0YXRlLm1hdGNoZXNbaW5kZXhdLCBtYXRjaCkgfHwgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMuc29tZShpZCA9PiBpZCA9PT0gbWF0Y2gucm91dGUuaWQpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igd2hlbiB3ZSByZXZhbGlkYXRlLiAgSWYgdGhlIHJvdXRlXHJcbiAgICAvLyBwcm92aWRlcyBpdCdzIG93biBpbXBsZW1lbnRhdGlvbiwgdGhlbiB3ZSBnaXZlIHRoZW0gZnVsbCBjb250cm9sIGJ1dFxyXG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXHJcbiAgICAvLyB0aGVpciBvd24gc3BlY2lmaWMgdXNlIGNhc2VzXHJcbiAgICBsZXQgY3VycmVudFJvdXRlTWF0Y2ggPSBzdGF0ZS5tYXRjaGVzW2luZGV4XTtcclxuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xyXG4gICAgcmV0dXJuIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIF9leHRlbmRzKHtcclxuICAgICAgY3VycmVudFVybCxcclxuICAgICAgY3VycmVudFBhcmFtczogY3VycmVudFJvdXRlTWF0Y2gucGFyYW1zLFxyXG4gICAgICBuZXh0VXJsLFxyXG4gICAgICBuZXh0UGFyYW1zOiBuZXh0Um91dGVNYXRjaC5wYXJhbXNcclxuICAgIH0sIHN1Ym1pc3Npb24sIHtcclxuICAgICAgYWN0aW9uUmVzdWx0LFxyXG4gICAgICBhY3Rpb25TdGF0dXMsXHJcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBzaG91bGRTa2lwUmV2YWxpZGF0aW9uID8gZmFsc2UgOlxyXG4gICAgICAvLyBGb3JjZWQgcmV2YWxpZGF0aW9uIGR1ZSB0byBzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRvciwgb3IgWC1SZW1peC1SZXZhbGlkYXRlXHJcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgfHwgY3VycmVudFVybC5wYXRobmFtZSArIGN1cnJlbnRVcmwuc2VhcmNoID09PSBuZXh0VXJsLnBhdGhuYW1lICsgbmV4dFVybC5zZWFyY2ggfHxcclxuICAgICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcclxuICAgICAgY3VycmVudFVybC5zZWFyY2ggIT09IG5leHRVcmwuc2VhcmNoIHx8IGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50Um91dGVNYXRjaCwgbmV4dFJvdXRlTWF0Y2gpXHJcbiAgICB9KSk7XHJcbiAgfSk7XHJcbiAgLy8gUGljayBmZXRjaGVyLmxvYWRzIHRoYXQgbmVlZCB0byBiZSByZXZhbGlkYXRlZFxyXG4gIGxldCByZXZhbGlkYXRpbmdGZXRjaGVycyA9IFtdO1xyXG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XHJcbiAgICAvLyBEb24ndCByZXZhbGlkYXRlOlxyXG4gICAgLy8gIC0gb24gaW5pdGlhbCBoeWRyYXRpb24gKHNob3VsZG4ndCBiZSBhbnkgZmV0Y2hlcnMgdGhlbiBhbnl3YXkpXHJcbiAgICAvLyAgLSBpZiBmZXRjaGVyIHdvbid0IGJlIHByZXNlbnQgaW4gdGhlIHN1YnNlcXVlbnQgcmVuZGVyXHJcbiAgICAvLyAgICAtIG5vIGxvbmdlciBtYXRjaGVzIHRoZSBVUkwgKHY3X2ZldGNoZXJQZXJzaXN0PWZhbHNlKVxyXG4gICAgLy8gICAgLSB3YXMgdW5tb3VudGVkIGJ1dCBwZXJzaXN0ZWQgZHVlIHRvIHY3X2ZldGNoZXJQZXJzaXN0PXRydWVcclxuICAgIGlmIChpbml0aWFsSHlkcmF0aW9uIHx8ICFtYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSBmLnJvdXRlSWQpIHx8IGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XHJcbiAgICAvLyBJZiB0aGUgZmV0Y2hlciBwYXRoIG5vIGxvbmdlciBtYXRjaGVzLCBwdXNoIGl0IGluIHdpdGggbnVsbCBtYXRjaGVzIHNvXHJcbiAgICAvLyB3ZSBjYW4gdHJpZ2dlciBhIDQwNCBpbiBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEuICBOb3RlIHRoaXMgaXNcclxuICAgIC8vIGN1cnJlbnRseSBvbmx5IGEgdXNlLWNhc2UgZm9yIFJlbWl4IEhNUiB3aGVyZSB0aGUgcm91dGUgdHJlZSBjYW4gY2hhbmdlXHJcbiAgICAvLyBhdCBydW50aW1lIGFuZCByZW1vdmUgYSByb3V0ZSBwcmV2aW91c2x5IGxvYWRlZCB2aWEgYSBmZXRjaGVyXHJcbiAgICBpZiAoIWZldGNoZXJNYXRjaGVzKSB7XHJcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xyXG4gICAgICAgIGtleSxcclxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXHJcbiAgICAgICAgcGF0aDogZi5wYXRoLFxyXG4gICAgICAgIG1hdGNoZXM6IG51bGwsXHJcbiAgICAgICAgbWF0Y2g6IG51bGwsXHJcbiAgICAgICAgY29udHJvbGxlcjogbnVsbFxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gUmV2YWxpZGF0aW5nIGZldGNoZXJzIGFyZSBkZWNvdXBsZWQgZnJvbSB0aGUgcm91dGUgbWF0Y2hlcyBzaW5jZSB0aGV5XHJcbiAgICAvLyBsb2FkIGZyb20gYSBzdGF0aWMgaHJlZi4gIFRoZXkgcmV2YWxpZGF0ZSBiYXNlZCBvbiBleHBsaWNpdCByZXZhbGlkYXRpb25cclxuICAgIC8vIChzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRvciwgb3IgWC1SZW1peC1SZXZhbGlkYXRlKVxyXG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcclxuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcclxuICAgIGxldCBzaG91bGRSZXZhbGlkYXRlID0gZmFsc2U7XHJcbiAgICBpZiAoZmV0Y2hSZWRpcmVjdElkcy5oYXMoa2V5KSkge1xyXG4gICAgICAvLyBOZXZlciB0cmlnZ2VyIGEgcmV2YWxpZGF0aW9uIG9mIGFuIGFjdGl2ZWx5IHJlZGlyZWN0aW5nIGZldGNoZXJcclxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmIChjYW5jZWxsZWRGZXRjaGVyTG9hZHMuaGFzKGtleSkpIHtcclxuICAgICAgLy8gQWx3YXlzIG1hcmsgZm9yIHJldmFsaWRhdGlvbiBpZiB0aGUgZmV0Y2hlciB3YXMgY2FuY2VsbGVkXHJcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5kZWxldGUoa2V5KTtcclxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSAhPT0gXCJpZGxlXCIgJiYgZmV0Y2hlci5kYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gSWYgdGhlIGZldGNoZXIgaGFzbid0IGV2ZXIgY29tcGxldGVkIGxvYWRpbmcgeWV0LCB0aGVuIHRoaXMgaXNuJ3QgYVxyXG4gICAgICAvLyByZXZhbGlkYXRpb24sIGl0IHdvdWxkIGp1c3QgYmUgYSBicmFuZCBuZXcgbG9hZCBpZiBhbiBleHBsaWNpdFxyXG4gICAgICAvLyByZXZhbGlkYXRpb24gaXMgcmVxdWlyZWRcclxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPdGhlcndpc2UgZmFsbCBiYWNrIG9uIGFueSB1c2VyLWRlZmluZWQgc2hvdWxkUmV2YWxpZGF0ZSwgZGVmYXVsdGluZ1xyXG4gICAgICAvLyB0byBleHBsaWNpdCByZXZhbGlkYXRpb25zIG9ubHlcclxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZmV0Y2hlck1hdGNoLCBfZXh0ZW5kcyh7XHJcbiAgICAgICAgY3VycmVudFVybCxcclxuICAgICAgICBjdXJyZW50UGFyYW1zOiBzdGF0ZS5tYXRjaGVzW3N0YXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxyXG4gICAgICAgIG5leHRVcmwsXHJcbiAgICAgICAgbmV4dFBhcmFtczogbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtc1xyXG4gICAgICB9LCBzdWJtaXNzaW9uLCB7XHJcbiAgICAgICAgYWN0aW9uUmVzdWx0LFxyXG4gICAgICAgIGFjdGlvblN0YXR1cyxcclxuICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTogc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA/IGZhbHNlIDogaXNSZXZhbGlkYXRpb25SZXF1aXJlZFxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkUmV2YWxpZGF0ZSkge1xyXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcclxuICAgICAgICBrZXksXHJcbiAgICAgICAgcm91dGVJZDogZi5yb3V0ZUlkLFxyXG4gICAgICAgIHBhdGg6IGYucGF0aCxcclxuICAgICAgICBtYXRjaGVzOiBmZXRjaGVyTWF0Y2hlcyxcclxuICAgICAgICBtYXRjaDogZmV0Y2hlck1hdGNoLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gW25hdmlnYXRpb25NYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVyc107XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24ocm91dGUsIGxvYWRlckRhdGEsIGVycm9ycykge1xyXG4gIC8vIFdlIGR1bm5vIGlmIHdlIGhhdmUgYSBsb2FkZXIgLSBnb3R0YSBmaW5kIG91dCFcclxuICBpZiAocm91dGUubGF6eSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8vIE5vIGxvYWRlciwgbm90aGluZyB0byBpbml0aWFsaXplXHJcbiAgaWYgKCFyb3V0ZS5sb2FkZXIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgbGV0IGhhc0RhdGEgPSBsb2FkZXJEYXRhICE9IG51bGwgJiYgbG9hZGVyRGF0YVtyb3V0ZS5pZF0gIT09IHVuZGVmaW5lZDtcclxuICBsZXQgaGFzRXJyb3IgPSBlcnJvcnMgIT0gbnVsbCAmJiBlcnJvcnNbcm91dGUuaWRdICE9PSB1bmRlZmluZWQ7XHJcbiAgLy8gRG9uJ3QgcnVuIGlmIHdlIGVycm9yJ2QgZHVyaW5nIFNTUlxyXG4gIGlmICghaGFzRGF0YSAmJiBoYXNFcnJvcikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvLyBFeHBsaWNpdGx5IG9wdGluZy1pbiB0byBydW5uaW5nIG9uIGh5ZHJhdGlvblxyXG4gIGlmICh0eXBlb2Ygcm91dGUubG9hZGVyID09PSBcImZ1bmN0aW9uXCIgJiYgcm91dGUubG9hZGVyLmh5ZHJhdGUgPT09IHRydWUpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICAvLyBPdGhlcndpc2UsIHJ1biBpZiB3ZSdyZSBub3QgeWV0IGluaXRpYWxpemVkIHdpdGggYW55dGhpbmdcclxuICByZXR1cm4gIWhhc0RhdGEgJiYgIWhhc0Vycm9yO1xyXG59XHJcbmZ1bmN0aW9uIGlzTmV3TG9hZGVyKGN1cnJlbnRMb2FkZXJEYXRhLCBjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XHJcbiAgbGV0IGlzTmV3ID1cclxuICAvLyBbYV0gLT4gW2EsIGJdXHJcbiAgIWN1cnJlbnRNYXRjaCB8fFxyXG4gIC8vIFthLCBiXSAtPiBbYSwgY11cclxuICBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoLnJvdXRlLmlkO1xyXG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB0aGF0IHdlIGRvbid0IGhhdmUgZGF0YSBmb3IgYSByZS11c2VkIHJvdXRlLCBwb3RlbnRpYWxseVxyXG4gIC8vIGZyb20gYSBwcmlvciBlcnJvciBvciBmcm9tIGEgY2FuY2VsbGVkIHBlbmRpbmcgZGVmZXJyZWRcclxuICBsZXQgaXNNaXNzaW5nRGF0YSA9IGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkO1xyXG4gIC8vIEFsd2F5cyBsb2FkIGlmIHRoaXMgaXMgYSBuZXQtbmV3IHJvdXRlIG9yIHdlIGRvbid0IHlldCBoYXZlIGRhdGFcclxuICByZXR1cm4gaXNOZXcgfHwgaXNNaXNzaW5nRGF0YTtcclxufVxyXG5mdW5jdGlvbiBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudE1hdGNoLCBtYXRjaCkge1xyXG4gIGxldCBjdXJyZW50UGF0aCA9IGN1cnJlbnRNYXRjaC5yb3V0ZS5wYXRoO1xyXG4gIHJldHVybiAoXHJcbiAgICAvLyBwYXJhbSBjaGFuZ2UgZm9yIHRoaXMgbWF0Y2gsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxyXG4gICAgY3VycmVudE1hdGNoLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fFxyXG4gICAgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxyXG4gICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXHJcbiAgICBjdXJyZW50UGF0aCAhPSBudWxsICYmIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihsb2FkZXJNYXRjaCwgYXJnKSB7XHJcbiAgaWYgKGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcclxuICAgIGxldCByb3V0ZUNob2ljZSA9IGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUoYXJnKTtcclxuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaFJvdXRlc0ltcGwocm91dGVJZCwgY2hpbGRyZW4sIHJvdXRlc1RvVXNlLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzKSB7XHJcbiAgdmFyIF9jaGlsZHJlblRvUGF0Y2g7XHJcbiAgbGV0IGNoaWxkcmVuVG9QYXRjaDtcclxuICBpZiAocm91dGVJZCkge1xyXG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Rbcm91dGVJZF07XHJcbiAgICBpbnZhcmlhbnQocm91dGUsIFwiTm8gcm91dGUgZm91bmQgdG8gcGF0Y2ggY2hpbGRyZW4gaW50bzogcm91dGVJZCA9IFwiICsgcm91dGVJZCk7XHJcbiAgICBpZiAoIXJvdXRlLmNoaWxkcmVuKSB7XHJcbiAgICAgIHJvdXRlLmNoaWxkcmVuID0gW107XHJcbiAgICB9XHJcbiAgICBjaGlsZHJlblRvUGF0Y2ggPSByb3V0ZS5jaGlsZHJlbjtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hpbGRyZW5Ub1BhdGNoID0gcm91dGVzVG9Vc2U7XHJcbiAgfVxyXG4gIC8vIERvbid0IHBhdGNoIGluIHJvdXRlcyB3ZSBhbHJlYWR5IGtub3cgYWJvdXQgc28gdGhhdCBgcGF0Y2hgIGlzIGlkZW1wb3RlbnRcclxuICAvLyB0byBzaW1wbGlmeSB1c2VyLWxhbmQgY29kZS4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSB3ZSByZS1jYWxsIHRoZVxyXG4gIC8vIGBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbmAgZnVuY3Rpb24gZm9yIG1hdGNoZWQgcm91dGVzIHdpdGggcGFyYW1zLlxyXG4gIGxldCB1bmlxdWVDaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihuZXdSb3V0ZSA9PiAhY2hpbGRyZW5Ub1BhdGNoLnNvbWUoZXhpc3RpbmdSb3V0ZSA9PiBpc1NhbWVSb3V0ZShuZXdSb3V0ZSwgZXhpc3RpbmdSb3V0ZSkpKTtcclxuICBsZXQgbmV3Um91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyh1bmlxdWVDaGlsZHJlbiwgbWFwUm91dGVQcm9wZXJ0aWVzLCBbcm91dGVJZCB8fCBcIl9cIiwgXCJwYXRjaFwiLCBTdHJpbmcoKChfY2hpbGRyZW5Ub1BhdGNoID0gY2hpbGRyZW5Ub1BhdGNoKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkcmVuVG9QYXRjaC5sZW5ndGgpIHx8IFwiMFwiKV0sIG1hbmlmZXN0KTtcclxuICBjaGlsZHJlblRvUGF0Y2gucHVzaCguLi5uZXdSb3V0ZXMpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVJvdXRlKG5ld1JvdXRlLCBleGlzdGluZ1JvdXRlKSB7XHJcbiAgLy8gTW9zdCBvcHRpbWFsIGNoZWNrIGlzIGJ5IGlkXHJcbiAgaWYgKFwiaWRcIiBpbiBuZXdSb3V0ZSAmJiBcImlkXCIgaW4gZXhpc3RpbmdSb3V0ZSAmJiBuZXdSb3V0ZS5pZCA9PT0gZXhpc3RpbmdSb3V0ZS5pZCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8vIFNlY29uZCBpcyBieSBwYXRoaW5nIGRpZmZlcmVuY2VzXHJcbiAgaWYgKCEobmV3Um91dGUuaW5kZXggPT09IGV4aXN0aW5nUm91dGUuaW5kZXggJiYgbmV3Um91dGUucGF0aCA9PT0gZXhpc3RpbmdSb3V0ZS5wYXRoICYmIG5ld1JvdXRlLmNhc2VTZW5zaXRpdmUgPT09IGV4aXN0aW5nUm91dGUuY2FzZVNlbnNpdGl2ZSkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLy8gUGF0aGxlc3MgbGF5b3V0IHJvdXRlcyBhcmUgdHJpY2tpZXIgc2luY2Ugd2UgbmVlZCB0byBjaGVjayBjaGlsZHJlbi5cclxuICAvLyBJZiB0aGV5IGhhdmUgbm8gY2hpbGRyZW4gdGhlbiB0aGV5J3JlIHRoZSBzYW1lIGFzIGZhciBhcyB3ZSBjYW4gdGVsbFxyXG4gIGlmICgoIW5ld1JvdXRlLmNoaWxkcmVuIHx8IG5ld1JvdXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgKCFleGlzdGluZ1JvdXRlLmNoaWxkcmVuIHx8IGV4aXN0aW5nUm91dGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8vIE90aGVyd2lzZSwgd2UgbG9vayB0byBzZWUgaWYgZXZlcnkgY2hpbGQgaW4gdGhlIG5ldyByb3V0ZSBpcyBhbHJlYWR5XHJcbiAgLy8gcmVwcmVzZW50ZWQgaW4gdGhlIGV4aXN0aW5nIHJvdXRlJ3MgY2hpbGRyZW5cclxuICByZXR1cm4gbmV3Um91dGUuY2hpbGRyZW4uZXZlcnkoKGFDaGlsZCwgaSkgPT4ge1xyXG4gICAgdmFyIF9leGlzdGluZ1JvdXRlJGNoaWxkcjtcclxuICAgIHJldHVybiAoX2V4aXN0aW5nUm91dGUkY2hpbGRyID0gZXhpc3RpbmdSb3V0ZS5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9leGlzdGluZ1JvdXRlJGNoaWxkci5zb21lKGJDaGlsZCA9PiBpc1NhbWVSb3V0ZShhQ2hpbGQsIGJDaGlsZCkpO1xyXG4gIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlIHJvdXRlLmxhenkoKSBtZXRob2RzIHRvIGxhemlseSBsb2FkIHJvdXRlIG1vZHVsZXMgKGxvYWRlciwgYWN0aW9uLFxyXG4gKiBzaG91bGRSZXZhbGlkYXRlKSBhbmQgdXBkYXRlIHRoZSByb3V0ZU1hbmlmZXN0IGluIHBsYWNlIHdoaWNoIHNoYXJlcyBvYmplY3RzXHJcbiAqIHdpdGggZGF0YVJvdXRlcyBzbyB0aG9zZSBnZXQgdXBkYXRlZCBhcyB3ZWxsLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbG9hZExhenlSb3V0ZU1vZHVsZShyb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCkge1xyXG4gIGlmICghcm91dGUubGF6eSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xyXG4gIC8vIElmIHRoZSBsYXp5IHJvdXRlIGZ1bmN0aW9uIHdhcyBleGVjdXRlZCBhbmQgcmVtb3ZlZCBieSBhbm90aGVyIHBhcmFsbGVsXHJcbiAgLy8gY2FsbCB0aGVuIHdlIGNhbiByZXR1cm4gLSBmaXJzdCBsYXp5KCkgdG8gZmluaXNoIHdpbnMgYmVjYXVzZSB0aGUgcmV0dXJuXHJcbiAgLy8gdmFsdWUgb2YgbGF6eSBpcyBleHBlY3RlZCB0byBiZSBzdGF0aWNcclxuICBpZiAoIXJvdXRlLmxhenkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgbGV0IHJvdXRlVG9VcGRhdGUgPSBtYW5pZmVzdFtyb3V0ZS5pZF07XHJcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XHJcbiAgLy8gVXBkYXRlIHRoZSByb3V0ZSBpbiBwbGFjZS4gIFRoaXMgc2hvdWxkIGJlIHNhZmUgYmVjYXVzZSB0aGVyZSdzIG5vIHdheVxyXG4gIC8vIHdlIGNvdWxkIHlldCBiZSBzaXR0aW5nIG9uIHRoaXMgcm91dGUgYXMgd2UgY2FuJ3QgZ2V0IHRoZXJlIHdpdGhvdXRcclxuICAvLyByZXNvbHZpbmcgbGF6eSgpIGZpcnN0LlxyXG4gIC8vXHJcbiAgLy8gVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgSE1SIFwidXBkYXRlXCIgdXNlLWNhc2Ugd2hlcmUgd2UgbWF5IGFjdGl2ZWx5IGJlXHJcbiAgLy8gb24gdGhlIHJvdXRlIGJlaW5nIHVwZGF0ZWQuICBUaGUgbWFpbiBjb25jZXJuIGJvaWxzIGRvd24gdG8gXCJkb2VzIHRoaXNcclxuICAvLyBtdXRhdGlvbiBhZmZlY3QgYW55IG9uZ29pbmcgbmF2aWdhdGlvbnMgb3IgYW55IGN1cnJlbnQgc3RhdGUubWF0Y2hlc1xyXG4gIC8vIHZhbHVlcz9cIi4gIElmIG5vdCwgaXQgc2hvdWxkIGJlIHNhZmUgdG8gdXBkYXRlIGluIHBsYWNlLlxyXG4gIGxldCByb3V0ZVVwZGF0ZXMgPSB7fTtcclxuICBmb3IgKGxldCBsYXp5Um91dGVQcm9wZXJ0eSBpbiBsYXp5Um91dGUpIHtcclxuICAgIGxldCBzdGF0aWNSb3V0ZVZhbHVlID0gcm91dGVUb1VwZGF0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XHJcbiAgICBsZXQgaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkID0gc3RhdGljUm91dGVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcclxuICAgIC8vIG9uIHRoZSByb3V0ZSB1cGRhdGVzXHJcbiAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XHJcbiAgICB3YXJuaW5nKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQsIFwiUm91dGUgXFxcIlwiICsgcm91dGVUb1VwZGF0ZS5pZCArIFwiXFxcIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXFxcIlwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIlxcXCIgXCIgKyBcImRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIFwiICsgKFwiVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXFxcIlwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIlxcXCIgd2lsbCBiZSBpZ25vcmVkLlwiKSk7XHJcbiAgICBpZiAoIWlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCAmJiAhaW1tdXRhYmxlUm91dGVLZXlzLmhhcyhsYXp5Um91dGVQcm9wZXJ0eSkpIHtcclxuICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9IGxhenlSb3V0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIE11dGF0ZSB0aGUgcm91dGUgd2l0aCB0aGUgcHJvdmlkZWQgdXBkYXRlcy4gIERvIHRoaXMgZmlyc3Qgc28gd2UgcGFzc1xyXG4gIC8vIHRoZSB1cGRhdGVkIHZlcnNpb24gdG8gbWFwUm91dGVQcm9wZXJ0aWVzXHJcbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCByb3V0ZVVwZGF0ZXMpO1xyXG4gIC8vIE11dGF0ZSB0aGUgYGhhc0Vycm9yQm91bmRhcnlgIHByb3BlcnR5IG9uIHRoZSByb3V0ZSBiYXNlZCBvbiB0aGUgcm91dGVcclxuICAvLyB1cGRhdGVzIGFuZCByZW1vdmUgdGhlIGBsYXp5YCBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNvbHZlIHRoZSBsYXp5XHJcbiAgLy8gcm91dGUgYWdhaW4uXHJcbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCBfZXh0ZW5kcyh7fSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlVG9VcGRhdGUpLCB7XHJcbiAgICBsYXp5OiB1bmRlZmluZWRcclxuICB9KSk7XHJcbn1cclxuLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgZGF0YVN0cmF0ZWd5YCB3aGljaCBmZXRjaGVzIGFsbCBsb2FkZXJzIGluIHBhcmFsbGVsXHJcbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHREYXRhU3RyYXRlZ3koX3JlZjQpIHtcclxuICBsZXQge1xyXG4gICAgbWF0Y2hlc1xyXG4gIH0gPSBfcmVmNDtcclxuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IG1hdGNoZXMuZmlsdGVyKG0gPT4gbS5zaG91bGRMb2FkKTtcclxuICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKG1hdGNoZXNUb0xvYWQubWFwKG0gPT4gbS5yZXNvbHZlKCkpKTtcclxuICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjYywgcmVzdWx0LCBpKSA9PiBPYmplY3QuYXNzaWduKGFjYywge1xyXG4gICAgW21hdGNoZXNUb0xvYWRbaV0ucm91dGUuaWRdOiByZXN1bHRcclxuICB9KSwge30pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3lJbXBsKGRhdGFTdHJhdGVneUltcGwsIHR5cGUsIHN0YXRlLCByZXF1ZXN0LCBtYXRjaGVzVG9Mb2FkLCBtYXRjaGVzLCBmZXRjaGVyS2V5LCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCByZXF1ZXN0Q29udGV4dCkge1xyXG4gIGxldCBsb2FkUm91dGVEZWZpbml0aW9uc1Byb21pc2VzID0gbWF0Y2hlcy5tYXAobSA9PiBtLnJvdXRlLmxhenkgPyBsb2FkTGF6eVJvdXRlTW9kdWxlKG0ucm91dGUsIG1hcFJvdXRlUHJvcGVydGllcywgbWFuaWZlc3QpIDogdW5kZWZpbmVkKTtcclxuICBsZXQgZHNNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG1hdGNoLCBpKSA9PiB7XHJcbiAgICBsZXQgbG9hZFJvdXRlUHJvbWlzZSA9IGxvYWRSb3V0ZURlZmluaXRpb25zUHJvbWlzZXNbaV07XHJcbiAgICBsZXQgc2hvdWxkTG9hZCA9IG1hdGNoZXNUb0xvYWQuc29tZShtID0+IG0ucm91dGUuaWQgPT09IG1hdGNoLnJvdXRlLmlkKTtcclxuICAgIC8vIGByZXNvbHZlYCBlbmNhcHN1bGF0ZXMgcm91dGUubGF6eSgpLCBleGVjdXRpbmcgdGhlIGxvYWRlci9hY3Rpb24sXHJcbiAgICAvLyBhbmQgbWFwcGluZyByZXR1cm4gdmFsdWVzL3Rocm93biBlcnJvcnMgdG8gYSBgRGF0YVN0cmF0ZWd5UmVzdWx0YC4gIFVzZXJzXHJcbiAgICAvLyBjYW4gcGFzcyBhIGNhbGxiYWNrIHRvIHRha2UgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgZXhlY3V0aW9uXHJcbiAgICAvLyBvZiB0aGUgbG9hZGVyL2FjdGlvblxyXG4gICAgbGV0IHJlc29sdmUgPSBhc3luYyBoYW5kbGVyT3ZlcnJpZGUgPT4ge1xyXG4gICAgICBpZiAoaGFuZGxlck92ZXJyaWRlICYmIHJlcXVlc3QubWV0aG9kID09PSBcIkdFVFwiICYmIChtYXRjaC5yb3V0ZS5sYXp5IHx8IG1hdGNoLnJvdXRlLmxvYWRlcikpIHtcclxuICAgICAgICBzaG91bGRMb2FkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2hvdWxkTG9hZCA/IGNhbGxMb2FkZXJPckFjdGlvbih0eXBlLCByZXF1ZXN0LCBtYXRjaCwgbG9hZFJvdXRlUHJvbWlzZSwgaGFuZGxlck92ZXJyaWRlLCByZXF1ZXN0Q29udGV4dCkgOiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcclxuICAgICAgICByZXN1bHQ6IHVuZGVmaW5lZFxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIG1hdGNoLCB7XHJcbiAgICAgIHNob3VsZExvYWQsXHJcbiAgICAgIHJlc29sdmVcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIC8vIFNlbmQgYWxsIG1hdGNoZXMgaGVyZSB0byBhbGxvdyBmb3IgYSBtaWRkbGV3YXJlLXR5cGUgaW1wbGVtZW50YXRpb24uXHJcbiAgLy8gaGFuZGxlciB3aWxsIGJlIGEgbm8tb3AgZm9yIHVubmVlZGVkIHJvdXRlcyBhbmQgd2UgZmlsdGVyIHRob3NlIHJlc3VsdHNcclxuICAvLyBiYWNrIG91dCBiZWxvdy5cclxuICBsZXQgcmVzdWx0cyA9IGF3YWl0IGRhdGFTdHJhdGVneUltcGwoe1xyXG4gICAgbWF0Y2hlczogZHNNYXRjaGVzLFxyXG4gICAgcmVxdWVzdCxcclxuICAgIHBhcmFtczogbWF0Y2hlc1swXS5wYXJhbXMsXHJcbiAgICBmZXRjaGVyS2V5LFxyXG4gICAgY29udGV4dDogcmVxdWVzdENvbnRleHRcclxuICB9KTtcclxuICAvLyBXYWl0IGZvciBhbGwgcm91dGVzIHRvIGxvYWQgaGVyZSBidXQgJ3N3YWxsb3cgdGhlIGVycm9yIHNpbmNlIHdlIHdhbnRcclxuICAvLyBpdCB0byBidWJibGUgdXAgZnJvbSB0aGUgYGF3YWl0IGxvYWRSb3V0ZVByb21pc2VgIGluIGBjYWxsTG9hZGVyT3JBY3Rpb25gIC1cclxuICAvLyBjYWxsZWQgZnJvbSBgbWF0Y2gucmVzb2x2ZSgpYFxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChsb2FkUm91dGVEZWZpbml0aW9uc1Byb21pc2VzKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBOby1vcFxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0cztcclxufVxyXG4vLyBEZWZhdWx0IGxvZ2ljIGZvciBjYWxsaW5nIGEgbG9hZGVyL2FjdGlvbiBpcyB0aGUgdXNlciBoYXMgbm8gc3BlY2lmaWVkIGEgZGF0YVN0cmF0ZWd5XHJcbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJPckFjdGlvbih0eXBlLCByZXF1ZXN0LCBtYXRjaCwgbG9hZFJvdXRlUHJvbWlzZSwgaGFuZGxlck92ZXJyaWRlLCBzdGF0aWNDb250ZXh0KSB7XHJcbiAgbGV0IHJlc3VsdDtcclxuICBsZXQgb25SZWplY3Q7XHJcbiAgbGV0IHJ1bkhhbmRsZXIgPSBoYW5kbGVyID0+IHtcclxuICAgIC8vIFNldHVwIGEgcHJvbWlzZSB3ZSBjYW4gcmFjZSBhZ2FpbnN0IHNvIHRoYXQgYWJvcnQgc2lnbmFscyBzaG9ydCBjaXJjdWl0XHJcbiAgICBsZXQgcmVqZWN0O1xyXG4gICAgLy8gVGhpcyB3aWxsIG5ldmVyIHJlc29sdmUgc28gc2FmZSB0byB0eXBlIGl0IGFzIFByb21pc2U8RGF0YVN0cmF0ZWd5UmVzdWx0PiB0b1xyXG4gICAgLy8gc2F0aXNmeSB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXHJcbiAgICBsZXQgYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHIpID0+IHJlamVjdCA9IHIpO1xyXG4gICAgb25SZWplY3QgPSAoKSA9PiByZWplY3QoKTtcclxuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XHJcbiAgICBsZXQgYWN0dWFsSGFuZGxlciA9IGN0eCA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIllvdSBjYW5ub3QgY2FsbCB0aGUgaGFuZGxlciBmb3IgYSByb3V0ZSB3aGljaCBkZWZpbmVzIGEgYm9vbGVhbiBcIiArIChcIlxcXCJcIiArIHR5cGUgKyBcIlxcXCIgW3JvdXRlSWQ6IFwiICsgbWF0Y2gucm91dGUuaWQgKyBcIl1cIikpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaGFuZGxlcih7XHJcbiAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcclxuICAgICAgICBjb250ZXh0OiBzdGF0aWNDb250ZXh0XHJcbiAgICAgIH0sIC4uLihjdHggIT09IHVuZGVmaW5lZCA/IFtjdHhdIDogW10pKTtcclxuICAgIH07XHJcbiAgICBsZXQgaGFuZGxlclByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGxldCB2YWwgPSBhd2FpdCAoaGFuZGxlck92ZXJyaWRlID8gaGFuZGxlck92ZXJyaWRlKGN0eCA9PiBhY3R1YWxIYW5kbGVyKGN0eCkpIDogYWN0dWFsSGFuZGxlcigpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdHlwZTogXCJkYXRhXCIsXHJcbiAgICAgICAgICByZXN1bHQ6IHZhbFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxyXG4gICAgICAgICAgcmVzdWx0OiBlXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2hhbmRsZXJQcm9taXNlLCBhYm9ydFByb21pc2VdKTtcclxuICB9O1xyXG4gIHRyeSB7XHJcbiAgICBsZXQgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xyXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHJvdXRlLmxhenkgcHJvbWlzZSwgYXdhaXQgdGhhdCBmaXJzdFxyXG4gICAgaWYgKGxvYWRSb3V0ZVByb21pc2UpIHtcclxuICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAvLyBSdW4gc3RhdGljYWxseSBkZWZpbmVkIGhhbmRsZXIgaW4gcGFyYWxsZWwgd2l0aCBsYXp5KClcclxuICAgICAgICBsZXQgaGFuZGxlckVycm9yO1xyXG4gICAgICAgIGxldCBbdmFsdWVdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIC8vIElmIHRoZSBoYW5kbGVyIHRocm93cywgZG9uJ3QgbGV0IGl0IGltbWVkaWF0ZWx5IGJ1YmJsZSBvdXQsXHJcbiAgICAgICAgLy8gc2luY2Ugd2UgbmVlZCB0byBsZXQgdGhlIGxhenkoKSBleGVjdXRpb24gZmluaXNoIHNvIHdlIGtub3cgaWYgdGhpc1xyXG4gICAgICAgIC8vIHJvdXRlIGhhcyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSB0aGUgZXJyb3JcclxuICAgICAgICBydW5IYW5kbGVyKGhhbmRsZXIpLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgaGFuZGxlckVycm9yID0gZTtcclxuICAgICAgICB9KSwgbG9hZFJvdXRlUHJvbWlzZV0pO1xyXG4gICAgICAgIGlmIChoYW5kbGVyRXJyb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhyb3cgaGFuZGxlckVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBMb2FkIGxhenkgcm91dGUgbW9kdWxlLCB0aGVuIHJ1biBhbnkgcmV0dXJuZWQgaGFuZGxlclxyXG4gICAgICAgIGF3YWl0IGxvYWRSb3V0ZVByb21pc2U7XHJcbiAgICAgICAgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xyXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgICAvLyBIYW5kbGVyIHN0aWxsIHJ1bnMgZXZlbiBpZiB3ZSBnb3QgaW50ZXJydXB0ZWQgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3lcclxuICAgICAgICAgIC8vIHdpdGggdW4tYWJvcnRhYmxlIGJlaGF2aW9yIG9mIGhhbmRsZXIgZXhlY3V0aW9uIG9uIG5vbi1sYXp5IG9yXHJcbiAgICAgICAgICAvLyBwcmV2aW91c2x5LWxhenktbG9hZGVkIHJvdXRlc1xyXG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcclxuICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcclxuICAgICAgICAgIGxldCBwYXRobmFtZSA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2g7XHJcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxyXG4gICAgICAgICAgICBwYXRobmFtZSxcclxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBsYXp5KCkgcm91dGUgaGFzIG5vIGxvYWRlciB0byBydW4uICBTaG9ydCBjaXJjdWl0IGhlcmUgc28gd2UgZG9uJ3RcclxuICAgICAgICAgIC8vIGhpdCB0aGUgaW52YXJpYW50IGJlbG93IHRoYXQgZXJyb3JzIG9uIHJldHVybmluZyB1bmRlZmluZWQuXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXHJcbiAgICAgICAgICAgIHJlc3VsdDogdW5kZWZpbmVkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xyXG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XHJcbiAgICAgIGxldCBwYXRobmFtZSA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2g7XHJcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XHJcbiAgICAgICAgcGF0aG5hbWVcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgaW52YXJpYW50KHJlc3VsdC5yZXN1bHQgIT09IHVuZGVmaW5lZCwgXCJZb3UgZGVmaW5lZCBcIiArICh0eXBlID09PSBcImFjdGlvblwiID8gXCJhbiBhY3Rpb25cIiA6IFwiYSBsb2FkZXJcIikgKyBcIiBmb3Igcm91dGUgXCIgKyAoXCJcXFwiXCIgKyBtYXRjaC5yb3V0ZS5pZCArIFwiXFxcIiBidXQgZGlkbid0IHJldHVybiBhbnl0aGluZyBmcm9tIHlvdXIgYFwiICsgdHlwZSArIFwiYCBcIikgKyBcImZ1bmN0aW9uLiBQbGVhc2UgcmV0dXJuIGEgdmFsdWUgb3IgYG51bGxgLlwiKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBXZSBzaG91bGQgYWxyZWFkeSBiZSBjYXRjaGluZyBhbmQgY29udmVydGluZyBub3JtYWwgaGFuZGxlciBleGVjdXRpb25zIHRvXHJcbiAgICAvLyBEYXRhU3RyYXRlZ3lSZXN1bHRzIGFuZCByZXR1cm5pbmcgdGhlbSwgc28gYW55dGhpbmcgdGhhdCB0aHJvd3MgaGVyZSBpcyBhblxyXG4gICAgLy8gdW5leHBlY3RlZCBlcnJvciB3ZSBzdGlsbCBuZWVkIHRvIHdyYXBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXHJcbiAgICAgIHJlc3VsdDogZVxyXG4gICAgfTtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgaWYgKG9uUmVqZWN0KSB7XHJcbiAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdChkYXRhU3RyYXRlZ3lSZXN1bHQpIHtcclxuICBsZXQge1xyXG4gICAgcmVzdWx0LFxyXG4gICAgdHlwZVxyXG4gIH0gPSBkYXRhU3RyYXRlZ3lSZXN1bHQ7XHJcbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xyXG4gICAgbGV0IGRhdGE7XHJcbiAgICB0cnkge1xyXG4gICAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XHJcbiAgICAgIC8vIENoZWNrIGJldHdlZW4gd29yZCBib3VuZGFyaWVzIGluc3RlYWQgb2Ygc3RhcnRzV2l0aCgpIGR1ZSB0byB0aGUgbGFzdFxyXG4gICAgICAvLyBwYXJhZ3JhcGggb2YgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNmaWVsZC5jb250ZW50LXR5cGVcclxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5ib2R5ID09IG51bGwpIHtcclxuICAgICAgICAgIGRhdGEgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzdWx0Lmpzb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC50ZXh0KCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxyXG4gICAgICAgIGVycm9yOiBlXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXHJcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgZGF0YSksXHJcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcclxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxyXG4gICAgICBkYXRhLFxyXG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxyXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKHR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcclxuICAgIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkpIHtcclxuICAgICAgdmFyIF9yZXN1bHQkaW5pdDI7XHJcbiAgICAgIGlmIChyZXN1bHQuZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgdmFyIF9yZXN1bHQkaW5pdDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcclxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZGF0YSxcclxuICAgICAgICAgIHN0YXR1c0NvZGU6IChfcmVzdWx0JGluaXQgPSByZXN1bHQuaW5pdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQkaW5pdC5zdGF0dXNcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIC8vIENvbnZlcnQgdGhyb3duIGRhdGEoKSB0byBFcnJvclJlc3BvbnNlIGluc3RhbmNlc1xyXG4gICAgICByZXN1bHQgPSBuZXcgRXJyb3JSZXNwb25zZUltcGwoKChfcmVzdWx0JGluaXQyID0gcmVzdWx0LmluaXQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0JGluaXQyLnN0YXR1cykgfHwgNTAwLCB1bmRlZmluZWQsIHJlc3VsdC5kYXRhKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXHJcbiAgICAgIGVycm9yOiByZXN1bHQsXHJcbiAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQuc3RhdHVzIDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAoaXNEZWZlcnJlZERhdGEocmVzdWx0KSkge1xyXG4gICAgdmFyIF9yZXN1bHQkaW5pdDMsIF9yZXN1bHQkaW5pdDQ7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkLFxyXG4gICAgICBkZWZlcnJlZERhdGE6IHJlc3VsdCxcclxuICAgICAgc3RhdHVzQ29kZTogKF9yZXN1bHQkaW5pdDMgPSByZXN1bHQuaW5pdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQkaW5pdDMuc3RhdHVzLFxyXG4gICAgICBoZWFkZXJzOiAoKF9yZXN1bHQkaW5pdDQgPSByZXN1bHQuaW5pdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQkaW5pdDQuaGVhZGVycykgJiYgbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycylcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkpIHtcclxuICAgIHZhciBfcmVzdWx0JGluaXQ1LCBfcmVzdWx0JGluaXQ2O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxyXG4gICAgICBkYXRhOiByZXN1bHQuZGF0YSxcclxuICAgICAgc3RhdHVzQ29kZTogKF9yZXN1bHQkaW5pdDUgPSByZXN1bHQuaW5pdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQkaW5pdDUuc3RhdHVzLFxyXG4gICAgICBoZWFkZXJzOiAoX3Jlc3VsdCRpbml0NiA9IHJlc3VsdC5pbml0KSAhPSBudWxsICYmIF9yZXN1bHQkaW5pdDYuaGVhZGVycyA/IG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpIDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxyXG4gICAgZGF0YTogcmVzdWx0XHJcbiAgfTtcclxufVxyXG4vLyBTdXBwb3J0IHJlbGF0aXZlIHJvdXRpbmcgaW4gaW50ZXJuYWwgcmVkaXJlY3RzXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UsIHJlcXVlc3QsIHJvdXRlSWQsIG1hdGNoZXMsIGJhc2VuYW1lLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCkge1xyXG4gIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XHJcbiAgaW52YXJpYW50KGxvY2F0aW9uLCBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCIpO1xyXG4gIGlmICghQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XHJcbiAgICBsZXQgdHJpbW1lZE1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKTtcclxuICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8obmV3IFVSTChyZXF1ZXN0LnVybCksIHRyaW1tZWRNYXRjaGVzLCBiYXNlbmFtZSwgdHJ1ZSwgbG9jYXRpb24sIHY3X3JlbGF0aXZlU3BsYXRQYXRoKTtcclxuICAgIHJlc3BvbnNlLmhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgbG9jYXRpb24pO1xyXG4gIH1cclxuICByZXR1cm4gcmVzcG9uc2U7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbiwgY3VycmVudFVybCwgYmFzZW5hbWUpIHtcclxuICBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XHJcbiAgICAvLyBTdHJpcCBvZmYgdGhlIHByb3RvY29sK29yaWdpbiBmb3Igc2FtZS1vcmlnaW4gKyBzYW1lLWJhc2VuYW1lIGFic29sdXRlIHJlZGlyZWN0c1xyXG4gICAgbGV0IG5vcm1hbGl6ZWRMb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgbGV0IHVybCA9IG5vcm1hbGl6ZWRMb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBub3JtYWxpemVkTG9jYXRpb24pIDogbmV3IFVSTChub3JtYWxpemVkTG9jYXRpb24pO1xyXG4gICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xyXG4gICAgaWYgKHVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIGlzU2FtZUJhc2VuYW1lKSB7XHJcbiAgICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBsb2NhdGlvbjtcclxufVxyXG4vLyBVdGlsaXR5IG1ldGhvZCBmb3IgY3JlYXRpbmcgdGhlIFJlcXVlc3QgaW5zdGFuY2VzIGZvciBsb2FkZXJzL2FjdGlvbnMgZHVyaW5nXHJcbi8vIGNsaWVudC1zaWRlIG5hdmlnYXRpb25zIGFuZCBmZXRjaGVzLiAgRHVyaW5nIFNTUiB3ZSB3aWxsIGFsd2F5cyBoYXZlIGFcclxuLy8gUmVxdWVzdCBpbnN0YW5jZSBmcm9tIHRoZSBzdGF0aWMgaGFuZGxlciAocXVlcnkvcXVlcnlSb3V0ZSlcclxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaGlzdG9yeSwgbG9jYXRpb24sIHNpZ25hbCwgc3VibWlzc2lvbikge1xyXG4gIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdHJpcEhhc2hGcm9tUGF0aChsb2NhdGlvbikpLnRvU3RyaW5nKCk7XHJcbiAgbGV0IGluaXQgPSB7XHJcbiAgICBzaWduYWxcclxuICB9O1xyXG4gIGlmIChzdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xyXG4gICAgbGV0IHtcclxuICAgICAgZm9ybU1ldGhvZCxcclxuICAgICAgZm9ybUVuY1R5cGVcclxuICAgIH0gPSBzdWJtaXNzaW9uO1xyXG4gICAgLy8gRGlkbid0IHRoaW5rIHdlIG5lZWRlZCB0aGlzIGJ1dCBpdCB0dXJucyBvdXQgdW5saWtlIG90aGVyIG1ldGhvZHMsIHBhdGNoXHJcbiAgICAvLyB3b24ndCBiZSBwcm9wZXJseSBub3JtYWxpemVkIHRvIHVwcGVyY2FzZSBhbmQgcmVzdWx0cyBpbiBhIDQwNSBlcnJvci5cclxuICAgIC8vIFNlZTogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kXHJcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcclxuICAgIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcclxuICAgICAgaW5pdC5oZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xyXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGZvcm1FbmNUeXBlXHJcbiAgICAgIH0pO1xyXG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xyXG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcclxuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXHJcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24udGV4dDtcclxuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgJiYgc3VibWlzc2lvbi5mb3JtRGF0YSkge1xyXG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcclxuICAgICAgaW5pdC5ib2R5ID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoc3VibWlzc2lvbi5mb3JtRGF0YSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcclxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XHJcbn1cclxuZnVuY3Rpb24gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoZm9ybURhdGEpIHtcclxuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xyXG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcclxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2NvbnZlcnRpbmctYW4tZW50cnktbGlzdC10by1hLWxpc3Qtb2YtbmFtZS12YWx1ZS1wYWlyc1xyXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XHJcbiAgfVxyXG4gIHJldHVybiBzZWFyY2hQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKSB7XHJcbiAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XHJcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcclxuICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIGZvcm1EYXRhO1xyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEobWF0Y2hlcywgcmVzdWx0cywgcGVuZGluZ0FjdGlvblJlc3VsdCwgYWN0aXZlRGVmZXJyZWRzLCBza2lwTG9hZGVyRXJyb3JCdWJibGluZykge1xyXG4gIC8vIEZpbGwgaW4gbG9hZGVyRGF0YS9lcnJvcnMgZnJvbSBvdXIgbG9hZGVyc1xyXG4gIGxldCBsb2FkZXJEYXRhID0ge307XHJcbiAgbGV0IGVycm9ycyA9IG51bGw7XHJcbiAgbGV0IHN0YXR1c0NvZGU7XHJcbiAgbGV0IGZvdW5kRXJyb3IgPSBmYWxzZTtcclxuICBsZXQgbG9hZGVySGVhZGVycyA9IHt9O1xyXG4gIGxldCBwZW5kaW5nRXJyb3IgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yIDogdW5kZWZpbmVkO1xyXG4gIC8vIFByb2Nlc3MgbG9hZGVyIHJlc3VsdHMgaW50byBzdGF0ZS5sb2FkZXJEYXRhL3N0YXRlLmVycm9yc1xyXG4gIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XHJcbiAgICBpZiAoIShtYXRjaC5yb3V0ZS5pZCBpbiByZXN1bHRzKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcclxuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2lkXTtcclxuICAgIGludmFyaWFudCghaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpLCBcIkNhbm5vdCBoYW5kbGUgcmVkaXJlY3QgcmVzdWx0cyBpbiBwcm9jZXNzTG9hZGVyRGF0YVwiKTtcclxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcclxuICAgICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xyXG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhY3Rpb24gZXJyb3IsIHdlIHJlcG9ydCBpdCBhdCB0aGUgaGlnaGVzdC1yb3V0ZVxyXG4gICAgICAvLyB0aGF0IHRocm93cyBhIGxvYWRlciBlcnJvciwgYW5kIHRoZW4gY2xlYXIgaXQgb3V0IHRvIGluZGljYXRlIHRoYXRcclxuICAgICAgLy8gaXQgd2FzIGNvbnN1bWVkXHJcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGVycm9yID0gcGVuZGluZ0Vycm9yO1xyXG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBlcnJvcnMgPSBlcnJvcnMgfHwge307XHJcbiAgICAgIGlmIChza2lwTG9hZGVyRXJyb3JCdWJibGluZykge1xyXG4gICAgICAgIGVycm9yc1tpZF0gPSBlcnJvcjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBMb29rIHVwd2FyZHMgZnJvbSB0aGUgbWF0Y2hlZCByb3V0ZSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZXJyb3JcclxuICAgICAgICAvLyBib3VuZGFyeSwgZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaC4gIFByZWZlciBoaWdoZXIgZXJyb3IgdmFsdWVzXHJcbiAgICAgICAgLy8gaWYgbG93ZXIgZXJyb3JzIGJ1YmJsZSB0byB0aGUgc2FtZSBib3VuZGFyeVxyXG4gICAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XHJcbiAgICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gQ2xlYXIgb3VyIGFueSBwcmlvciBsb2FkZXJEYXRhIGZvciB0aGUgdGhyb3dpbmcgcm91dGVcclxuICAgICAgbG9hZGVyRGF0YVtpZF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIE9uY2Ugd2UgZmluZCBvdXIgZmlyc3QgKGhpZ2hlc3QpIGVycm9yLCB3ZSBzZXQgdGhlIHN0YXR1cyBjb2RlIGFuZFxyXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXHJcbiAgICAgIGlmICghZm91bmRFcnJvcikge1xyXG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcclxuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XHJcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLnNldChpZCwgcmVzdWx0LmRlZmVycmVkRGF0YSk7XHJcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGE7XHJcbiAgICAgICAgLy8gRXJyb3Igc3RhdHVzIGNvZGVzIGFsd2F5cyBvdmVycmlkZSBzdWNjZXNzIHN0YXR1cyBjb2RlcywgYnV0IGlmIGFsbFxyXG4gICAgICAgIC8vIGxvYWRlcnMgYXJlIHN1Y2Nlc3NmdWwgd2UgdGFrZSB0aGUgZGVlcGVzdCBzdGF0dXMgY29kZS5cclxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCAmJiByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmICFmb3VuZEVycm9yKSB7XHJcbiAgICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xyXG4gICAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGF0YTtcclxuICAgICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXHJcbiAgICAgICAgLy8gbG9hZGVycyBhcmUgc3VjY2Vzc2Z1bCB3ZSB0YWtlIHRoZSBkZWVwZXN0IHN0YXR1cyBjb2RlLlxyXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzQ29kZSAmJiByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmICFmb3VuZEVycm9yKSB7XHJcbiAgICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xyXG4gICAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICAvLyBJZiB3ZSBkaWRuJ3QgY29uc3VtZSB0aGUgcGVuZGluZyBhY3Rpb24gZXJyb3IgKGkuZS4sIGFsbCBsb2FkZXJzXHJcbiAgLy8gcmVzb2x2ZWQpLCB0aGVuIGNvbnN1bWUgaXQgaGVyZS4gIEFsc28gY2xlYXIgb3V0IGFueSBsb2FkZXJEYXRhIGZvciB0aGVcclxuICAvLyB0aHJvd2luZyByb3V0ZVxyXG4gIGlmIChwZW5kaW5nRXJyb3IgIT09IHVuZGVmaW5lZCAmJiBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XHJcbiAgICBlcnJvcnMgPSB7XHJcbiAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0Vycm9yXHJcbiAgICB9O1xyXG4gICAgbG9hZGVyRGF0YVtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXSA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGxvYWRlckRhdGEsXHJcbiAgICBlcnJvcnMsXHJcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIHx8IDIwMCxcclxuICAgIGxvYWRlckhlYWRlcnNcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCByZXN1bHRzLCBwZW5kaW5nQWN0aW9uUmVzdWx0LCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMsIGFjdGl2ZURlZmVycmVkcykge1xyXG4gIGxldCB7XHJcbiAgICBsb2FkZXJEYXRhLFxyXG4gICAgZXJyb3JzXHJcbiAgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEobWF0Y2hlcywgcmVzdWx0cywgcGVuZGluZ0FjdGlvblJlc3VsdCwgYWN0aXZlRGVmZXJyZWRzLCBmYWxzZSAvLyBUaGlzIG1ldGhvZCBpcyBvbmx5IGNhbGxlZCBjbGllbnQgc2lkZSBzbyB3ZSBhbHdheXMgd2FudCB0byBidWJibGVcclxuICApO1xyXG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcclxuICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIGtleSxcclxuICAgICAgbWF0Y2gsXHJcbiAgICAgIGNvbnRyb2xsZXJcclxuICAgIH0gPSByZjtcclxuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyUmVzdWx0c1trZXldO1xyXG4gICAgaW52YXJpYW50KHJlc3VsdCwgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiKTtcclxuICAgIC8vIFByb2Nlc3MgZmV0Y2hlciBub24tcmVkaXJlY3QgZXJyb3JzXHJcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIGFib3J0ZWQgZmV0Y2hlcnNcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcclxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaC5yb3V0ZS5pZCk7XHJcbiAgICAgIGlmICghKGVycm9ycyAmJiBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0pKSB7XHJcbiAgICAgICAgZXJyb3JzID0gX2V4dGVuZHMoe30sIGVycm9ycywge1xyXG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcclxuICAgIH0gZWxzZSBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XHJcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgcmVkaXJlY3RzIHNob3VsZCBnZXQgcHJvY2Vzc2VkIGFib3ZlLCBidXQgd2VcclxuICAgICAgLy8ga2VlcCB0aGlzIHRvIHR5cGUgbmFycm93IHRvIGEgc3VjY2VzcyByZXN1bHQgaW4gdGhlIGVsc2VcclxuICAgICAgaW52YXJpYW50KGZhbHNlLCBcIlVuaGFuZGxlZCBmZXRjaGVyIHJldmFsaWRhdGlvbiByZWRpcmVjdFwiKTtcclxuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XHJcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgZGVmZXJyZWQgZGF0YSBzaG91bGQgYmUgYXdhaXRlZCBmb3IgZmV0Y2hlcnNcclxuICAgICAgLy8gaW4gcmVzb2x2ZURlZmVycmVkUmVzdWx0c1xyXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKTtcclxuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiB7XHJcbiAgICBsb2FkZXJEYXRhLFxyXG4gICAgZXJyb3JzXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEobG9hZGVyRGF0YSwgbmV3TG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSB7XHJcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSBfZXh0ZW5kcyh7fSwgbmV3TG9hZGVyRGF0YSk7XHJcbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xyXG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XHJcbiAgICBpZiAobmV3TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcclxuICAgICAgaWYgKG5ld0xvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IG5ld0xvYWRlckRhdGFbaWRdO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGxvYWRlckRhdGFbaWRdICE9PSB1bmRlZmluZWQgJiYgbWF0Y2gucm91dGUubG9hZGVyKSB7XHJcbiAgICAgIC8vIFByZXNlcnZlIGV4aXN0aW5nIGtleXMgbm90IGluY2x1ZGVkIGluIG5ld0xvYWRlckRhdGEgYW5kIHdoZXJlIGEgbG9hZGVyXHJcbiAgICAgIC8vIHdhc24ndCByZW1vdmVkIGJ5IEhNUlxyXG4gICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IGxvYWRlckRhdGFbaWRdO1xyXG4gICAgfVxyXG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XHJcbiAgICAgIC8vIERvbid0IGtlZXAgYW55IGxvYWRlciBkYXRhIGJlbG93IHRoZSBib3VuZGFyeVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XHJcbiAgaWYgKCFwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG4gIHJldHVybiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8ge1xyXG4gICAgLy8gQ2xlYXIgb3V0IHByaW9yIGFjdGlvbkRhdGEgb24gZXJyb3JzXHJcbiAgICBhY3Rpb25EYXRhOiB7fVxyXG4gIH0gOiB7XHJcbiAgICBhY3Rpb25EYXRhOiB7XHJcbiAgICAgIFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5kYXRhXHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4vLyBGaW5kIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LCBsb29raW5nIHVwd2FyZHMgZnJvbSB0aGUgbGVhZiByb3V0ZSAob3IgdGhlXHJcbi8vIHJvdXRlIHNwZWNpZmllZCBieSByb3V0ZUlkKSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZXJyb3IgYm91bmRhcnksXHJcbi8vIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcclxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCByb3V0ZUlkKSB7XHJcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWQgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKSA6IFsuLi5tYXRjaGVzXTtcclxuICByZXR1cm4gZWxpZ2libGVNYXRjaGVzLnJldmVyc2UoKS5maW5kKG0gPT4gbS5yb3V0ZS5oYXNFcnJvckJvdW5kYXJ5ID09PSB0cnVlKSB8fCBtYXRjaGVzWzBdO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzKSB7XHJcbiAgLy8gUHJlZmVyIGEgcm9vdCBsYXlvdXQgcm91dGUgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHNoaW0gaW4gYSByb3V0ZSBvYmplY3RcclxuICBsZXQgcm91dGUgPSByb3V0ZXMubGVuZ3RoID09PSAxID8gcm91dGVzWzBdIDogcm91dGVzLmZpbmQociA9PiByLmluZGV4IHx8ICFyLnBhdGggfHwgci5wYXRoID09PSBcIi9cIikgfHwge1xyXG4gICAgaWQ6IFwiX19zaGltLWVycm9yLXJvdXRlX19cIlxyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG1hdGNoZXM6IFt7XHJcbiAgICAgIHBhcmFtczoge30sXHJcbiAgICAgIHBhdGhuYW1lOiBcIlwiLFxyXG4gICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXHJcbiAgICAgIHJvdXRlXHJcbiAgICB9XSxcclxuICAgIHJvdXRlXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKHN0YXR1cywgX3RlbXA1KSB7XHJcbiAgbGV0IHtcclxuICAgIHBhdGhuYW1lLFxyXG4gICAgcm91dGVJZCxcclxuICAgIG1ldGhvZCxcclxuICAgIHR5cGUsXHJcbiAgICBtZXNzYWdlXHJcbiAgfSA9IF90ZW1wNSA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDU7XHJcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XHJcbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiVW5rbm93biBAcmVtaXgtcnVuL3JvdXRlciBlcnJvclwiO1xyXG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xyXG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcclxuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xyXG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIllvdSBtYWRlIGEgXCIgKyBtZXRob2QgKyBcIiByZXF1ZXN0IHRvIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiIGJ1dCBcIiArIChcImRpZCBub3QgcHJvdmlkZSBhIGBsb2FkZXJgIGZvciByb3V0ZSBcXFwiXCIgKyByb3V0ZUlkICsgXCJcXFwiLCBcIikgKyBcInNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuXCI7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGVmZXItYWN0aW9uXCIpIHtcclxuICAgICAgZXJyb3JNZXNzYWdlID0gXCJkZWZlcigpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWN0aW9uc1wiO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludmFsaWQtYm9keVwiKSB7XHJcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5hYmxlIHRvIGVuY29kZSBzdWJtaXNzaW9uIGJvZHlcIjtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XHJcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcclxuICAgIGVycm9yTWVzc2FnZSA9IFwiUm91dGUgXFxcIlwiICsgcm91dGVJZCArIFwiXFxcIiBkb2VzIG5vdCBtYXRjaCBVUkwgXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCJcIjtcclxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcclxuICAgIGVycm9yTWVzc2FnZSA9IFwiTm8gcm91dGUgbWF0Y2hlcyBVUkwgXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCJcIjtcclxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XHJcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcclxuICAgIGlmIChtZXRob2QgJiYgcGF0aG5hbWUgJiYgcm91dGVJZCkge1xyXG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIllvdSBtYWRlIGEgXCIgKyBtZXRob2QudG9VcHBlckNhc2UoKSArIFwiIHJlcXVlc3QgdG8gXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCIgYnV0IFwiICsgKFwiZGlkIG5vdCBwcm92aWRlIGFuIGBhY3Rpb25gIGZvciByb3V0ZSBcXFwiXCIgKyByb3V0ZUlkICsgXCJcXFwiLCBcIikgKyBcInNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuXCI7XHJcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xyXG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIkludmFsaWQgcmVxdWVzdCBtZXRob2QgXFxcIlwiICsgbWV0aG9kLnRvVXBwZXJDYXNlKCkgKyBcIlxcXCJcIjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG5ldyBFcnJvclJlc3BvbnNlSW1wbChzdGF0dXMgfHwgNTAwLCBzdGF0dXNUZXh0LCBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgdHJ1ZSk7XHJcbn1cclxuLy8gRmluZCBhbnkgcmV0dXJuZWQgcmVkaXJlY3QgZXJyb3JzLCBzdGFydGluZyBmcm9tIHRoZSBsb3dlc3QgbWF0Y2hcclxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KHJlc3VsdHMpIHtcclxuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHJlc3VsdHMpO1xyXG4gIGZvciAobGV0IGkgPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBsZXQgW2tleSwgcmVzdWx0XSA9IGVudHJpZXNbaV07XHJcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAga2V5LFxyXG4gICAgICAgIHJlc3VsdFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKSB7XHJcbiAgbGV0IHBhcnNlZFBhdGggPSB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChwYXRoKSA6IHBhdGg7XHJcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoX2V4dGVuZHMoe30sIHBhcnNlZFBhdGgsIHtcclxuICAgIGhhc2g6IFwiXCJcclxuICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShhLCBiKSB7XHJcbiAgaWYgKGEucGF0aG5hbWUgIT09IGIucGF0aG5hbWUgfHwgYS5zZWFyY2ggIT09IGIuc2VhcmNoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChhLmhhc2ggPT09IFwiXCIpIHtcclxuICAgIC8vIC9wYWdlIC0+IC9wYWdlI2hhc2hcclxuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XHJcbiAgfSBlbHNlIGlmIChhLmhhc2ggPT09IGIuaGFzaCkge1xyXG4gICAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZSNoYXNoXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGVsc2UgaWYgKGIuaGFzaCAhPT0gXCJcIikge1xyXG4gICAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZSNvdGhlclxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8vIElmIHRoZSBoYXNoIGlzIHJlbW92ZWQgdGhlIGJyb3dzZXIgd2lsbCByZS1wZXJmb3JtIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyXHJcbiAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc0RhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpIHtcclxuICByZXR1cm4gcmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiByZXN1bHQgJiYgXCJyZXN1bHRcIiBpbiByZXN1bHQgJiYgKHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmRhdGEgfHwgcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHRSZXN1bHQocmVzdWx0KSB7XHJcbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0LnJlc3VsdCkgJiYgcmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMocmVzdWx0LnJlc3VsdC5zdGF0dXMpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSB7XHJcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmRlZmVycmVkO1xyXG59XHJcbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XHJcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSB7XHJcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBSZXN1bHRUeXBlLnJlZGlyZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGlzRGF0YVdpdGhSZXNwb25zZUluaXQodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwgJiYgXCJ0eXBlXCIgaW4gdmFsdWUgJiYgXCJkYXRhXCIgaW4gdmFsdWUgJiYgXCJpbml0XCIgaW4gdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJEYXRhV2l0aFJlc3BvbnNlSW5pdFwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzRGVmZXJyZWREYXRhKHZhbHVlKSB7XHJcbiAgbGV0IGRlZmVycmVkID0gdmFsdWU7XHJcbiAgcmV0dXJuIGRlZmVycmVkICYmIHR5cGVvZiBkZWZlcnJlZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRlZmVycmVkLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZlcnJlZC5yZXNvbHZlRGF0YSA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVzcG9uc2UodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQpIHtcclxuICBpZiAoIWlzUmVzcG9uc2UocmVzdWx0KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcclxuICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcclxuICByZXR1cm4gc3RhdHVzID49IDMwMCAmJiBzdGF0dXMgPD0gMzk5ICYmIGxvY2F0aW9uICE9IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZE1ldGhvZChtZXRob2QpIHtcclxuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzTXV0YXRpb25NZXRob2QobWV0aG9kKSB7XHJcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZU5hdmlnYXRpb25EZWZlcnJlZFJlc3VsdHMobWF0Y2hlcywgcmVzdWx0cywgc2lnbmFsLCBjdXJyZW50TWF0Y2hlcywgY3VycmVudExvYWRlckRhdGEpIHtcclxuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHJlc3VsdHMpO1xyXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgbGV0IFtyb3V0ZUlkLCByZXN1bHRdID0gZW50cmllc1tpbmRleF07XHJcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzLmZpbmQobSA9PiAobSA9PSBudWxsID8gdm9pZCAwIDogbS5yb3V0ZS5pZCkgPT09IHJvdXRlSWQpO1xyXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoLCB0aGVuIHdlIGNhbiBoYXZlIGEgZGVmZXJyZWQgcmVzdWx0IHRvIGRvXHJcbiAgICAvLyBhbnl0aGluZyB3aXRoLiAgVGhpcyBpcyBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXJzIHdoZXJlIHRoZSByb3V0ZSB3YXNcclxuICAgIC8vIHJlbW92ZWQgZHVyaW5nIEhNUlxyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGxldCBjdXJyZW50TWF0Y2ggPSBjdXJyZW50TWF0Y2hlcy5maW5kKG0gPT4gbS5yb3V0ZS5pZCA9PT0gbWF0Y2gucm91dGUuaWQpO1xyXG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID0gY3VycmVudE1hdGNoICE9IG51bGwgJiYgIWlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSAmJiAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSAmJiBpc1JldmFsaWRhdGluZ0xvYWRlcikge1xyXG4gICAgICAvLyBOb3RlOiB3ZSBkbyBub3QgaGF2ZSB0byB0b3VjaCBhY3RpdmVEZWZlcnJlZHMgaGVyZSBzaW5jZSB3ZSByYWNlIHRoZW1cclxuICAgICAgLy8gYWdhaW5zdCB0aGUgc2lnbmFsIGluIHJlc29sdmVEZWZlcnJlZERhdGEgYW5kIHRoZXknbGwgZ2V0IGFib3J0ZWRcclxuICAgICAgLy8gdGhlcmUgaWYgbmVlZGVkXHJcbiAgICAgIGF3YWl0IHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBzaWduYWwsIGZhbHNlKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmVzdWx0c1tyb3V0ZUlkXSA9IHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRmV0Y2hlckRlZmVycmVkUmVzdWx0cyhtYXRjaGVzLCByZXN1bHRzLCByZXZhbGlkYXRpbmdGZXRjaGVycykge1xyXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgIGxldCB7XHJcbiAgICAgIGtleSxcclxuICAgICAgcm91dGVJZCxcclxuICAgICAgY29udHJvbGxlclxyXG4gICAgfSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcclxuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2tleV07XHJcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzLmZpbmQobSA9PiAobSA9PSBudWxsID8gdm9pZCAwIDogbS5yb3V0ZS5pZCkgPT09IHJvdXRlSWQpO1xyXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoLCB0aGVuIHdlIGNhbiBoYXZlIGEgZGVmZXJyZWQgcmVzdWx0IHRvIGRvXHJcbiAgICAvLyBhbnl0aGluZyB3aXRoLiAgVGhpcyBpcyBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXJzIHdoZXJlIHRoZSByb3V0ZSB3YXNcclxuICAgIC8vIHJlbW92ZWQgZHVyaW5nIEhNUlxyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcclxuICAgICAgLy8gTm90ZTogd2UgZG8gbm90IGhhdmUgdG8gdG91Y2ggYWN0aXZlRGVmZXJyZWRzIGhlcmUgc2luY2Ugd2UgcmFjZSB0aGVtXHJcbiAgICAgIC8vIGFnYWluc3QgdGhlIHNpZ25hbCBpbiByZXNvbHZlRGVmZXJyZWREYXRhIGFuZCB0aGV5J2xsIGdldCBhYm9ydGVkXHJcbiAgICAgIC8vIHRoZXJlIGlmIG5lZWRlZFxyXG4gICAgICBpbnZhcmlhbnQoY29udHJvbGxlciwgXCJFeHBlY3RlZCBhbiBBYm9ydENvbnRyb2xsZXIgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVyIGRlZmVycmVkIHJlc3VsdFwiKTtcclxuICAgICAgYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGNvbnRyb2xsZXIuc2lnbmFsLCB0cnVlKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBzaWduYWwsIHVud3JhcCkge1xyXG4gIGlmICh1bndyYXAgPT09IHZvaWQgMCkge1xyXG4gICAgdW53cmFwID0gZmFsc2U7XHJcbiAgfVxyXG4gIGxldCBhYm9ydGVkID0gYXdhaXQgcmVzdWx0LmRlZmVycmVkRGF0YS5yZXNvbHZlRGF0YShzaWduYWwpO1xyXG4gIGlmIChhYm9ydGVkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICh1bndyYXApIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxyXG4gICAgICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEudW53cmFwcGVkRGF0YVxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBIYW5kbGUgYW55IFRyYWNrZWRQcm9taXNlLl9lcnJvciB2YWx1ZXMgZW5jb3VudGVyZWQgd2hpbGUgdW53cmFwcGluZ1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXHJcbiAgICAgICAgZXJyb3I6IGVcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcclxuICAgIGRhdGE6IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCkge1xyXG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkuZ2V0QWxsKFwiaW5kZXhcIikuc29tZSh2ID0+IHYgPT09IFwiXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSB7XHJcbiAgbGV0IHNlYXJjaCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbikuc2VhcmNoIDogbG9jYXRpb24uc2VhcmNoO1xyXG4gIGlmIChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKSkge1xyXG4gICAgLy8gUmV0dXJuIHRoZSBsZWFmIGluZGV4IHJvdXRlIHdoZW4gaW5kZXggaXMgcHJlc2VudFxyXG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcclxuICB9XHJcbiAgLy8gT3RoZXJ3aXNlIGdyYWIgdGhlIGRlZXBlc3QgXCJwYXRoIGNvbnRyaWJ1dGluZ1wiIG1hdGNoIChpZ25vcmluZyBpbmRleCBhbmRcclxuICAvLyBwYXRobGVzcyBsYXlvdXQgcm91dGVzKVxyXG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xyXG4gIHJldHVybiBwYXRoTWF0Y2hlc1twYXRoTWF0Y2hlcy5sZW5ndGggLSAxXTtcclxufVxyXG5mdW5jdGlvbiBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obmF2aWdhdGlvbikge1xyXG4gIGxldCB7XHJcbiAgICBmb3JtTWV0aG9kLFxyXG4gICAgZm9ybUFjdGlvbixcclxuICAgIGZvcm1FbmNUeXBlLFxyXG4gICAgdGV4dCxcclxuICAgIGZvcm1EYXRhLFxyXG4gICAganNvblxyXG4gIH0gPSBuYXZpZ2F0aW9uO1xyXG4gIGlmICghZm9ybU1ldGhvZCB8fCAhZm9ybUFjdGlvbiB8fCAhZm9ybUVuY1R5cGUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZm9ybU1ldGhvZCxcclxuICAgICAgZm9ybUFjdGlvbixcclxuICAgICAgZm9ybUVuY1R5cGUsXHJcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXHJcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcclxuICAgICAgdGV4dFxyXG4gICAgfTtcclxuICB9IGVsc2UgaWYgKGZvcm1EYXRhICE9IG51bGwpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGZvcm1NZXRob2QsXHJcbiAgICAgIGZvcm1BY3Rpb24sXHJcbiAgICAgIGZvcm1FbmNUeXBlLFxyXG4gICAgICBmb3JtRGF0YSxcclxuICAgICAganNvbjogdW5kZWZpbmVkLFxyXG4gICAgICB0ZXh0OiB1bmRlZmluZWRcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGZvcm1NZXRob2QsXHJcbiAgICAgIGZvcm1BY3Rpb24sXHJcbiAgICAgIGZvcm1FbmNUeXBlLFxyXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxyXG4gICAgICBqc29uLFxyXG4gICAgICB0ZXh0OiB1bmRlZmluZWRcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XHJcbiAgaWYgKHN1Ym1pc3Npb24pIHtcclxuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xyXG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXHJcbiAgICAgIGxvY2F0aW9uLFxyXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXHJcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcclxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXHJcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxyXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXHJcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxyXG4gICAgfTtcclxuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHtcclxuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxyXG4gICAgICBsb2NhdGlvbixcclxuICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxyXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXHJcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXHJcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXHJcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcclxuICAgICAgdGV4dDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG5hdmlnYXRpb247XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XHJcbiAgbGV0IG5hdmlnYXRpb24gPSB7XHJcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXHJcbiAgICBsb2NhdGlvbixcclxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcclxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcclxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxyXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXHJcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXHJcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcclxuICB9O1xyXG4gIHJldHVybiBuYXZpZ2F0aW9uO1xyXG59XHJcbmZ1bmN0aW9uIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGRhdGEpIHtcclxuICBpZiAoc3VibWlzc2lvbikge1xyXG4gICAgbGV0IGZldGNoZXIgPSB7XHJcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcclxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxyXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXHJcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxyXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcclxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxyXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXHJcbiAgICAgIGRhdGFcclxuICAgIH07XHJcbiAgICByZXR1cm4gZmV0Y2hlcjtcclxuICB9IGVsc2Uge1xyXG4gICAgbGV0IGZldGNoZXIgPSB7XHJcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcclxuICAgICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxyXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXHJcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXHJcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXHJcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcclxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxyXG4gICAgICBkYXRhXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZldGNoZXI7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlcikge1xyXG4gIGxldCBmZXRjaGVyID0ge1xyXG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxyXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxyXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxyXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXHJcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcclxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcclxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcclxuICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkXHJcbiAgfTtcclxuICByZXR1cm4gZmV0Y2hlcjtcclxufVxyXG5mdW5jdGlvbiBnZXREb25lRmV0Y2hlcihkYXRhKSB7XHJcbiAgbGV0IGZldGNoZXIgPSB7XHJcbiAgICBzdGF0ZTogXCJpZGxlXCIsXHJcbiAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXHJcbiAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXHJcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxyXG4gICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcclxuICAgIGpzb246IHVuZGVmaW5lZCxcclxuICAgIHRleHQ6IHVuZGVmaW5lZCxcclxuICAgIGRhdGFcclxuICB9O1xyXG4gIHJldHVybiBmZXRjaGVyO1xyXG59XHJcbmZ1bmN0aW9uIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcclxuICB0cnkge1xyXG4gICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBfd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oVFJBTlNJVElPTlNfU1RPUkFHRV9LRVkpO1xyXG4gICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcclxuICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xyXG4gICAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbiB8fCB7fSkpIHtcclxuICAgICAgICBpZiAodiAmJiBBcnJheS5pc0FycmF5KHYpKSB7XHJcbiAgICAgICAgICB0cmFuc2l0aW9ucy5zZXQoaywgbmV3IFNldCh2IHx8IFtdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKF93aW5kb3csIHRyYW5zaXRpb25zKSB7XHJcbiAgaWYgKHRyYW5zaXRpb25zLnNpemUgPiAwKSB7XHJcbiAgICBsZXQganNvbiA9IHt9O1xyXG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHRyYW5zaXRpb25zKSB7XHJcbiAgICAgIGpzb25ba10gPSBbLi4udl07XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBfd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oVFJBTlNJVElPTlNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGpzb24pKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiRmFpbGVkIHRvIHNhdmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlIChcIiArIGVycm9yICsgXCIpLlwiKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuLy8jZW5kcmVnaW9uXHJcblxyXG5leHBvcnQgeyBBYm9ydGVkRGVmZXJyZWRFcnJvciwgQWN0aW9uLCBJRExFX0JMT0NLRVIsIElETEVfRkVUQ0hFUiwgSURMRV9OQVZJR0FUSU9OLCBVTlNBRkVfREVGRVJSRURfU1lNQk9MLCBEZWZlcnJlZERhdGEgYXMgVU5TQUZFX0RlZmVycmVkRGF0YSwgRXJyb3JSZXNwb25zZUltcGwgYXMgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsLCBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCBhcyBVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gsIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMgYXMgVU5TQUZFX2NvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsIGRlY29kZVBhdGggYXMgVU5TQUZFX2RlY29kZVBhdGgsIGdldFJlc29sdmVUb01hdGNoZXMgYXMgVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMsIGludmFyaWFudCBhcyBVTlNBRkVfaW52YXJpYW50LCB3YXJuaW5nIGFzIFVOU0FGRV93YXJuaW5nLCBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZVBhdGgsIGNyZWF0ZVJvdXRlciwgY3JlYXRlU3RhdGljSGFuZGxlciwgZGF0YSwgZGVmZXIsIGdlbmVyYXRlUGF0aCwgZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciwgZ2V0VG9QYXRobmFtZSwgaXNEYXRhV2l0aFJlc3BvbnNlSW5pdCwgaXNEZWZlcnJlZERhdGEsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBqb2luUGF0aHMsIGpzb24sIG1hdGNoUGF0aCwgbWF0Y2hSb3V0ZXMsIG5vcm1hbGl6ZVBhdGhuYW1lLCBwYXJzZVBhdGgsIHJlZGlyZWN0LCByZWRpcmVjdERvY3VtZW50LCByZXBsYWNlLCByZXNvbHZlUGF0aCwgcmVzb2x2ZVRvLCBzdHJpcEJhc2VuYW1lIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@remix-run/router/dist/router.js\n"));

/***/ }),

/***/ "./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.NavigationType),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_ErrorResponseImpl),\n/* harmony export */   UNSAFE_FetchersContext: () => (/* binding */ FetchersContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_ViewTransitionContext: () => (/* binding */ ViewTransitionContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_useRouteId),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.renderMatches),\n/* harmony export */   replace: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.replace),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useBlocker),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit),\n/* harmony export */   useViewTransitionState: () => (/* binding */ useViewTransitionState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router */ \"./node_modules/react-router/dist/index.js\");\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @remix-run/router */ \"./node_modules/@remix-run/router/dist/router.js\");\n/**\r\n * React Router DOM v6.27.0\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction _extends() {\r\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n    return target;\r\n  };\r\n  return _extends.apply(this, arguments);\r\n}\r\nfunction _objectWithoutPropertiesLoose(source, excluded) {\r\n  if (source == null) return {};\r\n  var target = {};\r\n  var sourceKeys = Object.keys(source);\r\n  var key, i;\r\n  for (i = 0; i < sourceKeys.length; i++) {\r\n    key = sourceKeys[i];\r\n    if (excluded.indexOf(key) >= 0) continue;\r\n    target[key] = source[key];\r\n  }\r\n  return target;\r\n}\r\n\r\nconst defaultMethod = \"get\";\r\nconst defaultEncType = \"application/x-www-form-urlencoded\";\r\nfunction isHtmlElement(object) {\r\n  return object != null && typeof object.tagName === \"string\";\r\n}\r\nfunction isButtonElement(object) {\r\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\r\n}\r\nfunction isFormElement(object) {\r\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\r\n}\r\nfunction isInputElement(object) {\r\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\r\n}\r\nfunction isModifiedEvent(event) {\r\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\r\n}\r\nfunction shouldProcessLinkClick(event, target) {\r\n  return event.button === 0 && (\r\n  // Ignore everything but left clicks\r\n  !target || target === \"_self\") &&\r\n  // Let browser handle \"target=_blank\" etc.\r\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\r\n  ;\r\n}\r\n/**\r\n * Creates a URLSearchParams object using the given initializer.\r\n *\r\n * This is identical to `new URLSearchParams(init)` except it also\r\n * supports arrays as values in the object form of the initializer\r\n * instead of just strings. This is convenient when you need multiple\r\n * values for a given key, but don't want to use an array initializer.\r\n *\r\n * For example, instead of:\r\n *\r\n *   let searchParams = new URLSearchParams([\r\n *     ['sort', 'name'],\r\n *     ['sort', 'price']\r\n *   ]);\r\n *\r\n * you can do:\r\n *\r\n *   let searchParams = createSearchParams({\r\n *     sort: ['name', 'price']\r\n *   });\r\n */\r\nfunction createSearchParams(init) {\r\n  if (init === void 0) {\r\n    init = \"\";\r\n  }\r\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\r\n    let value = init[key];\r\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\r\n  }, []));\r\n}\r\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\r\n  let searchParams = createSearchParams(locationSearch);\r\n  if (defaultSearchParams) {\r\n    // Use `defaultSearchParams.forEach(...)` here instead of iterating of\r\n    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\r\n    // web extensions. Relevant Bugzilla tickets:\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\r\n    defaultSearchParams.forEach((_, key) => {\r\n      if (!searchParams.has(key)) {\r\n        defaultSearchParams.getAll(key).forEach(value => {\r\n          searchParams.append(key, value);\r\n        });\r\n      }\r\n    });\r\n  }\r\n  return searchParams;\r\n}\r\n// One-time check for submitter support\r\nlet _formDataSupportsSubmitter = null;\r\nfunction isFormDataSubmitterSupported() {\r\n  if (_formDataSupportsSubmitter === null) {\r\n    try {\r\n      new FormData(document.createElement(\"form\"),\r\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\r\n      0);\r\n      _formDataSupportsSubmitter = false;\r\n    } catch (e) {\r\n      _formDataSupportsSubmitter = true;\r\n    }\r\n  }\r\n  return _formDataSupportsSubmitter;\r\n}\r\nconst supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\r\nfunction getFormEncType(encType) {\r\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\r\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_warning)(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) : 0;\r\n    return null;\r\n  }\r\n  return encType;\r\n}\r\nfunction getFormSubmissionInfo(target, basename) {\r\n  let method;\r\n  let action;\r\n  let encType;\r\n  let formData;\r\n  let body;\r\n  if (isFormElement(target)) {\r\n    // When grabbing the action from the element, it will have had the basename\r\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\r\n    // re-prefix in the router\r\n    let attr = target.getAttribute(\"action\");\r\n    action = attr ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.stripBasename)(attr, basename) : null;\r\n    method = target.getAttribute(\"method\") || defaultMethod;\r\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\r\n    formData = new FormData(target);\r\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\r\n    let form = target.form;\r\n    if (form == null) {\r\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\r\n    }\r\n    // <button>/<input type=\"submit\"> may override attributes of <form>\r\n    // When grabbing the action from the element, it will have had the basename\r\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\r\n    // re-prefix in the router\r\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\r\n    action = attr ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.stripBasename)(attr, basename) : null;\r\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\r\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\r\n    // Build a FormData object populated from a form and submitter\r\n    formData = new FormData(form, target);\r\n    // If this browser doesn't support the `FormData(el, submitter)` format,\r\n    // then tack on the submitter value at the end.  This is a lightweight\r\n    // solution that is not 100% spec compliant.  For complete support in older\r\n    // browsers, consider using the `formdata-submitter-polyfill` package\r\n    if (!isFormDataSubmitterSupported()) {\r\n      let {\r\n        name,\r\n        type,\r\n        value\r\n      } = target;\r\n      if (type === \"image\") {\r\n        let prefix = name ? name + \".\" : \"\";\r\n        formData.append(prefix + \"x\", \"0\");\r\n        formData.append(prefix + \"y\", \"0\");\r\n      } else if (name) {\r\n        formData.append(name, value);\r\n      }\r\n    }\r\n  } else if (isHtmlElement(target)) {\r\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\r\n  } else {\r\n    method = defaultMethod;\r\n    action = null;\r\n    encType = defaultEncType;\r\n    body = target;\r\n  }\r\n  // Send body for <Form encType=\"text/plain\" so we encode it into text\r\n  if (formData && encType === \"text/plain\") {\r\n    body = formData;\r\n    formData = undefined;\r\n  }\r\n  return {\r\n    action,\r\n    method: method.toLowerCase(),\r\n    encType,\r\n    formData,\r\n    body\r\n  };\r\n}\r\n\r\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"viewTransition\"],\r\n  _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"viewTransition\", \"children\"],\r\n  _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"viewTransition\"];\r\n// HEY YOU! DON'T TOUCH THIS VARIABLE!\r\n//\r\n// It is replaced with the proper version at build time via a babel plugin in\r\n// the rollup config.\r\n//\r\n// Export a global property onto the window for React Router detection by the\r\n// Core Web Vitals Technology Report.  This way they can configure the `wappalyzer`\r\n// to detect and properly classify live websites as being built with React Router:\r\n// https://github.com/HTTPArchive/wappalyzer/blob/main/src/technologies/r.json\r\nconst REACT_ROUTER_VERSION = \"6\";\r\ntry {\r\n  window.__reactRouterVersion = REACT_ROUTER_VERSION;\r\n} catch (e) {\r\n  // no-op\r\n}\r\nfunction createBrowserRouter(routes, opts) {\r\n  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.createRouter)({\r\n    basename: opts == null ? void 0 : opts.basename,\r\n    future: _extends({}, opts == null ? void 0 : opts.future, {\r\n      v7_prependBasename: true\r\n    }),\r\n    history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.createBrowserHistory)({\r\n      window: opts == null ? void 0 : opts.window\r\n    }),\r\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\r\n    routes,\r\n    mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_mapRouteProperties,\r\n    dataStrategy: opts == null ? void 0 : opts.dataStrategy,\r\n    patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,\r\n    window: opts == null ? void 0 : opts.window\r\n  }).initialize();\r\n}\r\nfunction createHashRouter(routes, opts) {\r\n  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.createRouter)({\r\n    basename: opts == null ? void 0 : opts.basename,\r\n    future: _extends({}, opts == null ? void 0 : opts.future, {\r\n      v7_prependBasename: true\r\n    }),\r\n    history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.createHashHistory)({\r\n      window: opts == null ? void 0 : opts.window\r\n    }),\r\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\r\n    routes,\r\n    mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_mapRouteProperties,\r\n    dataStrategy: opts == null ? void 0 : opts.dataStrategy,\r\n    patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation,\r\n    window: opts == null ? void 0 : opts.window\r\n  }).initialize();\r\n}\r\nfunction parseHydrationData() {\r\n  var _window;\r\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\r\n  if (state && state.errors) {\r\n    state = _extends({}, state, {\r\n      errors: deserializeErrors(state.errors)\r\n    });\r\n  }\r\n  return state;\r\n}\r\nfunction deserializeErrors(errors) {\r\n  if (!errors) return null;\r\n  let entries = Object.entries(errors);\r\n  let serialized = {};\r\n  for (let [key, val] of entries) {\r\n    // Hey you!  If you change this, please change the corresponding logic in\r\n    // serializeErrors in react-router-dom/server.tsx :)\r\n    if (val && val.__type === \"RouteErrorResponse\") {\r\n      serialized[key] = new _remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\r\n    } else if (val && val.__type === \"Error\") {\r\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\r\n      if (val.__subType) {\r\n        let ErrorConstructor = window[val.__subType];\r\n        if (typeof ErrorConstructor === \"function\") {\r\n          try {\r\n            // @ts-expect-error\r\n            let error = new ErrorConstructor(val.message);\r\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\r\n            // because we don't serialize SSR stack traces for security reasons\r\n            error.stack = \"\";\r\n            serialized[key] = error;\r\n          } catch (e) {\r\n            // no-op - fall through and create a normal Error\r\n          }\r\n        }\r\n      }\r\n      if (serialized[key] == null) {\r\n        let error = new Error(val.message);\r\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\r\n        // because we don't serialize SSR stack traces for security reasons\r\n        error.stack = \"\";\r\n        serialized[key] = error;\r\n      }\r\n    } else {\r\n      serialized[key] = val;\r\n    }\r\n  }\r\n  return serialized;\r\n}\r\nconst ViewTransitionContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\r\n  isTransitioning: false\r\n});\r\nif (true) {\r\n  ViewTransitionContext.displayName = \"ViewTransition\";\r\n}\r\nconst FetchersContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(new Map());\r\nif (true) {\r\n  FetchersContext.displayName = \"Fetchers\";\r\n}\r\n//#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region Components\r\n////////////////////////////////////////////////////////////////////////////////\r\n/**\r\n  Webpack + React 17 fails to compile on any of the following because webpack\r\n  complains that `startTransition` doesn't exist in `React`:\r\n  * import { startTransition } from \"react\"\r\n  * import * as React from from \"react\";\r\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\r\n  * import * as React from from \"react\";\r\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\r\n\r\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\r\n  * import * as React from from \"react\";\r\n    const START_TRANSITION = \"startTransition\";\r\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\r\n\r\n  However, that introduces webpack/terser minification issues in production builds\r\n  in React 18 where minification/obfuscation ends up removing the call of\r\n  React.startTransition entirely from the first half of the ternary.  Grabbing\r\n  this exported reference once up front resolves that issue.\r\n\r\n  See https://github.com/remix-run/react-router/issues/10579\r\n*/\r\nconst START_TRANSITION = \"startTransition\";\r\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\r\nconst FLUSH_SYNC = \"flushSync\";\r\nconst flushSyncImpl = react_dom__WEBPACK_IMPORTED_MODULE_1__[FLUSH_SYNC];\r\nconst USE_ID = \"useId\";\r\nconst useIdImpl = react__WEBPACK_IMPORTED_MODULE_0__[USE_ID];\r\nfunction startTransitionSafe(cb) {\r\n  if (startTransitionImpl) {\r\n    startTransitionImpl(cb);\r\n  } else {\r\n    cb();\r\n  }\r\n}\r\nfunction flushSyncSafe(cb) {\r\n  if (flushSyncImpl) {\r\n    flushSyncImpl(cb);\r\n  } else {\r\n    cb();\r\n  }\r\n}\r\nclass Deferred {\r\n  constructor() {\r\n    this.status = \"pending\";\r\n    this.promise = new Promise((resolve, reject) => {\r\n      this.resolve = value => {\r\n        if (this.status === \"pending\") {\r\n          this.status = \"resolved\";\r\n          resolve(value);\r\n        }\r\n      };\r\n      this.reject = reason => {\r\n        if (this.status === \"pending\") {\r\n          this.status = \"rejected\";\r\n          reject(reason);\r\n        }\r\n      };\r\n    });\r\n  }\r\n}\r\n/**\r\n * Given a Remix Router instance, render the appropriate UI\r\n */\r\nfunction RouterProvider(_ref) {\r\n  let {\r\n    fallbackElement,\r\n    router,\r\n    future\r\n  } = _ref;\r\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\r\n  let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\r\n  let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n    isTransitioning: false\r\n  });\r\n  let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\r\n  let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\r\n  let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\r\n  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Map());\r\n  let {\r\n    v7_startTransition\r\n  } = future || {};\r\n  let optInStartTransition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(cb => {\r\n    if (v7_startTransition) {\r\n      startTransitionSafe(cb);\r\n    } else {\r\n      cb();\r\n    }\r\n  }, [v7_startTransition]);\r\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState, _ref2) => {\r\n    let {\r\n      deletedFetchers,\r\n      flushSync: flushSync,\r\n      viewTransitionOpts: viewTransitionOpts\r\n    } = _ref2;\r\n    deletedFetchers.forEach(key => fetcherData.current.delete(key));\r\n    newState.fetchers.forEach((fetcher, key) => {\r\n      if (fetcher.data !== undefined) {\r\n        fetcherData.current.set(key, fetcher.data);\r\n      }\r\n    });\r\n    let isViewTransitionUnavailable = router.window == null || router.window.document == null || typeof router.window.document.startViewTransition !== \"function\";\r\n    // If this isn't a view transition or it's not available in this browser,\r\n    // just update and be done with it\r\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\r\n      if (flushSync) {\r\n        flushSyncSafe(() => setStateImpl(newState));\r\n      } else {\r\n        optInStartTransition(() => setStateImpl(newState));\r\n      }\r\n      return;\r\n    }\r\n    // flushSync + startViewTransition\r\n    if (flushSync) {\r\n      // Flush through the context to mark DOM elements as transition=ing\r\n      flushSyncSafe(() => {\r\n        // Cancel any pending transitions\r\n        if (transition) {\r\n          renderDfd && renderDfd.resolve();\r\n          transition.skipTransition();\r\n        }\r\n        setVtContext({\r\n          isTransitioning: true,\r\n          flushSync: true,\r\n          currentLocation: viewTransitionOpts.currentLocation,\r\n          nextLocation: viewTransitionOpts.nextLocation\r\n        });\r\n      });\r\n      // Update the DOM\r\n      let t = router.window.document.startViewTransition(() => {\r\n        flushSyncSafe(() => setStateImpl(newState));\r\n      });\r\n      // Clean up after the animation completes\r\n      t.finished.finally(() => {\r\n        flushSyncSafe(() => {\r\n          setRenderDfd(undefined);\r\n          setTransition(undefined);\r\n          setPendingState(undefined);\r\n          setVtContext({\r\n            isTransitioning: false\r\n          });\r\n        });\r\n      });\r\n      flushSyncSafe(() => setTransition(t));\r\n      return;\r\n    }\r\n    // startTransition + startViewTransition\r\n    if (transition) {\r\n      // Interrupting an in-progress transition, cancel and let everything flush\r\n      // out, and then kick off a new transition from the interruption state\r\n      renderDfd && renderDfd.resolve();\r\n      transition.skipTransition();\r\n      setInterruption({\r\n        state: newState,\r\n        currentLocation: viewTransitionOpts.currentLocation,\r\n        nextLocation: viewTransitionOpts.nextLocation\r\n      });\r\n    } else {\r\n      // Completed navigation update with opted-in view transitions, let 'er rip\r\n      setPendingState(newState);\r\n      setVtContext({\r\n        isTransitioning: true,\r\n        flushSync: false,\r\n        currentLocation: viewTransitionOpts.currentLocation,\r\n        nextLocation: viewTransitionOpts.nextLocation\r\n      });\r\n    }\r\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\r\n  // Need to use a layout effect here so we are subscribed early enough to\r\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\r\n  // When we start a view transition, create a Deferred we can use for the\r\n  // eventual \"completed\" render\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\r\n      setRenderDfd(new Deferred());\r\n    }\r\n  }, [vtContext]);\r\n  // Once the deferred is created, kick off startViewTransition() to update the\r\n  // DOM and then wait on the Deferred to resolve (indicating the DOM update has\r\n  // happened)\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (renderDfd && pendingState && router.window) {\r\n      let newState = pendingState;\r\n      let renderPromise = renderDfd.promise;\r\n      let transition = router.window.document.startViewTransition(async () => {\r\n        optInStartTransition(() => setStateImpl(newState));\r\n        await renderPromise;\r\n      });\r\n      transition.finished.finally(() => {\r\n        setRenderDfd(undefined);\r\n        setTransition(undefined);\r\n        setPendingState(undefined);\r\n        setVtContext({\r\n          isTransitioning: false\r\n        });\r\n      });\r\n      setTransition(transition);\r\n    }\r\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\r\n  // When the new location finally renders and is committed to the DOM, this\r\n  // effect will run to resolve the transition\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\r\n      renderDfd.resolve();\r\n    }\r\n  }, [renderDfd, transition, state.location, pendingState]);\r\n  // If we get interrupted with a new navigation during a transition, we skip\r\n  // the active transition, let it cleanup, then kick it off again here\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (!vtContext.isTransitioning && interruption) {\r\n      setPendingState(interruption.state);\r\n      setVtContext({\r\n        isTransitioning: true,\r\n        flushSync: false,\r\n        currentLocation: interruption.currentLocation,\r\n        nextLocation: interruption.nextLocation\r\n      });\r\n      setInterruption(undefined);\r\n    }\r\n  }, [vtContext.isTransitioning, interruption]);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\r\n    // Only log this once on initial mount\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n  let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    return {\r\n      createHref: router.createHref,\r\n      encodeLocation: router.encodeLocation,\r\n      go: n => router.navigate(n),\r\n      push: (to, state, opts) => router.navigate(to, {\r\n        state,\r\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\r\n      }),\r\n      replace: (to, state, opts) => router.navigate(to, {\r\n        replace: true,\r\n        state,\r\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\r\n      })\r\n    };\r\n  }, [router]);\r\n  let basename = router.basename || \"/\";\r\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\r\n    router,\r\n    navigator,\r\n    static: false,\r\n    basename\r\n  }), [router, navigator, basename]);\r\n  let routerFuture = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\r\n    v7_relativeSplatPath: router.future.v7_relativeSplatPath\r\n  }), [router.future.v7_relativeSplatPath]);\r\n  // The fragment and {null} here are important!  We need them to keep React 18's\r\n  // useId happy when we are server-rendering since we may have a <script> here\r\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\r\n  // useId relies on the component tree structure to generate deterministic id's\r\n  // so we need to ensure it remains the same on the client even though\r\n  // we don't need the <script> tag\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext.Provider, {\r\n    value: dataRouterContext\r\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext.Provider, {\r\n    value: state\r\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {\r\n    value: fetcherData.current\r\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {\r\n    value: vtContext\r\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\r\n    basename: basename,\r\n    location: state.location,\r\n    navigationType: state.historyAction,\r\n    navigator: navigator,\r\n    future: routerFuture\r\n  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(MemoizedDataRoutes, {\r\n    routes: router.routes,\r\n    future: router.future,\r\n    state: state\r\n  }) : fallbackElement))))), null);\r\n}\r\n// Memoize to avoid re-renders when updating `ViewTransitionContext`\r\nconst MemoizedDataRoutes = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.memo(DataRoutes);\r\nfunction DataRoutes(_ref3) {\r\n  let {\r\n    routes,\r\n    future,\r\n    state\r\n  } = _ref3;\r\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_useRoutesImpl)(routes, undefined, state, future);\r\n}\r\n/**\r\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\r\n */\r\nfunction BrowserRouter(_ref4) {\r\n  let {\r\n    basename,\r\n    children,\r\n    future,\r\n    window\r\n  } = _ref4;\r\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\r\n  if (historyRef.current == null) {\r\n    historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.createBrowserHistory)({\r\n      window,\r\n      v5Compat: true\r\n    });\r\n  }\r\n  let history = historyRef.current;\r\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  let {\r\n    v7_startTransition\r\n  } = future || {};\r\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\r\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\r\n  }, [setStateImpl, v7_startTransition]);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\r\n    basename: basename,\r\n    children: children,\r\n    location: state.location,\r\n    navigationType: state.action,\r\n    navigator: history,\r\n    future: future\r\n  });\r\n}\r\n/**\r\n * A `<Router>` for use in web browsers. Stores the location in the hash\r\n * portion of the URL so it is not sent to the server.\r\n */\r\nfunction HashRouter(_ref5) {\r\n  let {\r\n    basename,\r\n    children,\r\n    future,\r\n    window\r\n  } = _ref5;\r\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\r\n  if (historyRef.current == null) {\r\n    historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.createHashHistory)({\r\n      window,\r\n      v5Compat: true\r\n    });\r\n  }\r\n  let history = historyRef.current;\r\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  let {\r\n    v7_startTransition\r\n  } = future || {};\r\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\r\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\r\n  }, [setStateImpl, v7_startTransition]);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\r\n    basename: basename,\r\n    children: children,\r\n    location: state.location,\r\n    navigationType: state.action,\r\n    navigator: history,\r\n    future: future\r\n  });\r\n}\r\n/**\r\n * A `<Router>` that accepts a pre-instantiated history object. It's important\r\n * to note that using your own history object is highly discouraged and may add\r\n * two versions of the history library to your bundles unless you use the same\r\n * version of the history library that React Router uses internally.\r\n */\r\nfunction HistoryRouter(_ref6) {\r\n  let {\r\n    basename,\r\n    children,\r\n    future,\r\n    history\r\n  } = _ref6;\r\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  let {\r\n    v7_startTransition\r\n  } = future || {};\r\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\r\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\r\n  }, [setStateImpl, v7_startTransition]);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\r\n    basename: basename,\r\n    children: children,\r\n    location: state.location,\r\n    navigationType: state.action,\r\n    navigator: history,\r\n    future: future\r\n  });\r\n}\r\nif (true) {\r\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\r\n}\r\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\r\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\r\n/**\r\n * The public API for rendering a history-aware `<a>`.\r\n */\r\nconst Link = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref7, ref) {\r\n  let {\r\n      onClick,\r\n      relative,\r\n      reloadDocument,\r\n      replace,\r\n      state,\r\n      target,\r\n      to,\r\n      preventScrollReset,\r\n      viewTransition\r\n    } = _ref7,\r\n    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\r\n  let {\r\n    basename\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\r\n  // Rendered into <a href> for absolute URLs\r\n  let absoluteHref;\r\n  let isExternal = false;\r\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\r\n    // Render the absolute href server- and client-side\r\n    absoluteHref = to;\r\n    // Only check for external origins client-side\r\n    if (isBrowser) {\r\n      try {\r\n        let currentUrl = new URL(window.location.href);\r\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\r\n        let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.stripBasename)(targetUrl.pathname, basename);\r\n        if (targetUrl.origin === currentUrl.origin && path != null) {\r\n          // Strip the protocol/origin/basename for same-origin absolute URLs\r\n          to = path + targetUrl.search + targetUrl.hash;\r\n        } else {\r\n          isExternal = true;\r\n        }\r\n      } catch (e) {\r\n        // We can't do external URL detection without a valid URL\r\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_warning)(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") : 0;\r\n      }\r\n    }\r\n  }\r\n  // Rendered into <a href> for relative URLs\r\n  let href = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useHref)(to, {\r\n    relative\r\n  });\r\n  let internalOnClick = useLinkClickHandler(to, {\r\n    replace,\r\n    state,\r\n    target,\r\n    preventScrollReset,\r\n    relative,\r\n    viewTransition\r\n  });\r\n  function handleClick(event) {\r\n    if (onClick) onClick(event);\r\n    if (!event.defaultPrevented) {\r\n      internalOnClick(event);\r\n    }\r\n  }\r\n  return (\r\n    /*#__PURE__*/\r\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\r\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\r\n      href: absoluteHref || href,\r\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\r\n      ref: ref,\r\n      target: target\r\n    }))\r\n  );\r\n});\r\nif (true) {\r\n  Link.displayName = \"Link\";\r\n}\r\n/**\r\n * A `<Link>` wrapper that knows if it's \"active\" or not.\r\n */\r\nconst NavLink = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref8, ref) {\r\n  let {\r\n      \"aria-current\": ariaCurrentProp = \"page\",\r\n      caseSensitive = false,\r\n      className: classNameProp = \"\",\r\n      end = false,\r\n      style: styleProp,\r\n      to,\r\n      viewTransition,\r\n      children\r\n    } = _ref8,\r\n    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\r\n  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {\r\n    relative: rest.relative\r\n  });\r\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\r\n  let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);\r\n  let {\r\n    navigator,\r\n    basename\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\r\n  let isTransitioning = routerState != null &&\r\n  // Conditional usage is OK here because the usage of a data router is static\r\n  // eslint-disable-next-line react-hooks/rules-of-hooks\r\n  useViewTransitionState(path) && viewTransition === true;\r\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\r\n  let locationPathname = location.pathname;\r\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\r\n  if (!caseSensitive) {\r\n    locationPathname = locationPathname.toLowerCase();\r\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\r\n    toPathname = toPathname.toLowerCase();\r\n  }\r\n  if (nextLocationPathname && basename) {\r\n    nextLocationPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.stripBasename)(nextLocationPathname, basename) || nextLocationPathname;\r\n  }\r\n  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\r\n  // we're looking for a slash _after_ what's in `to`.  For example:\r\n  //\r\n  // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\r\n  // both want to look for a / at index 6 to match URL `/users/matt`\r\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\r\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\r\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\r\n  let renderProps = {\r\n    isActive,\r\n    isPending,\r\n    isTransitioning\r\n  };\r\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\r\n  let className;\r\n  if (typeof classNameProp === \"function\") {\r\n    className = classNameProp(renderProps);\r\n  } else {\r\n    // If the className prop is not a function, we use a default `active`\r\n    // class for <NavLink />s that are active. In v5 `active` was the default\r\n    // value for `activeClassName`, but we are removing that API and can still\r\n    // use the old default behavior for a cleaner upgrade path and keep the\r\n    // simple styling rules working as they currently do.\r\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\r\n  }\r\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\r\n    \"aria-current\": ariaCurrent,\r\n    className: className,\r\n    ref: ref,\r\n    style: style,\r\n    to: to,\r\n    viewTransition: viewTransition\r\n  }), typeof children === \"function\" ? children(renderProps) : children);\r\n});\r\nif (true) {\r\n  NavLink.displayName = \"NavLink\";\r\n}\r\n/**\r\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\r\n * that the interaction with the server is with `fetch` instead of new document\r\n * requests, allowing components to add nicer UX to the page as the form is\r\n * submitted and returns with data.\r\n */\r\nconst Form = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref9, forwardedRef) => {\r\n  let {\r\n      fetcherKey,\r\n      navigate,\r\n      reloadDocument,\r\n      replace,\r\n      state,\r\n      method = defaultMethod,\r\n      action,\r\n      onSubmit,\r\n      relative,\r\n      preventScrollReset,\r\n      viewTransition\r\n    } = _ref9,\r\n    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\r\n  let submit = useSubmit();\r\n  let formAction = useFormAction(action, {\r\n    relative\r\n  });\r\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\r\n  let submitHandler = event => {\r\n    onSubmit && onSubmit(event);\r\n    if (event.defaultPrevented) return;\r\n    event.preventDefault();\r\n    let submitter = event.nativeEvent.submitter;\r\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\r\n    submit(submitter || event.currentTarget, {\r\n      fetcherKey,\r\n      method: submitMethod,\r\n      navigate,\r\n      replace,\r\n      state,\r\n      relative,\r\n      preventScrollReset,\r\n      viewTransition\r\n    });\r\n  };\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\r\n    ref: forwardedRef,\r\n    method: formMethod,\r\n    action: formAction,\r\n    onSubmit: reloadDocument ? onSubmit : submitHandler\r\n  }, props));\r\n});\r\nif (true) {\r\n  Form.displayName = \"Form\";\r\n}\r\n/**\r\n * This component will emulate the browser's scroll restoration on location\r\n * changes.\r\n */\r\nfunction ScrollRestoration(_ref10) {\r\n  let {\r\n    getKey,\r\n    storageKey\r\n  } = _ref10;\r\n  useScrollRestoration({\r\n    getKey,\r\n    storageKey\r\n  });\r\n  return null;\r\n}\r\nif (true) {\r\n  ScrollRestoration.displayName = \"ScrollRestoration\";\r\n}\r\n//#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region Hooks\r\n////////////////////////////////////////////////////////////////////////////////\r\nvar DataRouterHook;\r\n(function (DataRouterHook) {\r\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\r\n  DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\r\n  DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\r\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\r\n  DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\r\n})(DataRouterHook || (DataRouterHook = {}));\r\nvar DataRouterStateHook;\r\n(function (DataRouterStateHook) {\r\n  DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\r\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\r\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\r\n})(DataRouterStateHook || (DataRouterStateHook = {}));\r\n// Internal hooks\r\nfunction getDataRouterConsoleError(hookName) {\r\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\r\n}\r\nfunction useDataRouterContext(hookName) {\r\n  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext);\r\n  !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\r\n  return ctx;\r\n}\r\nfunction useDataRouterState(hookName) {\r\n  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);\r\n  !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\r\n  return state;\r\n}\r\n// External hooks\r\n/**\r\n * Handles the click behavior for router `<Link>` components. This is useful if\r\n * you need to create custom `<Link>` components with the same click behavior we\r\n * use in our exported `<Link>`.\r\n */\r\nfunction useLinkClickHandler(to, _temp) {\r\n  let {\r\n    target,\r\n    replace: replaceProp,\r\n    state,\r\n    preventScrollReset,\r\n    relative,\r\n    viewTransition\r\n  } = _temp === void 0 ? {} : _temp;\r\n  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();\r\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\r\n  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {\r\n    relative\r\n  });\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {\r\n    if (shouldProcessLinkClick(event, target)) {\r\n      event.preventDefault();\r\n      // If the URL hasn't changed, a regular <a> will do a replace instead of\r\n      // a push, so do the same here unless the replace prop is explicitly set\r\n      let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\r\n      navigate(to, {\r\n        replace,\r\n        state,\r\n        preventScrollReset,\r\n        relative,\r\n        viewTransition\r\n      });\r\n    }\r\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);\r\n}\r\n/**\r\n * A convenient wrapper for reading and writing search parameters via the\r\n * URLSearchParams interface.\r\n */\r\nfunction useSearchParams(defaultInit) {\r\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params.\") : 0;\r\n  let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\r\n  let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\r\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\r\n  let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() =>\r\n  // Only merge in the defaults if we haven't yet called setSearchParams.\r\n  // Once we call that we want those to take precedence, otherwise you can't\r\n  // remove a param with setSearchParams({}) if it has an initial value\r\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\r\n  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();\r\n  let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions) => {\r\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\r\n    hasSetSearchParamsRef.current = true;\r\n    navigate(\"?\" + newSearchParams, navigateOptions);\r\n  }, [navigate, searchParams]);\r\n  return [searchParams, setSearchParams];\r\n}\r\nfunction validateClientSideSubmission() {\r\n  if (typeof document === \"undefined\") {\r\n    throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\r\n  }\r\n}\r\nlet fetcherId = 0;\r\nlet getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\r\n/**\r\n * Returns a function that may be used to programmatically submit a form (or\r\n * some arbitrary data) to the server.\r\n */\r\nfunction useSubmit() {\r\n  let {\r\n    router\r\n  } = useDataRouterContext(DataRouterHook.UseSubmit);\r\n  let {\r\n    basename\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\r\n  let currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_useRouteId)();\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (target, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n    validateClientSideSubmission();\r\n    let {\r\n      action,\r\n      method,\r\n      encType,\r\n      formData,\r\n      body\r\n    } = getFormSubmissionInfo(target, basename);\r\n    if (options.navigate === false) {\r\n      let key = options.fetcherKey || getUniqueFetcherId();\r\n      router.fetch(key, currentRouteId, options.action || action, {\r\n        preventScrollReset: options.preventScrollReset,\r\n        formData,\r\n        body,\r\n        formMethod: options.method || method,\r\n        formEncType: options.encType || encType,\r\n        flushSync: options.flushSync\r\n      });\r\n    } else {\r\n      router.navigate(options.action || action, {\r\n        preventScrollReset: options.preventScrollReset,\r\n        formData,\r\n        body,\r\n        formMethod: options.method || method,\r\n        formEncType: options.encType || encType,\r\n        replace: options.replace,\r\n        state: options.state,\r\n        fromRouteId: currentRouteId,\r\n        flushSync: options.flushSync,\r\n        viewTransition: options.viewTransition\r\n      });\r\n    }\r\n  }, [router, basename, currentRouteId]);\r\n}\r\n// v7: Eventually we should deprecate this entirely in favor of using the\r\n// router method directly?\r\nfunction useFormAction(action, _temp2) {\r\n  let {\r\n    relative\r\n  } = _temp2 === void 0 ? {} : _temp2;\r\n  let {\r\n    basename\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\r\n  let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);\r\n  !routeContext ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\r\n  let [match] = routeContext.matches.slice(-1);\r\n  // Shallow clone path so we can modify it below, otherwise we modify the\r\n  // object referenced by useMemo inside useResolvedPath\r\n  let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(action ? action : \".\", {\r\n    relative\r\n  }));\r\n  // If no action was specified, browsers will persist current search params\r\n  // when determining the path, so match that behavior\r\n  // https://github.com/remix-run/remix/issues/927\r\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\r\n  if (action == null) {\r\n    // Safe to write to this directly here since if action was undefined, we\r\n    // would have called useResolvedPath(\".\") which will never include a search\r\n    path.search = location.search;\r\n    // When grabbing search params from the URL, remove any included ?index param\r\n    // since it might not apply to our contextual route.  We add it back based\r\n    // on match.route.index below\r\n    let params = new URLSearchParams(path.search);\r\n    let indexValues = params.getAll(\"index\");\r\n    let hasNakedIndexParam = indexValues.some(v => v === \"\");\r\n    if (hasNakedIndexParam) {\r\n      params.delete(\"index\");\r\n      indexValues.filter(v => v).forEach(v => params.append(\"index\", v));\r\n      let qs = params.toString();\r\n      path.search = qs ? \"?\" + qs : \"\";\r\n    }\r\n  }\r\n  if ((!action || action === \".\") && match.route.index) {\r\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\r\n  }\r\n  // If we're operating within a basename, prepend it to the pathname prior\r\n  // to creating the form action.  If this is a root navigation, then just use\r\n  // the raw basename which allows the basename to have full control over the\r\n  // presence of a trailing slash on root actions\r\n  if (basename !== \"/\") {\r\n    path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.joinPaths)([basename, path.pathname]);\r\n  }\r\n  return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\r\n}\r\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\r\n/**\r\n * Interacts with route loaders and actions without causing a navigation. Great\r\n * for any interaction that stays on the same page.\r\n */\r\nfunction useFetcher(_temp3) {\r\n  var _route$matches;\r\n  let {\r\n    key\r\n  } = _temp3 === void 0 ? {} : _temp3;\r\n  let {\r\n    router\r\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\r\n  let state = useDataRouterState(DataRouterStateHook.UseFetcher);\r\n  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);\r\n  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);\r\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\r\n  !fetcherData ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_invariant)(false, \"useFetcher must be used inside a FetchersContext\") : 0 : void 0;\r\n  !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\r\n  !(routeId != null) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_invariant)(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : 0 : void 0;\r\n  // Fetcher key handling\r\n  // OK to call conditionally to feature detect `useId`\r\n  // eslint-disable-next-line react-hooks/rules-of-hooks\r\n  let defaultKey = useIdImpl ? useIdImpl() : \"\";\r\n  let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || defaultKey);\r\n  if (key && key !== fetcherKey) {\r\n    setFetcherKey(key);\r\n  } else if (!fetcherKey) {\r\n    // We will only fall through here when `useId` is not available\r\n    setFetcherKey(getUniqueFetcherId());\r\n  }\r\n  // Registration/cleanup\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    router.getFetcher(fetcherKey);\r\n    return () => {\r\n      // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\r\n      // will not delete immediately but instead queue up a delete after the\r\n      // fetcher returns to an `idle` state\r\n      router.deleteFetcher(fetcherKey);\r\n    };\r\n  }, [router, fetcherKey]);\r\n  // Fetcher additions\r\n  let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((href, opts) => {\r\n    !routeId ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\r\n    router.fetch(fetcherKey, routeId, href, opts);\r\n  }, [fetcherKey, routeId, router]);\r\n  let submitImpl = useSubmit();\r\n  let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((target, opts) => {\r\n    submitImpl(target, _extends({}, opts, {\r\n      navigate: false,\r\n      fetcherKey\r\n    }));\r\n  }, [fetcherKey, submitImpl]);\r\n  let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    let FetcherForm = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\r\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, _extends({}, props, {\r\n        navigate: false,\r\n        fetcherKey: fetcherKey,\r\n        ref: ref\r\n      }));\r\n    });\r\n    if (true) {\r\n      FetcherForm.displayName = \"fetcher.Form\";\r\n    }\r\n    return FetcherForm;\r\n  }, [fetcherKey]);\r\n  // Exposed FetcherWithComponents\r\n  let fetcher = state.fetchers.get(fetcherKey) || _remix_run_router__WEBPACK_IMPORTED_MODULE_3__.IDLE_FETCHER;\r\n  let data = fetcherData.get(fetcherKey);\r\n  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _extends({\r\n    Form: FetcherForm,\r\n    submit,\r\n    load\r\n  }, fetcher, {\r\n    data\r\n  }), [FetcherForm, submit, load, fetcher, data]);\r\n  return fetcherWithComponents;\r\n}\r\n/**\r\n * Provides all fetchers currently on the page. Useful for layouts and parent\r\n * routes that need to provide pending/optimistic UI regarding the fetch.\r\n */\r\nfunction useFetchers() {\r\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\r\n  return Array.from(state.fetchers.entries()).map(_ref11 => {\r\n    let [key, fetcher] = _ref11;\r\n    return _extends({}, fetcher, {\r\n      key\r\n    });\r\n  });\r\n}\r\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\r\nlet savedScrollPositions = {};\r\n/**\r\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\r\n */\r\nfunction useScrollRestoration(_temp4) {\r\n  let {\r\n    getKey,\r\n    storageKey\r\n  } = _temp4 === void 0 ? {} : _temp4;\r\n  let {\r\n    router\r\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\r\n  let {\r\n    restoreScrollPosition,\r\n    preventScrollReset\r\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\r\n  let {\r\n    basename\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\r\n  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\r\n  let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches)();\r\n  let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation)();\r\n  // Trigger manual scroll restoration while we're active\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    window.history.scrollRestoration = \"manual\";\r\n    return () => {\r\n      window.history.scrollRestoration = \"auto\";\r\n    };\r\n  }, []);\r\n  // Save positions on pagehide\r\n  usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\r\n    if (navigation.state === \"idle\") {\r\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\r\n      savedScrollPositions[key] = window.scrollY;\r\n    }\r\n    try {\r\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\r\n    } catch (error) {\r\n       true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_warning)(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : 0;\r\n    }\r\n    window.history.scrollRestoration = \"auto\";\r\n  }, [storageKey, getKey, navigation.state, location, matches]));\r\n  // Read in any saved scroll locations\r\n  if (typeof document !== \"undefined\") {\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\r\n      try {\r\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\r\n        if (sessionPositions) {\r\n          savedScrollPositions = JSON.parse(sessionPositions);\r\n        }\r\n      } catch (e) {\r\n        // no-op, use default empty object\r\n      }\r\n    }, [storageKey]);\r\n    // Enable scroll restoration in the router\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\r\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey( // Strip the basename to match useLocation()\r\n      _extends({}, location, {\r\n        pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.stripBasename)(location.pathname, basename) || location.pathname\r\n      }), matches) : getKey;\r\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\r\n      return () => disableScrollRestoration && disableScrollRestoration();\r\n    }, [router, basename, getKey]);\r\n    // Restore scrolling when state.restoreScrollPosition changes\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\r\n      // Explicit false means don't do anything (used for submissions)\r\n      if (restoreScrollPosition === false) {\r\n        return;\r\n      }\r\n      // been here before, scroll to it\r\n      if (typeof restoreScrollPosition === \"number\") {\r\n        window.scrollTo(0, restoreScrollPosition);\r\n        return;\r\n      }\r\n      // try to scroll to the hash\r\n      if (location.hash) {\r\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\r\n        if (el) {\r\n          el.scrollIntoView();\r\n          return;\r\n        }\r\n      }\r\n      // Don't reset if this navigation opted out\r\n      if (preventScrollReset === true) {\r\n        return;\r\n      }\r\n      // otherwise go to the top on new locations\r\n      window.scrollTo(0, 0);\r\n    }, [location, restoreScrollPosition, preventScrollReset]);\r\n  }\r\n}\r\n/**\r\n * Setup a callback to be fired on the window's `beforeunload` event. This is\r\n * useful for saving some data to `window.localStorage` just before the page\r\n * refreshes.\r\n *\r\n * Note: The `callback` argument should be a function created with\r\n * `React.useCallback()`.\r\n */\r\nfunction useBeforeUnload(callback, options) {\r\n  let {\r\n    capture\r\n  } = options || {};\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    let opts = capture != null ? {\r\n      capture\r\n    } : undefined;\r\n    window.addEventListener(\"beforeunload\", callback, opts);\r\n    return () => {\r\n      window.removeEventListener(\"beforeunload\", callback, opts);\r\n    };\r\n  }, [callback, capture]);\r\n}\r\n/**\r\n * Setup a callback to be fired on the window's `pagehide` event. This is\r\n * useful for saving some data to `window.localStorage` just before the page\r\n * refreshes.  This event is better supported than beforeunload across browsers.\r\n *\r\n * Note: The `callback` argument should be a function created with\r\n * `React.useCallback()`.\r\n */\r\nfunction usePageHide(callback, options) {\r\n  let {\r\n    capture\r\n  } = options || {};\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    let opts = capture != null ? {\r\n      capture\r\n    } : undefined;\r\n    window.addEventListener(\"pagehide\", callback, opts);\r\n    return () => {\r\n      window.removeEventListener(\"pagehide\", callback, opts);\r\n    };\r\n  }, [callback, capture]);\r\n}\r\n/**\r\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\r\n * of building a custom UI with useBlocker.\r\n *\r\n * Warning: This has *a lot of rough edges* and behaves very differently (and\r\n * very incorrectly in some cases) across browsers if user click addition\r\n * back/forward navigations while the confirm is open.  Use at your own risk.\r\n */\r\nfunction usePrompt(_ref12) {\r\n  let {\r\n    when,\r\n    message\r\n  } = _ref12;\r\n  let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useBlocker)(when);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (blocker.state === \"blocked\") {\r\n      let proceed = window.confirm(message);\r\n      if (proceed) {\r\n        // This timeout is needed to avoid a weird \"race\" on POP navigations\r\n        // between the `window.history` revert navigation and the result of\r\n        // `window.confirm`\r\n        setTimeout(blocker.proceed, 0);\r\n      } else {\r\n        blocker.reset();\r\n      }\r\n    }\r\n  }, [blocker, message]);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (blocker.state === \"blocked\" && !when) {\r\n      blocker.reset();\r\n    }\r\n  }, [blocker, when]);\r\n}\r\n/**\r\n * Return a boolean indicating if there is an active view transition to the\r\n * given href.  You can use this value to render CSS classes or viewTransitionName\r\n * styles onto your elements\r\n *\r\n * @param href The destination href\r\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\r\n */\r\nfunction useViewTransitionState(to, opts) {\r\n  if (opts === void 0) {\r\n    opts = {};\r\n  }\r\n  let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);\r\n  !(vtContext != null) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_invariant)(false, \"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : 0 : void 0;\r\n  let {\r\n    basename\r\n  } = useDataRouterContext(DataRouterHook.useViewTransitionState);\r\n  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {\r\n    relative: opts.relative\r\n  });\r\n  if (!vtContext.isTransitioning) {\r\n    return false;\r\n  }\r\n  let currentPath = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.stripBasename)(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\r\n  let nextPath = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.stripBasename)(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\r\n  // Transition is active if we're going to or coming from the indicated\r\n  // destination.  This ensures that other PUSH navigations that reverse\r\n  // an indicated transition apply.  I.e., on the list view you have:\r\n  //\r\n  //   <NavLink to=\"/details/1\" viewTransition>\r\n  //\r\n  // If you click the breadcrumb back to the list view:\r\n  //\r\n  //   <NavLink to=\"/list\" viewTransition>\r\n  //\r\n  // We should apply the transition because it's indicated as active going\r\n  // from /list -> /details/1 and therefore should be active on the reverse\r\n  // (even though this isn't strictly a POP reverse)\r\n  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.matchPath)(path.pathname, nextPath) != null || (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_3__.matchPath)(path.pathname, currentPath) != null;\r\n}\r\n//#endregion\r\n\r\n\r\n//# sourceMappingURL=index.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQjtBQUNPO0FBQ21SO0FBQ21mO0FBQ25tQjtBQUM1STtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQXFDLEdBQUcsaUVBQWMsOElBQThJLENBQU07QUFDOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0RBQVk7QUFDckI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxLQUFLO0FBQ0wsYUFBYSx1RUFBb0I7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixtRUFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLCtEQUFZO0FBQ3JCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMLGFBQWEsb0VBQWlCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IsbUVBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUVBQXdCO0FBQ3BELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnREFBbUI7QUFDOUQ7QUFDQSxDQUFDO0FBQ0QsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0EscUNBQXFDLGdEQUFtQjtBQUN4RCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBSztBQUNqQztBQUNBLHNCQUFzQixzQ0FBUTtBQUM5QjtBQUNBLGtCQUFrQixrQ0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhCQUE4QiwyQ0FBYztBQUM1Qyx3Q0FBd0MsMkNBQWM7QUFDdEQsa0NBQWtDLDJDQUFjO0FBQ2hEO0FBQ0EsR0FBRztBQUNILGtDQUFrQywyQ0FBYztBQUNoRCxvQ0FBb0MsMkNBQWM7QUFDbEQsd0NBQXdDLDJDQUFjO0FBQ3RELG9CQUFvQix5Q0FBWTtBQUNoQztBQUNBO0FBQ0EsSUFBSTtBQUNKLDZCQUE2Qiw4Q0FBaUI7QUFDOUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQiw4Q0FBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSxrREFBcUI7QUFDdkI7QUFDQTtBQUNBLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLDRDQUFlO0FBQ2pCLElBQUksS0FBcUMsR0FBRyxpRUFBYyx1TUFBdU0sQ0FBTTtBQUN2UTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQiwwQ0FBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLDBCQUEwQiwwQ0FBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsMENBQWE7QUFDbEM7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBbUIsQ0FBQywyQ0FBYyxxQkFBcUIsZ0RBQW1CLENBQUMsa0VBQXdCO0FBQ3pIO0FBQ0EsR0FBRyxlQUFlLGdEQUFtQixDQUFDLHVFQUE2QjtBQUNuRTtBQUNBLEdBQUcsZUFBZSxnREFBbUI7QUFDckM7QUFDQSxHQUFHLGVBQWUsZ0RBQW1CO0FBQ3JDO0FBQ0EsR0FBRyxlQUFlLGdEQUFtQixDQUFDLGdEQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdFQUF3RSxnREFBbUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3Q0FBd0MsdUNBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixTQUFTLGtFQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUIseUNBQVk7QUFDL0I7QUFDQSx5QkFBeUIsdUVBQW9CO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBYztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUJBQWlCLDhDQUFpQjtBQUNsQztBQUNBLEdBQUc7QUFDSCxFQUFFLGtEQUFxQjtBQUN2QixzQkFBc0IsZ0RBQW1CLENBQUMsZ0RBQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osbUJBQW1CLHlDQUFZO0FBQy9CO0FBQ0EseUJBQXlCLG9FQUFpQjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQWM7QUFDNUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQiw4Q0FBaUI7QUFDbEM7QUFDQSxHQUFHO0FBQ0gsRUFBRSxrREFBcUI7QUFDdkIsc0JBQXNCLGdEQUFtQixDQUFDLGdEQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw4QkFBOEIsMkNBQWM7QUFDNUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQiw4Q0FBaUI7QUFDbEM7QUFDQSxHQUFHO0FBQ0gsRUFBRSxrREFBcUI7QUFDdkIsc0JBQXNCLGdEQUFtQixDQUFDLGdEQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUksRUFBRSw2Q0FBZ0IsQ0FBQyxrRUFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVEsS0FBcUMsR0FBRyxpRUFBYywrSUFBK0ksQ0FBTTtBQUNuTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQU87QUFDcEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBbUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsYUFBYSw2REFBZTtBQUM1QjtBQUNBLEdBQUc7QUFDSCxpQkFBaUIseURBQVc7QUFDNUIsb0JBQW9CLDZDQUFnQixDQUFDLHVFQUE2QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsNkNBQWdCLENBQUMsa0VBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdFQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFtQixrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFnQixDQUFDLGtFQUF3QjtBQUNyRCxTQUFTLEtBQXFDLEdBQUcsbUVBQWdCLCtDQUErQyxDQUF1QjtBQUN2STtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFnQixDQUFDLHVFQUE2QjtBQUM1RCxXQUFXLEtBQXFDLEdBQUcsbUVBQWdCLCtDQUErQyxDQUF1QjtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCLGlCQUFpQix5REFBVztBQUM1QixpQkFBaUIseURBQVc7QUFDNUIsYUFBYSw2REFBZTtBQUM1QjtBQUNBLEdBQUc7QUFDSCxTQUFTLDhDQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx3REFBVSxlQUFlLHdEQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQXFDLEdBQUcsaUVBQWMscVNBQXFTLENBQU07QUFDblcsK0JBQStCLHlDQUFZO0FBQzNDLDhCQUE4Qix5Q0FBWTtBQUMxQyxpQkFBaUIseURBQVc7QUFDNUIscUJBQXFCLDBDQUFhO0FBQ2xDO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxpQkFBaUIseURBQVc7QUFDNUIsd0JBQXdCLDhDQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUksRUFBRSw2Q0FBZ0IsQ0FBQyxrRUFBd0I7QUFDL0MsdUJBQXVCLCtEQUFpQjtBQUN4QyxTQUFTLDhDQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQTtBQUNBLElBQUksRUFBRSw2Q0FBZ0IsQ0FBQyxrRUFBd0I7QUFDL0MscUJBQXFCLDZDQUFnQixDQUFDLDZEQUFtQjtBQUN6RCxrQkFBa0IsS0FBcUMsR0FBRyxtRUFBZ0IsOERBQThELENBQXVCO0FBQy9KO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFLDZEQUFlO0FBQ3pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0REFBUztBQUNoRTtBQUNBLFNBQVMsd0RBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLDZDQUFnQjtBQUNwQyxjQUFjLDZDQUFnQixDQUFDLDZEQUFtQjtBQUNsRDtBQUNBLGlCQUFpQixLQUFxQyxHQUFHLG1FQUFnQiw4REFBOEQsQ0FBdUI7QUFDOUosV0FBVyxLQUFxQyxHQUFHLG1FQUFnQiwyREFBMkQsQ0FBdUI7QUFDckosdUJBQXVCLEtBQXFDLEdBQUcsbUVBQWdCLGdGQUFnRixDQUF1QjtBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQ0FBYztBQUNsRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWEsOENBQWlCO0FBQzlCLGVBQWUsS0FBcUMsR0FBRyxtRUFBZ0IscURBQXFELENBQXVCO0FBQ25KO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSw4Q0FBaUI7QUFDaEMsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILG9CQUFvQiwwQ0FBYTtBQUNqQyxtQ0FBbUMsNkNBQWdCO0FBQ25ELDBCQUEwQixnREFBbUIsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrREFBa0QsMkRBQVk7QUFDOUQ7QUFDQSw4QkFBOEIsMENBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJLEVBQUUsNkNBQWdCLENBQUMsa0VBQXdCO0FBQy9DLGlCQUFpQix5REFBVztBQUM1QixnQkFBZ0Isd0RBQVU7QUFDMUIsbUJBQW1CLDJEQUFhO0FBQ2hDO0FBQ0EsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsOENBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNLEtBQXFDLEdBQUcsaUVBQWMsOEhBQThILENBQU07QUFDaE07QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUksa0RBQXFCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGtCQUFrQixnRUFBYTtBQUMvQixPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0Isd0RBQVU7QUFDMUIsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkNBQWdCO0FBQ2xDLHlCQUF5QixLQUFxQyxHQUFHLG1FQUFnQix5S0FBeUssQ0FBdUI7QUFDalI7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhLDZEQUFlO0FBQzVCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRUFBYTtBQUNqQyxpQkFBaUIsZ0VBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFTLHFDQUFxQyw0REFBUztBQUNoRTtBQUNBO0FBQ0E7QUFDMmY7QUFDM2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZGlzdC9pbmRleC5qcz8wM2E2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBSZWFjdCBSb3V0ZXIgRE9NIHY2LjI3LjBcclxuICpcclxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXHJcbiAqXHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xyXG5pbXBvcnQgeyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLCBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBSb3V0ZXIsIFVOU0FGRV91c2VSb3V0ZXNJbXBsLCBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIHVzZUhyZWYsIHVzZVJlc29sdmVkUGF0aCwgdXNlTG9jYXRpb24sIHVzZU5hdmlnYXRlLCBjcmVhdGVQYXRoLCBVTlNBRkVfdXNlUm91dGVJZCwgVU5TQUZFX1JvdXRlQ29udGV4dCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGlvbiwgdXNlQmxvY2tlciB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XHJcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBd2FpdCwgTWVtb3J5Um91dGVyLCBOYXZpZ2F0ZSwgTmF2aWdhdGlvblR5cGUsIE91dGxldCwgUm91dGUsIFJvdXRlciwgUm91dGVzLCBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0LCBVTlNBRkVfTG9jYXRpb25Db250ZXh0LCBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIFVOU0FGRV91c2VSb3V0ZUlkLCBjcmVhdGVNZW1vcnlSb3V0ZXIsIGNyZWF0ZVBhdGgsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiwgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgcGFyc2VQYXRoLCByZWRpcmVjdCwgcmVkaXJlY3REb2N1bWVudCwgcmVuZGVyTWF0Y2hlcywgcmVwbGFjZSwgcmVzb2x2ZVBhdGgsIHVzZUFjdGlvbkRhdGEsIHVzZUFzeW5jRXJyb3IsIHVzZUFzeW5jVmFsdWUsIHVzZUJsb2NrZXIsIHVzZUhyZWYsIHVzZUluUm91dGVyQ29udGV4dCwgdXNlTG9hZGVyRGF0YSwgdXNlTG9jYXRpb24sIHVzZU1hdGNoLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvbiwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVJldmFsaWRhdG9yLCB1c2VSb3V0ZUVycm9yLCB1c2VSb3V0ZUxvYWRlckRhdGEsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XHJcbmltcG9ydCB7IHN0cmlwQmFzZW5hbWUsIFVOU0FGRV93YXJuaW5nLCBjcmVhdGVSb3V0ZXIsIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsLCBVTlNBRkVfaW52YXJpYW50LCBqb2luUGF0aHMsIElETEVfRkVUQ0hFUiwgbWF0Y2hQYXRoIH0gZnJvbSAnQHJlbWl4LXJ1bi9yb3V0ZXInO1xyXG5leHBvcnQgeyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwgfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XHJcblxyXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcclxuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfTtcclxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XHJcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XHJcbiAgdmFyIHRhcmdldCA9IHt9O1xyXG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICB2YXIga2V5LCBpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xyXG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcclxuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbmNvbnN0IGRlZmF1bHRNZXRob2QgPSBcImdldFwiO1xyXG5jb25zdCBkZWZhdWx0RW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XHJcbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcclxufVxyXG5mdW5jdGlvbiBpc0J1dHRvbkVsZW1lbnQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xyXG59XHJcbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcclxufVxyXG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcclxuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcclxufVxyXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcclxuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XHJcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAoXHJcbiAgLy8gSWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXHJcbiAgIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiZcclxuICAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxyXG4gICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXHJcbiAgO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXHJcbiAqXHJcbiAqIFRoaXMgaXMgaWRlbnRpY2FsIHRvIGBuZXcgVVJMU2VhcmNoUGFyYW1zKGluaXQpYCBleGNlcHQgaXQgYWxzb1xyXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcclxuICogaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MuIFRoaXMgaXMgY29udmVuaWVudCB3aGVuIHlvdSBuZWVkIG11bHRpcGxlXHJcbiAqIHZhbHVlcyBmb3IgYSBnaXZlbiBrZXksIGJ1dCBkb24ndCB3YW50IHRvIHVzZSBhbiBhcnJheSBpbml0aWFsaXplci5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Y6XHJcbiAqXHJcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xyXG4gKiAgICAgWydzb3J0JywgJ25hbWUnXSxcclxuICogICAgIFsnc29ydCcsICdwcmljZSddXHJcbiAqICAgXSk7XHJcbiAqXHJcbiAqIHlvdSBjYW4gZG86XHJcbiAqXHJcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh7XHJcbiAqICAgICBzb3J0OiBbJ25hbWUnLCAncHJpY2UnXVxyXG4gKiAgIH0pO1xyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKGluaXQpIHtcclxuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XHJcbiAgICBpbml0ID0gXCJcIjtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXModHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShpbml0KSB8fCBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID8gaW5pdCA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XHJcbiAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XHJcbiAgICByZXR1cm4gbWVtby5jb25jYXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXSk7XHJcbiAgfSwgW10pKTtcclxufVxyXG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvblNlYXJjaCwgZGVmYXVsdFNlYXJjaFBhcmFtcykge1xyXG4gIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb25TZWFyY2gpO1xyXG4gIGlmIChkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XHJcbiAgICAvLyBVc2UgYGRlZmF1bHRTZWFyY2hQYXJhbXMuZm9yRWFjaCguLi4pYCBoZXJlIGluc3RlYWQgb2YgaXRlcmF0aW5nIG9mXHJcbiAgICAvLyBgZGVmYXVsdFNlYXJjaFBhcmFtcy5rZXlzKClgIHRvIHdvcmstYXJvdW5kIGEgYnVnIGluIEZpcmVmb3ggcmVsYXRlZCB0b1xyXG4gICAgLy8gd2ViIGV4dGVuc2lvbnMuIFJlbGV2YW50IEJ1Z3ppbGxhIHRpY2tldHM6XHJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDE0NjAyXHJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDIzOTg0XHJcbiAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIGtleSkgPT4ge1xyXG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xyXG4gICAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSkuZm9yRWFjaCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcclxufVxyXG4vLyBPbmUtdGltZSBjaGVjayBmb3Igc3VibWl0dGVyIHN1cHBvcnRcclxubGV0IF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gbnVsbDtcclxuZnVuY3Rpb24gaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpIHtcclxuICBpZiAoX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPT09IG51bGwpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIG5ldyBGb3JtRGF0YShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcclxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpZiBGb3JtRGF0YSBzdXBwb3J0cyB0aGUgc3VibWl0dGVyIHBhcmFtZXRlciwgdGhpcyB3aWxsIHRocm93XHJcbiAgICAgIDApO1xyXG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IGZhbHNlO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlcjtcclxufVxyXG5jb25zdCBzdXBwb3J0ZWRGb3JtRW5jVHlwZXMgPSBuZXcgU2V0KFtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgXCJ0ZXh0L3BsYWluXCJdKTtcclxuZnVuY3Rpb24gZ2V0Rm9ybUVuY1R5cGUoZW5jVHlwZSkge1xyXG4gIGlmIChlbmNUeXBlICE9IG51bGwgJiYgIXN1cHBvcnRlZEZvcm1FbmNUeXBlcy5oYXMoZW5jVHlwZSkpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIlxcXCJcIiArIGVuY1R5cGUgKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgYGVuY1R5cGVgIGZvciBgPEZvcm0+YC9gPGZldGNoZXIuRm9ybT5gIFwiICsgKFwiYW5kIHdpbGwgZGVmYXVsdCB0byBcXFwiXCIgKyBkZWZhdWx0RW5jVHlwZSArIFwiXFxcIlwiKSkgOiB2b2lkIDA7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGVuY1R5cGU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgYmFzZW5hbWUpIHtcclxuICBsZXQgbWV0aG9kO1xyXG4gIGxldCBhY3Rpb247XHJcbiAgbGV0IGVuY1R5cGU7XHJcbiAgbGV0IGZvcm1EYXRhO1xyXG4gIGxldCBib2R5O1xyXG4gIGlmIChpc0Zvcm1FbGVtZW50KHRhcmdldCkpIHtcclxuICAgIC8vIFdoZW4gZ3JhYmJpbmcgdGhlIGFjdGlvbiBmcm9tIHRoZSBlbGVtZW50LCBpdCB3aWxsIGhhdmUgaGFkIHRoZSBiYXNlbmFtZVxyXG4gICAgLy8gcHJlZml4ZWQgdG8gZW5zdXJlIG5vbi1KUyBzY2VuYXJpb3Mgd29yaywgc28gc3RyaXAgaXQgc2luY2Ugd2UnbGxcclxuICAgIC8vIHJlLXByZWZpeCBpbiB0aGUgcm91dGVyXHJcbiAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XHJcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xyXG4gICAgbWV0aG9kID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xyXG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcclxuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKHRhcmdldCk7XHJcbiAgfSBlbHNlIGlmIChpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmICh0YXJnZXQudHlwZSA9PT0gXCJzdWJtaXRcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJpbWFnZVwiKSkge1xyXG4gICAgbGV0IGZvcm0gPSB0YXJnZXQuZm9ybTtcclxuICAgIGlmIChmb3JtID09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiPiB3aXRob3V0IGEgPGZvcm0+XCIpO1xyXG4gICAgfVxyXG4gICAgLy8gPGJ1dHRvbj4vPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gbWF5IG92ZXJyaWRlIGF0dHJpYnV0ZXMgb2YgPGZvcm0+XHJcbiAgICAvLyBXaGVuIGdyYWJiaW5nIHRoZSBhY3Rpb24gZnJvbSB0aGUgZWxlbWVudCwgaXQgd2lsbCBoYXZlIGhhZCB0aGUgYmFzZW5hbWVcclxuICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXHJcbiAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxyXG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcclxuICAgIGFjdGlvbiA9IGF0dHIgPyBzdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XHJcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xyXG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSkgfHwgZ2V0Rm9ybUVuY1R5cGUoZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcclxuICAgIC8vIEJ1aWxkIGEgRm9ybURhdGEgb2JqZWN0IHBvcHVsYXRlZCBmcm9tIGEgZm9ybSBhbmQgc3VibWl0dGVyXHJcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtLCB0YXJnZXQpO1xyXG4gICAgLy8gSWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgYEZvcm1EYXRhKGVsLCBzdWJtaXR0ZXIpYCBmb3JtYXQsXHJcbiAgICAvLyB0aGVuIHRhY2sgb24gdGhlIHN1Ym1pdHRlciB2YWx1ZSBhdCB0aGUgZW5kLiAgVGhpcyBpcyBhIGxpZ2h0d2VpZ2h0XHJcbiAgICAvLyBzb2x1dGlvbiB0aGF0IGlzIG5vdCAxMDAlIHNwZWMgY29tcGxpYW50LiAgRm9yIGNvbXBsZXRlIHN1cHBvcnQgaW4gb2xkZXJcclxuICAgIC8vIGJyb3dzZXJzLCBjb25zaWRlciB1c2luZyB0aGUgYGZvcm1kYXRhLXN1Ym1pdHRlci1wb2x5ZmlsbGAgcGFja2FnZVxyXG4gICAgaWYgKCFpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkKCkpIHtcclxuICAgICAgbGV0IHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgdmFsdWVcclxuICAgICAgfSA9IHRhcmdldDtcclxuICAgICAgaWYgKHR5cGUgPT09IFwiaW1hZ2VcIikge1xyXG4gICAgICAgIGxldCBwcmVmaXggPSBuYW1lID8gbmFtZSArIFwiLlwiIDogXCJcIjtcclxuICAgICAgICBmb3JtRGF0YS5hcHBlbmQocHJlZml4ICsgXCJ4XCIsIFwiMFwiKTtcclxuICAgICAgICBmb3JtRGF0YS5hcHBlbmQocHJlZml4ICsgXCJ5XCIsIFwiMFwiKTtcclxuICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XHJcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3VibWl0IGVsZW1lbnQgdGhhdCBpcyBub3QgPGZvcm0+LCA8YnV0dG9uPiwgb3IgXCIgKyBcIjxpbnB1dCB0eXBlPVxcXCJzdWJtaXR8aW1hZ2VcXFwiPlwiKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZDtcclxuICAgIGFjdGlvbiA9IG51bGw7XHJcbiAgICBlbmNUeXBlID0gZGVmYXVsdEVuY1R5cGU7XHJcbiAgICBib2R5ID0gdGFyZ2V0O1xyXG4gIH1cclxuICAvLyBTZW5kIGJvZHkgZm9yIDxGb3JtIGVuY1R5cGU9XCJ0ZXh0L3BsYWluXCIgc28gd2UgZW5jb2RlIGl0IGludG8gdGV4dFxyXG4gIGlmIChmb3JtRGF0YSAmJiBlbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xyXG4gICAgYm9keSA9IGZvcm1EYXRhO1xyXG4gICAgZm9ybURhdGEgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBhY3Rpb24sXHJcbiAgICBtZXRob2Q6IG1ldGhvZC50b0xvd2VyQ2FzZSgpLFxyXG4gICAgZW5jVHlwZSxcclxuICAgIGZvcm1EYXRhLFxyXG4gICAgYm9keVxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IF9leGNsdWRlZCA9IFtcIm9uQ2xpY2tcIiwgXCJyZWxhdGl2ZVwiLCBcInJlbG9hZERvY3VtZW50XCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwidGFyZ2V0XCIsIFwidG9cIiwgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiwgXCJ2aWV3VHJhbnNpdGlvblwiXSxcclxuICBfZXhjbHVkZWQyID0gW1wiYXJpYS1jdXJyZW50XCIsIFwiY2FzZVNlbnNpdGl2ZVwiLCBcImNsYXNzTmFtZVwiLCBcImVuZFwiLCBcInN0eWxlXCIsIFwidG9cIiwgXCJ2aWV3VHJhbnNpdGlvblwiLCBcImNoaWxkcmVuXCJdLFxyXG4gIF9leGNsdWRlZDMgPSBbXCJmZXRjaGVyS2V5XCIsIFwibmF2aWdhdGVcIiwgXCJyZWxvYWREb2N1bWVudFwiLCBcInJlcGxhY2VcIiwgXCJzdGF0ZVwiLCBcIm1ldGhvZFwiLCBcImFjdGlvblwiLCBcIm9uU3VibWl0XCIsIFwicmVsYXRpdmVcIiwgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiwgXCJ2aWV3VHJhbnNpdGlvblwiXTtcclxuLy8gSEVZIFlPVSEgRE9OJ1QgVE9VQ0ggVEhJUyBWQVJJQUJMRSFcclxuLy9cclxuLy8gSXQgaXMgcmVwbGFjZWQgd2l0aCB0aGUgcHJvcGVyIHZlcnNpb24gYXQgYnVpbGQgdGltZSB2aWEgYSBiYWJlbCBwbHVnaW4gaW5cclxuLy8gdGhlIHJvbGx1cCBjb25maWcuXHJcbi8vXHJcbi8vIEV4cG9ydCBhIGdsb2JhbCBwcm9wZXJ0eSBvbnRvIHRoZSB3aW5kb3cgZm9yIFJlYWN0IFJvdXRlciBkZXRlY3Rpb24gYnkgdGhlXHJcbi8vIENvcmUgV2ViIFZpdGFscyBUZWNobm9sb2d5IFJlcG9ydC4gIFRoaXMgd2F5IHRoZXkgY2FuIGNvbmZpZ3VyZSB0aGUgYHdhcHBhbHl6ZXJgXHJcbi8vIHRvIGRldGVjdCBhbmQgcHJvcGVybHkgY2xhc3NpZnkgbGl2ZSB3ZWJzaXRlcyBhcyBiZWluZyBidWlsdCB3aXRoIFJlYWN0IFJvdXRlcjpcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0hUVFBBcmNoaXZlL3dhcHBhbHl6ZXIvYmxvYi9tYWluL3NyYy90ZWNobm9sb2dpZXMvci5qc29uXHJcbmNvbnN0IFJFQUNUX1JPVVRFUl9WRVJTSU9OID0gXCI2XCI7XHJcbnRyeSB7XHJcbiAgd2luZG93Ll9fcmVhY3RSb3V0ZXJWZXJzaW9uID0gUkVBQ1RfUk9VVEVSX1ZFUlNJT047XHJcbn0gY2F0Y2ggKGUpIHtcclxuICAvLyBuby1vcFxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIocm91dGVzLCBvcHRzKSB7XHJcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XHJcbiAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcclxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XHJcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxyXG4gICAgfSksXHJcbiAgICBoaXN0b3J5OiBjcmVhdGVCcm93c2VySGlzdG9yeSh7XHJcbiAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcclxuICAgIH0pLFxyXG4gICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXHJcbiAgICByb3V0ZXMsXHJcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsXHJcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZGF0YVN0cmF0ZWd5LFxyXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24sXHJcbiAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XHJcbiAgfSkuaW5pdGlhbGl6ZSgpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIocm91dGVzLCBvcHRzKSB7XHJcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XHJcbiAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcclxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XHJcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxyXG4gICAgfSksXHJcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7XHJcbiAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcclxuICAgIH0pLFxyXG4gICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXHJcbiAgICByb3V0ZXMsXHJcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsXHJcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZGF0YVN0cmF0ZWd5LFxyXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24sXHJcbiAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XHJcbiAgfSkuaW5pdGlhbGl6ZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcclxuICB2YXIgX3dpbmRvdztcclxuICBsZXQgc3RhdGUgPSAoX3dpbmRvdyA9IHdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3cuX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhO1xyXG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcclxuICAgIHN0YXRlID0gX2V4dGVuZHMoe30sIHN0YXRlLCB7XHJcbiAgICAgIGVycm9yczogZGVzZXJpYWxpemVFcnJvcnMoc3RhdGUuZXJyb3JzKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcclxuICBpZiAoIWVycm9ycykgcmV0dXJuIG51bGw7XHJcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xyXG4gIGxldCBzZXJpYWxpemVkID0ge307XHJcbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XHJcbiAgICAvLyBIZXkgeW91ISAgSWYgeW91IGNoYW5nZSB0aGlzLCBwbGVhc2UgY2hhbmdlIHRoZSBjb3JyZXNwb25kaW5nIGxvZ2ljIGluXHJcbiAgICAvLyBzZXJpYWxpemVFcnJvcnMgaW4gcmVhY3Qtcm91dGVyLWRvbS9zZXJ2ZXIudHN4IDopXHJcbiAgICBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiUm91dGVFcnJvclJlc3BvbnNlXCIpIHtcclxuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IFVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCh2YWwuc3RhdHVzLCB2YWwuc3RhdHVzVGV4dCwgdmFsLmRhdGEsIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcclxuICAgICAgLy8gQXR0ZW1wdCB0byByZWNvbnN0cnVjdCB0aGUgcmlnaHQgdHlwZSBvZiBFcnJvciAoaS5lLiwgUmVmZXJlbmNlRXJyb3IpXHJcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XHJcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSB3aW5kb3dbdmFsLl9fc3ViVHlwZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xyXG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBuby1vcCAtIGZhbGwgdGhyb3VnaCBhbmQgY3JlYXRlIGEgbm9ybWFsIEVycm9yXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcih2YWwubWVzc2FnZSk7XHJcbiAgICAgICAgLy8gV2lwZSBhd2F5IHRoZSBjbGllbnQtc2lkZSBzdGFjayB0cmFjZS4gIE5vdGhpbmcgdG8gZmlsbCBpdCBpbiB3aXRoXHJcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xyXG4gICAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcclxuICAgICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2VyaWFsaXplZDtcclxufVxyXG5jb25zdCBWaWV3VHJhbnNpdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XHJcbiAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxyXG59KTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIFZpZXdUcmFuc2l0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiVmlld1RyYW5zaXRpb25cIjtcclxufVxyXG5jb25zdCBGZXRjaGVyc0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChuZXcgTWFwKCkpO1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgRmV0Y2hlcnNDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJGZXRjaGVyc1wiO1xyXG59XHJcbi8vI2VuZHJlZ2lvblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyNyZWdpb24gQ29tcG9uZW50c1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vKipcclxuICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcclxuICBjb21wbGFpbnMgdGhhdCBgc3RhcnRUcmFuc2l0aW9uYCBkb2Vzbid0IGV4aXN0IGluIGBSZWFjdGA6XHJcbiAgKiBpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIlxyXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcclxuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXHJcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xyXG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxyXG5cclxuICBNb3ZpbmcgaXQgdG8gYSBjb25zdGFudCBzdWNoIGFzIHRoZSBmb2xsb3dpbmcgc29sdmVzIHRoZSBXZWJwYWNrL1JlYWN0IDE3IGlzc3VlOlxyXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcclxuICAgIGNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xyXG4gICAgU1RBUlRfVFJBTlNJVElPTiBpbiBSZWFjdCA/IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxyXG5cclxuICBIb3dldmVyLCB0aGF0IGludHJvZHVjZXMgd2VicGFjay90ZXJzZXIgbWluaWZpY2F0aW9uIGlzc3VlcyBpbiBwcm9kdWN0aW9uIGJ1aWxkc1xyXG4gIGluIFJlYWN0IDE4IHdoZXJlIG1pbmlmaWNhdGlvbi9vYmZ1c2NhdGlvbiBlbmRzIHVwIHJlbW92aW5nIHRoZSBjYWxsIG9mXHJcbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uIGVudGlyZWx5IGZyb20gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIHRlcm5hcnkuICBHcmFiYmluZ1xyXG4gIHRoaXMgZXhwb3J0ZWQgcmVmZXJlbmNlIG9uY2UgdXAgZnJvbnQgcmVzb2x2ZXMgdGhhdCBpc3N1ZS5cclxuXHJcbiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxyXG4qL1xyXG5jb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcclxuY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dO1xyXG5jb25zdCBGTFVTSF9TWU5DID0gXCJmbHVzaFN5bmNcIjtcclxuY29uc3QgZmx1c2hTeW5jSW1wbCA9IFJlYWN0RE9NW0ZMVVNIX1NZTkNdO1xyXG5jb25zdCBVU0VfSUQgPSBcInVzZUlkXCI7XHJcbmNvbnN0IHVzZUlkSW1wbCA9IFJlYWN0W1VTRV9JRF07XHJcbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvblNhZmUoY2IpIHtcclxuICBpZiAoc3RhcnRUcmFuc2l0aW9uSW1wbCkge1xyXG4gICAgc3RhcnRUcmFuc2l0aW9uSW1wbChjYik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNiKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGZsdXNoU3luY1NhZmUoY2IpIHtcclxuICBpZiAoZmx1c2hTeW5jSW1wbCkge1xyXG4gICAgZmx1c2hTeW5jSW1wbChjYik7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNiKCk7XHJcbiAgfVxyXG59XHJcbmNsYXNzIERlZmVycmVkIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuc3RhdHVzID0gXCJwZW5kaW5nXCI7XHJcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHZhbHVlID0+IHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XHJcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVzb2x2ZWRcIjtcclxuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy5yZWplY3QgPSByZWFzb24gPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcclxuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xyXG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIFJlbWl4IFJvdXRlciBpbnN0YW5jZSwgcmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBVSVxyXG4gKi9cclxuZnVuY3Rpb24gUm91dGVyUHJvdmlkZXIoX3JlZikge1xyXG4gIGxldCB7XHJcbiAgICBmYWxsYmFja0VsZW1lbnQsXHJcbiAgICByb3V0ZXIsXHJcbiAgICBmdXR1cmVcclxuICB9ID0gX3JlZjtcclxuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUocm91dGVyLnN0YXRlKTtcclxuICBsZXQgW3BlbmRpbmdTdGF0ZSwgc2V0UGVuZGluZ1N0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XHJcbiAgbGV0IFt2dENvbnRleHQsIHNldFZ0Q29udGV4dF0gPSBSZWFjdC51c2VTdGF0ZSh7XHJcbiAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXHJcbiAgfSk7XHJcbiAgbGV0IFtyZW5kZXJEZmQsIHNldFJlbmRlckRmZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xyXG4gIGxldCBbdHJhbnNpdGlvbiwgc2V0VHJhbnNpdGlvbl0gPSBSZWFjdC51c2VTdGF0ZSgpO1xyXG4gIGxldCBbaW50ZXJydXB0aW9uLCBzZXRJbnRlcnJ1cHRpb25dID0gUmVhY3QudXNlU3RhdGUoKTtcclxuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdC51c2VSZWYobmV3IE1hcCgpKTtcclxuICBsZXQge1xyXG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXHJcbiAgfSA9IGZ1dHVyZSB8fCB7fTtcclxuICBsZXQgb3B0SW5TdGFydFRyYW5zaXRpb24gPSBSZWFjdC51c2VDYWxsYmFjayhjYiA9PiB7XHJcbiAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uKSB7XHJcbiAgICAgIHN0YXJ0VHJhbnNpdGlvblNhZmUoY2IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2IoKTtcclxuICAgIH1cclxuICB9LCBbdjdfc3RhcnRUcmFuc2l0aW9uXSk7XHJcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKG5ld1N0YXRlLCBfcmVmMikgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgZGVsZXRlZEZldGNoZXJzLFxyXG4gICAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcclxuICAgICAgdmlld1RyYW5zaXRpb25PcHRzOiB2aWV3VHJhbnNpdGlvbk9wdHNcclxuICAgIH0gPSBfcmVmMjtcclxuICAgIGRlbGV0ZWRGZXRjaGVycy5mb3JFYWNoKGtleSA9PiBmZXRjaGVyRGF0YS5jdXJyZW50LmRlbGV0ZShrZXkpKTtcclxuICAgIG5ld1N0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xyXG4gICAgICBpZiAoZmV0Y2hlci5kYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBmZXRjaGVyRGF0YS5jdXJyZW50LnNldChrZXksIGZldGNoZXIuZGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgbGV0IGlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSA9IHJvdXRlci53aW5kb3cgPT0gbnVsbCB8fCByb3V0ZXIud2luZG93LmRvY3VtZW50ID09IG51bGwgfHwgdHlwZW9mIHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbiAhPT0gXCJmdW5jdGlvblwiO1xyXG4gICAgLy8gSWYgdGhpcyBpc24ndCBhIHZpZXcgdHJhbnNpdGlvbiBvciBpdCdzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBicm93c2VyLFxyXG4gICAgLy8ganVzdCB1cGRhdGUgYW5kIGJlIGRvbmUgd2l0aCBpdFxyXG4gICAgaWYgKCF2aWV3VHJhbnNpdGlvbk9wdHMgfHwgaXNWaWV3VHJhbnNpdGlvblVuYXZhaWxhYmxlKSB7XHJcbiAgICAgIGlmIChmbHVzaFN5bmMpIHtcclxuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9wdEluU3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGZsdXNoU3luYyArIHN0YXJ0Vmlld1RyYW5zaXRpb25cclxuICAgIGlmIChmbHVzaFN5bmMpIHtcclxuICAgICAgLy8gRmx1c2ggdGhyb3VnaCB0aGUgY29udGV4dCB0byBtYXJrIERPTSBlbGVtZW50cyBhcyB0cmFuc2l0aW9uPWluZ1xyXG4gICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcclxuICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNpdGlvbnNcclxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFZ0Q29udGV4dCh7XHJcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXHJcbiAgICAgICAgICBmbHVzaFN5bmM6IHRydWUsXHJcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5jdXJyZW50TG9jYXRpb24sXHJcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgRE9NXHJcbiAgICAgIGxldCB0ID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKCgpID0+IHtcclxuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xyXG4gICAgICB9KTtcclxuICAgICAgLy8gQ2xlYW4gdXAgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcclxuICAgICAgdC5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICBmbHVzaFN5bmNTYWZlKCgpID0+IHtcclxuICAgICAgICAgIHNldFJlbmRlckRmZCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgc2V0VHJhbnNpdGlvbih1bmRlZmluZWQpO1xyXG4gICAgICAgICAgc2V0UGVuZGluZ1N0YXRlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICBzZXRWdENvbnRleHQoe1xyXG4gICAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4gc2V0VHJhbnNpdGlvbih0KSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHN0YXJ0VHJhbnNpdGlvbiArIHN0YXJ0Vmlld1RyYW5zaXRpb25cclxuICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgIC8vIEludGVycnVwdGluZyBhbiBpbi1wcm9ncmVzcyB0cmFuc2l0aW9uLCBjYW5jZWwgYW5kIGxldCBldmVyeXRoaW5nIGZsdXNoXHJcbiAgICAgIC8vIG91dCwgYW5kIHRoZW4ga2ljayBvZmYgYSBuZXcgdHJhbnNpdGlvbiBmcm9tIHRoZSBpbnRlcnJ1cHRpb24gc3RhdGVcclxuICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XHJcbiAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcclxuICAgICAgc2V0SW50ZXJydXB0aW9uKHtcclxuICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXHJcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxyXG4gICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIENvbXBsZXRlZCBuYXZpZ2F0aW9uIHVwZGF0ZSB3aXRoIG9wdGVkLWluIHZpZXcgdHJhbnNpdGlvbnMsIGxldCAnZXIgcmlwXHJcbiAgICAgIHNldFBlbmRpbmdTdGF0ZShuZXdTdGF0ZSk7XHJcbiAgICAgIHNldFZ0Q29udGV4dCh7XHJcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxyXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXHJcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxyXG4gICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCBbcm91dGVyLndpbmRvdywgdHJhbnNpdGlvbiwgcmVuZGVyRGZkLCBmZXRjaGVyRGF0YSwgb3B0SW5TdGFydFRyYW5zaXRpb25dKTtcclxuICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cclxuICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXHJcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xyXG4gIC8vIFdoZW4gd2Ugc3RhcnQgYSB2aWV3IHRyYW5zaXRpb24sIGNyZWF0ZSBhIERlZmVycmVkIHdlIGNhbiB1c2UgZm9yIHRoZVxyXG4gIC8vIGV2ZW50dWFsIFwiY29tcGxldGVkXCIgcmVuZGVyXHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICh2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmICF2dENvbnRleHQuZmx1c2hTeW5jKSB7XHJcbiAgICAgIHNldFJlbmRlckRmZChuZXcgRGVmZXJyZWQoKSk7XHJcbiAgICB9XHJcbiAgfSwgW3Z0Q29udGV4dF0pO1xyXG4gIC8vIE9uY2UgdGhlIGRlZmVycmVkIGlzIGNyZWF0ZWQsIGtpY2sgb2ZmIHN0YXJ0Vmlld1RyYW5zaXRpb24oKSB0byB1cGRhdGUgdGhlXHJcbiAgLy8gRE9NIGFuZCB0aGVuIHdhaXQgb24gdGhlIERlZmVycmVkIHRvIHJlc29sdmUgKGluZGljYXRpbmcgdGhlIERPTSB1cGRhdGUgaGFzXHJcbiAgLy8gaGFwcGVuZWQpXHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHJvdXRlci53aW5kb3cpIHtcclxuICAgICAgbGV0IG5ld1N0YXRlID0gcGVuZGluZ1N0YXRlO1xyXG4gICAgICBsZXQgcmVuZGVyUHJvbWlzZSA9IHJlbmRlckRmZC5wcm9taXNlO1xyXG4gICAgICBsZXQgdHJhbnNpdGlvbiA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgb3B0SW5TdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XHJcbiAgICAgICAgYXdhaXQgcmVuZGVyUHJvbWlzZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRyYW5zaXRpb24uZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgc2V0UmVuZGVyRGZkKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgc2V0VHJhbnNpdGlvbih1bmRlZmluZWQpO1xyXG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgIHNldFZ0Q29udGV4dCh7XHJcbiAgICAgICAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xyXG4gICAgfVxyXG4gIH0sIFtvcHRJblN0YXJ0VHJhbnNpdGlvbiwgcGVuZGluZ1N0YXRlLCByZW5kZXJEZmQsIHJvdXRlci53aW5kb3ddKTtcclxuICAvLyBXaGVuIHRoZSBuZXcgbG9jYXRpb24gZmluYWxseSByZW5kZXJzIGFuZCBpcyBjb21taXR0ZWQgdG8gdGhlIERPTSwgdGhpc1xyXG4gIC8vIGVmZmVjdCB3aWxsIHJ1biB0byByZXNvbHZlIHRoZSB0cmFuc2l0aW9uXHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChyZW5kZXJEZmQgJiYgcGVuZGluZ1N0YXRlICYmIHN0YXRlLmxvY2F0aW9uLmtleSA9PT0gcGVuZGluZ1N0YXRlLmxvY2F0aW9uLmtleSkge1xyXG4gICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gIH0sIFtyZW5kZXJEZmQsIHRyYW5zaXRpb24sIHN0YXRlLmxvY2F0aW9uLCBwZW5kaW5nU3RhdGVdKTtcclxuICAvLyBJZiB3ZSBnZXQgaW50ZXJydXB0ZWQgd2l0aCBhIG5ldyBuYXZpZ2F0aW9uIGR1cmluZyBhIHRyYW5zaXRpb24sIHdlIHNraXBcclxuICAvLyB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGxldCBpdCBjbGVhbnVwLCB0aGVuIGtpY2sgaXQgb2ZmIGFnYWluIGhlcmVcclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmIGludGVycnVwdGlvbikge1xyXG4gICAgICBzZXRQZW5kaW5nU3RhdGUoaW50ZXJydXB0aW9uLnN0YXRlKTtcclxuICAgICAgc2V0VnRDb250ZXh0KHtcclxuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXHJcbiAgICAgICAgZmx1c2hTeW5jOiBmYWxzZSxcclxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGludGVycnVwdGlvbi5jdXJyZW50TG9jYXRpb24sXHJcbiAgICAgICAgbmV4dExvY2F0aW9uOiBpbnRlcnJ1cHRpb24ubmV4dExvY2F0aW9uXHJcbiAgICAgIH0pO1xyXG4gICAgICBzZXRJbnRlcnJ1cHRpb24odW5kZWZpbmVkKTtcclxuICAgIH1cclxuICB9LCBbdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZywgaW50ZXJydXB0aW9uXSk7XHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbGxiYWNrRWxlbWVudCA9PSBudWxsIHx8ICFyb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24sIFwiYDxSb3V0ZXJQcm92aWRlciBmYWxsYmFja0VsZW1lbnQ+YCBpcyBkZXByZWNhdGVkIHdoZW4gdXNpbmcgXCIgKyBcImB2N19wYXJ0aWFsSHlkcmF0aW9uYCwgdXNlIGEgYEh5ZHJhdGVGYWxsYmFja2AgY29tcG9uZW50IGluc3RlYWRcIikgOiB2b2lkIDA7XHJcbiAgICAvLyBPbmx5IGxvZyB0aGlzIG9uY2Ugb24gaW5pdGlhbCBtb3VudFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gIH0sIFtdKTtcclxuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjcmVhdGVIcmVmOiByb3V0ZXIuY3JlYXRlSHJlZixcclxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcclxuICAgICAgZ286IG4gPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxyXG4gICAgICBwdXNoOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XHJcbiAgICAgIH0pLFxyXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcclxuICAgICAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgICAgIHN0YXRlLFxyXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcclxuICAgICAgfSlcclxuICAgIH07XHJcbiAgfSwgW3JvdXRlcl0pO1xyXG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcclxuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XHJcbiAgICByb3V0ZXIsXHJcbiAgICBuYXZpZ2F0b3IsXHJcbiAgICBzdGF0aWM6IGZhbHNlLFxyXG4gICAgYmFzZW5hbWVcclxuICB9KSwgW3JvdXRlciwgbmF2aWdhdG9yLCBiYXNlbmFtZV0pO1xyXG4gIGxldCByb3V0ZXJGdXR1cmUgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XHJcbiAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogcm91dGVyLmZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aFxyXG4gIH0pLCBbcm91dGVyLmZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aF0pO1xyXG4gIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcclxuICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxyXG4gIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxyXG4gIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xyXG4gIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxyXG4gIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XHJcbiAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcclxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgdmFsdWU6IHN0YXRlXHJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7XHJcbiAgICB2YWx1ZTogZmV0Y2hlckRhdGEuY3VycmVudFxyXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpZXdUcmFuc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgdmFsdWU6IHZ0Q29udGV4dFxyXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xyXG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxyXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxyXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmhpc3RvcnlBY3Rpb24sXHJcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcclxuICAgIGZ1dHVyZTogcm91dGVyRnV0dXJlXHJcbiAgfSwgc3RhdGUuaW5pdGlhbGl6ZWQgfHwgcm91dGVyLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWREYXRhUm91dGVzLCB7XHJcbiAgICByb3V0ZXM6IHJvdXRlci5yb3V0ZXMsXHJcbiAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXHJcbiAgICBzdGF0ZTogc3RhdGVcclxuICB9KSA6IGZhbGxiYWNrRWxlbWVudCkpKSkpLCBudWxsKTtcclxufVxyXG4vLyBNZW1vaXplIHRvIGF2b2lkIHJlLXJlbmRlcnMgd2hlbiB1cGRhdGluZyBgVmlld1RyYW5zaXRpb25Db250ZXh0YFxyXG5jb25zdCBNZW1vaXplZERhdGFSb3V0ZXMgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhEYXRhUm91dGVzKTtcclxuZnVuY3Rpb24gRGF0YVJvdXRlcyhfcmVmMykge1xyXG4gIGxldCB7XHJcbiAgICByb3V0ZXMsXHJcbiAgICBmdXR1cmUsXHJcbiAgICBzdGF0ZVxyXG4gIH0gPSBfcmVmMztcclxuICByZXR1cm4gVU5TQUZFX3VzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlLCBmdXR1cmUpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxyXG4gKi9cclxuZnVuY3Rpb24gQnJvd3NlclJvdXRlcihfcmVmNCkge1xyXG4gIGxldCB7XHJcbiAgICBiYXNlbmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgZnV0dXJlLFxyXG4gICAgd2luZG93XHJcbiAgfSA9IF9yZWY0O1xyXG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKCk7XHJcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XHJcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVCcm93c2VySGlzdG9yeSh7XHJcbiAgICAgIHdpbmRvdyxcclxuICAgICAgdjVDb21wYXQ6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcclxuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xyXG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcclxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXHJcbiAgfSk7XHJcbiAgbGV0IHtcclxuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxyXG4gIH0gPSBmdXR1cmUgfHwge307XHJcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xyXG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcclxuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcclxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XHJcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXHJcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXHJcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXHJcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxyXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxyXG4gICAgZnV0dXJlOiBmdXR1cmVcclxuICB9KTtcclxufVxyXG4vKipcclxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBTdG9yZXMgdGhlIGxvY2F0aW9uIGluIHRoZSBoYXNoXHJcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gSGFzaFJvdXRlcihfcmVmNSkge1xyXG4gIGxldCB7XHJcbiAgICBiYXNlbmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgZnV0dXJlLFxyXG4gICAgd2luZG93XHJcbiAgfSA9IF9yZWY1O1xyXG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmKCk7XHJcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XHJcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7XHJcbiAgICAgIHdpbmRvdyxcclxuICAgICAgdjVDb21wYXQ6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcclxuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xyXG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcclxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXHJcbiAgfSk7XHJcbiAgbGV0IHtcclxuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxyXG4gIH0gPSBmdXR1cmUgfHwge307XHJcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xyXG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcclxuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcclxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeSwgc2V0U3RhdGVdKTtcclxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XHJcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXHJcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXHJcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXHJcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxyXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5LFxyXG4gICAgZnV0dXJlOiBmdXR1cmVcclxuICB9KTtcclxufVxyXG4vKipcclxuICogQSBgPFJvdXRlcj5gIHRoYXQgYWNjZXB0cyBhIHByZS1pbnN0YW50aWF0ZWQgaGlzdG9yeSBvYmplY3QuIEl0J3MgaW1wb3J0YW50XHJcbiAqIHRvIG5vdGUgdGhhdCB1c2luZyB5b3VyIG93biBoaXN0b3J5IG9iamVjdCBpcyBoaWdobHkgZGlzY291cmFnZWQgYW5kIG1heSBhZGRcclxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXHJcbiAqIHZlcnNpb24gb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0aGF0IFJlYWN0IFJvdXRlciB1c2VzIGludGVybmFsbHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKF9yZWY2KSB7XHJcbiAgbGV0IHtcclxuICAgIGJhc2VuYW1lLFxyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBmdXR1cmUsXHJcbiAgICBoaXN0b3J5XHJcbiAgfSA9IF9yZWY2O1xyXG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XHJcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxyXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cclxuICB9KTtcclxuICBsZXQge1xyXG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXHJcbiAgfSA9IGZ1dHVyZSB8fCB7fTtcclxuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XHJcbiAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xyXG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xyXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcclxuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcclxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcclxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXHJcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnksXHJcbiAgICBmdXR1cmU6IGZ1dHVyZVxyXG4gIH0pO1xyXG59XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICBIaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XHJcbn1cclxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcclxuY29uc3QgQUJTT0xVVEVfVVJMX1JFR0VYID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xyXG4vKipcclxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgYDxhPmAuXHJcbiAqL1xyXG5jb25zdCBMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua1dpdGhSZWYoX3JlZjcsIHJlZikge1xyXG4gIGxldCB7XHJcbiAgICAgIG9uQ2xpY2ssXHJcbiAgICAgIHJlbGF0aXZlLFxyXG4gICAgICByZWxvYWREb2N1bWVudCxcclxuICAgICAgcmVwbGFjZSxcclxuICAgICAgc3RhdGUsXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgdG8sXHJcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcclxuICAgICAgdmlld1RyYW5zaXRpb25cclxuICAgIH0gPSBfcmVmNyxcclxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNywgX2V4Y2x1ZGVkKTtcclxuICBsZXQge1xyXG4gICAgYmFzZW5hbWVcclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xyXG4gIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIGFic29sdXRlIFVSTHNcclxuICBsZXQgYWJzb2x1dGVIcmVmO1xyXG4gIGxldCBpc0V4dGVybmFsID0gZmFsc2U7XHJcbiAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh0bykpIHtcclxuICAgIC8vIFJlbmRlciB0aGUgYWJzb2x1dGUgaHJlZiBzZXJ2ZXItIGFuZCBjbGllbnQtc2lkZVxyXG4gICAgYWJzb2x1dGVIcmVmID0gdG87XHJcbiAgICAvLyBPbmx5IGNoZWNrIGZvciBleHRlcm5hbCBvcmlnaW5zIGNsaWVudC1zaWRlXHJcbiAgICBpZiAoaXNCcm93c2VyKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcclxuICAgICAgICBsZXQgdGFyZ2V0VXJsID0gdG8uc3RhcnRzV2l0aChcIi8vXCIpID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgdG8pIDogbmV3IFVSTCh0byk7XHJcbiAgICAgICAgbGV0IHBhdGggPSBzdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xyXG4gICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcclxuICAgICAgICAgIC8vIFN0cmlwIHRoZSBwcm90b2NvbC9vcmlnaW4vYmFzZW5hbWUgZm9yIHNhbWUtb3JpZ2luIGFic29sdXRlIFVSTHNcclxuICAgICAgICAgIHRvID0gcGF0aCArIHRhcmdldFVybC5zZWFyY2ggKyB0YXJnZXRVcmwuaGFzaDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaXNFeHRlcm5hbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gV2UgY2FuJ3QgZG8gZXh0ZXJuYWwgVVJMIGRldGVjdGlvbiB3aXRob3V0IGEgdmFsaWQgVVJMXHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiPExpbmsgdG89XFxcIlwiICsgdG8gKyBcIlxcXCI+IGNvbnRhaW5zIGFuIGludmFsaWQgVVJMIHdoaWNoIHdpbGwgcHJvYmFibHkgYnJlYWsgXCIgKyBcIndoZW4gY2xpY2tlZCAtIHBsZWFzZSB1cGRhdGUgdG8gYSB2YWxpZCBVUkwgcGF0aC5cIikgOiB2b2lkIDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgcmVsYXRpdmUgVVJMc1xyXG4gIGxldCBocmVmID0gdXNlSHJlZih0bywge1xyXG4gICAgcmVsYXRpdmVcclxuICB9KTtcclxuICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywge1xyXG4gICAgcmVwbGFjZSxcclxuICAgIHN0YXRlLFxyXG4gICAgdGFyZ2V0LFxyXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxyXG4gICAgcmVsYXRpdmUsXHJcbiAgICB2aWV3VHJhbnNpdGlvblxyXG4gIH0pO1xyXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcbiAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XHJcbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIChcclxuICAgIC8qI19fUFVSRV9fKi9cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcclxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XHJcbiAgICAgIGhyZWY6IGFic29sdXRlSHJlZiB8fCBocmVmLFxyXG4gICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxyXG4gICAgICByZWY6IHJlZixcclxuICAgICAgdGFyZ2V0OiB0YXJnZXRcclxuICAgIH0pKVxyXG4gICk7XHJcbn0pO1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xyXG59XHJcbi8qKlxyXG4gKiBBIGA8TGluaz5gIHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxyXG4gKi9cclxuY29uc3QgTmF2TGluayA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKF9yZWY4LCByZWYpIHtcclxuICBsZXQge1xyXG4gICAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcclxuICAgICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxyXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxyXG4gICAgICBlbmQgPSBmYWxzZSxcclxuICAgICAgc3R5bGU6IHN0eWxlUHJvcCxcclxuICAgICAgdG8sXHJcbiAgICAgIHZpZXdUcmFuc2l0aW9uLFxyXG4gICAgICBjaGlsZHJlblxyXG4gICAgfSA9IF9yZWY4LFxyXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY4LCBfZXhjbHVkZWQyKTtcclxuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xyXG4gICAgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmVcclxuICB9KTtcclxuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xyXG4gIGxldCByb3V0ZXJTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xyXG4gIGxldCB7XHJcbiAgICBuYXZpZ2F0b3IsXHJcbiAgICBiYXNlbmFtZVxyXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XHJcbiAgbGV0IGlzVHJhbnNpdGlvbmluZyA9IHJvdXRlclN0YXRlICE9IG51bGwgJiZcclxuICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXHJcbiAgdXNlVmlld1RyYW5zaXRpb25TdGF0ZShwYXRoKSAmJiB2aWV3VHJhbnNpdGlvbiA9PT0gdHJ1ZTtcclxuICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZSA6IHBhdGgucGF0aG5hbWU7XHJcbiAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcclxuICBsZXQgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSByb3V0ZXJTdGF0ZSAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gPyByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLnBhdGhuYW1lIDogbnVsbDtcclxuICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcclxuICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IG5leHRMb2NhdGlvblBhdGhuYW1lID8gbmV4dExvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XHJcbiAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gIH1cclxuICBpZiAobmV4dExvY2F0aW9uUGF0aG5hbWUgJiYgYmFzZW5hbWUpIHtcclxuICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShuZXh0TG9jYXRpb25QYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvblBhdGhuYW1lO1xyXG4gIH1cclxuICAvLyBJZiB0aGUgYHRvYCBoYXMgYSB0cmFpbGluZyBzbGFzaCwgbG9vayBhdCB0aGF0IGV4YWN0IHNwb3QuICBPdGhlcndpc2UsXHJcbiAgLy8gd2UncmUgbG9va2luZyBmb3IgYSBzbGFzaCBfYWZ0ZXJfIHdoYXQncyBpbiBgdG9gLiAgRm9yIGV4YW1wbGU6XHJcbiAgLy9cclxuICAvLyA8TmF2TGluayB0bz1cIi91c2Vyc1wiPiBhbmQgPE5hdkxpbmsgdG89XCIvdXNlcnMvXCI+XHJcbiAgLy8gYm90aCB3YW50IHRvIGxvb2sgZm9yIGEgLyBhdCBpbmRleCA2IHRvIG1hdGNoIFVSTCBgL3VzZXJzL21hdHRgXHJcbiAgY29uc3QgZW5kU2xhc2hQb3NpdGlvbiA9IHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpID8gdG9QYXRobmFtZS5sZW5ndGggLSAxIDogdG9QYXRobmFtZS5sZW5ndGg7XHJcbiAgbGV0IGlzQWN0aXZlID0gbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdChlbmRTbGFzaFBvc2l0aW9uKSA9PT0gXCIvXCI7XHJcbiAgbGV0IGlzUGVuZGluZyA9IG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiYgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XHJcbiAgbGV0IHJlbmRlclByb3BzID0ge1xyXG4gICAgaXNBY3RpdmUsXHJcbiAgICBpc1BlbmRpbmcsXHJcbiAgICBpc1RyYW5zaXRpb25pbmdcclxuICB9O1xyXG4gIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xyXG4gIGxldCBjbGFzc05hbWU7XHJcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AocmVuZGVyUHJvcHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcclxuICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcclxuICAgIC8vIHZhbHVlIGZvciBgYWN0aXZlQ2xhc3NOYW1lYCwgYnV0IHdlIGFyZSByZW1vdmluZyB0aGF0IEFQSSBhbmQgY2FuIHN0aWxsXHJcbiAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxyXG4gICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cclxuICAgIGNsYXNzTmFtZSA9IFtjbGFzc05hbWVQcm9wLCBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsLCBpc1BlbmRpbmcgPyBcInBlbmRpbmdcIiA6IG51bGwsIGlzVHJhbnNpdGlvbmluZyA/IFwidHJhbnNpdGlvbmluZ1wiIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xyXG4gIH1cclxuICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AocmVuZGVyUHJvcHMpIDogc3R5bGVQcm9wO1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xyXG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnQsXHJcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcclxuICAgIHJlZjogcmVmLFxyXG4gICAgc3R5bGU6IHN0eWxlLFxyXG4gICAgdG86IHRvLFxyXG4gICAgdmlld1RyYW5zaXRpb246IHZpZXdUcmFuc2l0aW9uXHJcbiAgfSksIHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4ocmVuZGVyUHJvcHMpIDogY2hpbGRyZW4pO1xyXG59KTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcclxufVxyXG4vKipcclxuICogQSBgQHJlbWl4LXJ1bi9yb3V0ZXJgLWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHRcclxuICogdGhhdCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2VydmVyIGlzIHdpdGggYGZldGNoYCBpbnN0ZWFkIG9mIG5ldyBkb2N1bWVudFxyXG4gKiByZXF1ZXN0cywgYWxsb3dpbmcgY29tcG9uZW50cyB0byBhZGQgbmljZXIgVVggdG8gdGhlIHBhZ2UgYXMgdGhlIGZvcm0gaXNcclxuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cclxuICovXHJcbmNvbnN0IEZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoX3JlZjksIGZvcndhcmRlZFJlZikgPT4ge1xyXG4gIGxldCB7XHJcbiAgICAgIGZldGNoZXJLZXksXHJcbiAgICAgIG5hdmlnYXRlLFxyXG4gICAgICByZWxvYWREb2N1bWVudCxcclxuICAgICAgcmVwbGFjZSxcclxuICAgICAgc3RhdGUsXHJcbiAgICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QsXHJcbiAgICAgIGFjdGlvbixcclxuICAgICAgb25TdWJtaXQsXHJcbiAgICAgIHJlbGF0aXZlLFxyXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXHJcbiAgICAgIHZpZXdUcmFuc2l0aW9uXHJcbiAgICB9ID0gX3JlZjksXHJcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY5LCBfZXhjbHVkZWQzKTtcclxuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0KCk7XHJcbiAgbGV0IGZvcm1BY3Rpb24gPSB1c2VGb3JtQWN0aW9uKGFjdGlvbiwge1xyXG4gICAgcmVsYXRpdmVcclxuICB9KTtcclxuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xyXG4gIGxldCBzdWJtaXRIYW5kbGVyID0gZXZlbnQgPT4ge1xyXG4gICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xyXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBsZXQgc3VibWl0dGVyID0gZXZlbnQubmF0aXZlRXZlbnQuc3VibWl0dGVyO1xyXG4gICAgbGV0IHN1Ym1pdE1ldGhvZCA9IChzdWJtaXR0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHN1Ym1pdHRlci5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpKSB8fCBtZXRob2Q7XHJcbiAgICBzdWJtaXQoc3VibWl0dGVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcclxuICAgICAgZmV0Y2hlcktleSxcclxuICAgICAgbWV0aG9kOiBzdWJtaXRNZXRob2QsXHJcbiAgICAgIG5hdmlnYXRlLFxyXG4gICAgICByZXBsYWNlLFxyXG4gICAgICBzdGF0ZSxcclxuICAgICAgcmVsYXRpdmUsXHJcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcclxuICAgICAgdmlld1RyYW5zaXRpb25cclxuICAgIH0pO1xyXG4gIH07XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XHJcbiAgICByZWY6IGZvcndhcmRlZFJlZixcclxuICAgIG1ldGhvZDogZm9ybU1ldGhvZCxcclxuICAgIGFjdGlvbjogZm9ybUFjdGlvbixcclxuICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlclxyXG4gIH0sIHByb3BzKSk7XHJcbn0pO1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgRm9ybS5kaXNwbGF5TmFtZSA9IFwiRm9ybVwiO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIGVtdWxhdGUgdGhlIGJyb3dzZXIncyBzY3JvbGwgcmVzdG9yYXRpb24gb24gbG9jYXRpb25cclxuICogY2hhbmdlcy5cclxuICovXHJcbmZ1bmN0aW9uIFNjcm9sbFJlc3RvcmF0aW9uKF9yZWYxMCkge1xyXG4gIGxldCB7XHJcbiAgICBnZXRLZXksXHJcbiAgICBzdG9yYWdlS2V5XHJcbiAgfSA9IF9yZWYxMDtcclxuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XHJcbiAgICBnZXRLZXksXHJcbiAgICBzdG9yYWdlS2V5XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIFNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xyXG59XHJcbi8vI2VuZHJlZ2lvblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyNyZWdpb24gSG9va3NcclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxudmFyIERhdGFSb3V0ZXJIb29rO1xyXG4oZnVuY3Rpb24gKERhdGFSb3V0ZXJIb29rKSB7XHJcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VTY3JvbGxSZXN0b3JhdGlvblwiXSA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIjtcclxuICBEYXRhUm91dGVySG9va1tcIlVzZVN1Ym1pdFwiXSA9IFwidXNlU3VibWl0XCI7XHJcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VTdWJtaXRGZXRjaGVyXCJdID0gXCJ1c2VTdWJtaXRGZXRjaGVyXCI7XHJcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VGZXRjaGVyXCJdID0gXCJ1c2VGZXRjaGVyXCI7XHJcbiAgRGF0YVJvdXRlckhvb2tbXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCJdID0gXCJ1c2VWaWV3VHJhbnNpdGlvblN0YXRlXCI7XHJcbn0pKERhdGFSb3V0ZXJIb29rIHx8IChEYXRhUm91dGVySG9vayA9IHt9KSk7XHJcbnZhciBEYXRhUm91dGVyU3RhdGVIb29rO1xyXG4oZnVuY3Rpb24gKERhdGFSb3V0ZXJTdGF0ZUhvb2spIHtcclxuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlRmV0Y2hlclwiXSA9IFwidXNlRmV0Y2hlclwiO1xyXG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VGZXRjaGVyc1wiXSA9IFwidXNlRmV0Y2hlcnNcIjtcclxuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlU2Nyb2xsUmVzdG9yYXRpb25cIl0gPSBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCI7XHJcbn0pKERhdGFSb3V0ZXJTdGF0ZUhvb2sgfHwgKERhdGFSb3V0ZXJTdGF0ZUhvb2sgPSB7fSkpO1xyXG4vLyBJbnRlcm5hbCBob29rc1xyXG5mdW5jdGlvbiBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSB7XHJcbiAgcmV0dXJuIGhvb2tOYW1lICsgXCIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5cIjtcclxufVxyXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyQ29udGV4dChob29rTmFtZSkge1xyXG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCk7XHJcbiAgIWN0eCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHJldHVybiBjdHg7XHJcbn1cclxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lKSB7XHJcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XHJcbiAgIXN0YXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbi8vIEV4dGVybmFsIGhvb2tzXHJcbi8qKlxyXG4gKiBIYW5kbGVzIHRoZSBjbGljayBiZWhhdmlvciBmb3Igcm91dGVyIGA8TGluaz5gIGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmXHJcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXHJcbiAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCBfdGVtcCkge1xyXG4gIGxldCB7XHJcbiAgICB0YXJnZXQsXHJcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcclxuICAgIHN0YXRlLFxyXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxyXG4gICAgcmVsYXRpdmUsXHJcbiAgICB2aWV3VHJhbnNpdGlvblxyXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcclxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xyXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XHJcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcclxuICAgIHJlbGF0aXZlXHJcbiAgfSk7XHJcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcclxuICAgIGlmIChzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIC8vIElmIHRoZSBVUkwgaGFzbid0IGNoYW5nZWQsIGEgcmVndWxhciA8YT4gd2lsbCBkbyBhIHJlcGxhY2UgaW5zdGVhZCBvZlxyXG4gICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUgdW5sZXNzIHRoZSByZXBsYWNlIHByb3AgaXMgZXhwbGljaXRseSBzZXRcclxuICAgICAgbGV0IHJlcGxhY2UgPSByZXBsYWNlUHJvcCAhPT0gdW5kZWZpbmVkID8gcmVwbGFjZVByb3AgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcclxuICAgICAgbmF2aWdhdGUodG8sIHtcclxuICAgICAgICByZXBsYWNlLFxyXG4gICAgICAgIHN0YXRlLFxyXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcclxuICAgICAgICByZWxhdGl2ZSxcclxuICAgICAgICB2aWV3VHJhbnNpdGlvblxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCBbbG9jYXRpb24sIG5hdmlnYXRlLCBwYXRoLCByZXBsYWNlUHJvcCwgc3RhdGUsIHRhcmdldCwgdG8sIHByZXZlbnRTY3JvbGxSZXNldCwgcmVsYXRpdmUsIHZpZXdUcmFuc2l0aW9uXSk7XHJcbn1cclxuLyoqXHJcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcclxuICogVVJMU2VhcmNoUGFyYW1zIGludGVyZmFjZS5cclxuICovXHJcbmZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkge1xyXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09IFwidW5kZWZpbmVkXCIsIFwiWW91IGNhbm5vdCB1c2UgdGhlIGB1c2VTZWFyY2hQYXJhbXNgIGhvb2sgaW4gYSBicm93c2VyIHRoYXQgZG9lcyBub3QgXCIgKyBcInN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgXCIgKyBcIkV4cGxvcmVyIDExLCB3ZSByZWNvbW1lbmQgeW91IGxvYWQgYSBwb2x5ZmlsbCBzdWNoIGFzIFwiICsgXCJodHRwczovL2dpdGh1Yi5jb20vdW5nYXAvdXJsLXNlYXJjaC1wYXJhbXMuXCIpIDogdm9pZCAwO1xyXG4gIGxldCBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xyXG4gIGxldCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xyXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XHJcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT5cclxuICAvLyBPbmx5IG1lcmdlIGluIHRoZSBkZWZhdWx0cyBpZiB3ZSBoYXZlbid0IHlldCBjYWxsZWQgc2V0U2VhcmNoUGFyYW1zLlxyXG4gIC8vIE9uY2Ugd2UgY2FsbCB0aGF0IHdlIHdhbnQgdGhvc2UgdG8gdGFrZSBwcmVjZWRlbmNlLCBvdGhlcndpc2UgeW91IGNhbid0XHJcbiAgLy8gcmVtb3ZlIGEgcGFyYW0gd2l0aCBzZXRTZWFyY2hQYXJhbXMoe30pIGlmIGl0IGhhcyBhbiBpbml0aWFsIHZhbHVlXHJcbiAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24obG9jYXRpb24uc2VhcmNoLCBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA/IG51bGwgOiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQpLCBbbG9jYXRpb24uc2VhcmNoXSk7XHJcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcclxuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QudXNlQ2FsbGJhY2soKG5leHRJbml0LCBuYXZpZ2F0ZU9wdGlvbnMpID0+IHtcclxuICAgIGNvbnN0IG5ld1NlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdCk7XHJcbiAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICBuYXZpZ2F0ZShcIj9cIiArIG5ld1NlYXJjaFBhcmFtcywgbmF2aWdhdGVPcHRpb25zKTtcclxuICB9LCBbbmF2aWdhdGUsIHNlYXJjaFBhcmFtc10pO1xyXG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKSB7XHJcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGFyZSBjYWxsaW5nIHN1Ym1pdCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIuIFwiICsgXCJUcnkgY2FsbGluZyBzdWJtaXQgd2l0aGluIGEgYHVzZUVmZmVjdGAgb3IgY2FsbGJhY2sgaW5zdGVhZC5cIik7XHJcbiAgfVxyXG59XHJcbmxldCBmZXRjaGVySWQgPSAwO1xyXG5sZXQgZ2V0VW5pcXVlRmV0Y2hlcklkID0gKCkgPT4gXCJfX1wiICsgU3RyaW5nKCsrZmV0Y2hlcklkKSArIFwiX19cIjtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgc3VibWl0IGEgZm9ybSAob3JcclxuICogc29tZSBhcmJpdHJhcnkgZGF0YSkgdG8gdGhlIHNlcnZlci5cclxuICovXHJcbmZ1bmN0aW9uIHVzZVN1Ym1pdCgpIHtcclxuICBsZXQge1xyXG4gICAgcm91dGVyXHJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVN1Ym1pdCk7XHJcbiAgbGV0IHtcclxuICAgIGJhc2VuYW1lXHJcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcclxuICBsZXQgY3VycmVudFJvdXRlSWQgPSBVTlNBRkVfdXNlUm91dGVJZCgpO1xyXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlQ2xpZW50U2lkZVN1Ym1pc3Npb24oKTtcclxuICAgIGxldCB7XHJcbiAgICAgIGFjdGlvbixcclxuICAgICAgbWV0aG9kLFxyXG4gICAgICBlbmNUeXBlLFxyXG4gICAgICBmb3JtRGF0YSxcclxuICAgICAgYm9keVxyXG4gICAgfSA9IGdldEZvcm1TdWJtaXNzaW9uSW5mbyh0YXJnZXQsIGJhc2VuYW1lKTtcclxuICAgIGlmIChvcHRpb25zLm5hdmlnYXRlID09PSBmYWxzZSkge1xyXG4gICAgICBsZXQga2V5ID0gb3B0aW9ucy5mZXRjaGVyS2V5IHx8IGdldFVuaXF1ZUZldGNoZXJJZCgpO1xyXG4gICAgICByb3V0ZXIuZmV0Y2goa2V5LCBjdXJyZW50Um91dGVJZCwgb3B0aW9ucy5hY3Rpb24gfHwgYWN0aW9uLCB7XHJcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcclxuICAgICAgICBmb3JtRGF0YSxcclxuICAgICAgICBib2R5LFxyXG4gICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcclxuICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXHJcbiAgICAgICAgZmx1c2hTeW5jOiBvcHRpb25zLmZsdXNoU3luY1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZShvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcclxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxyXG4gICAgICAgIGZvcm1EYXRhLFxyXG4gICAgICAgIGJvZHksXHJcbiAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxyXG4gICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcclxuICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2UsXHJcbiAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXHJcbiAgICAgICAgZnJvbVJvdXRlSWQ6IGN1cnJlbnRSb3V0ZUlkLFxyXG4gICAgICAgIGZsdXNoU3luYzogb3B0aW9ucy5mbHVzaFN5bmMsXHJcbiAgICAgICAgdmlld1RyYW5zaXRpb246IG9wdGlvbnMudmlld1RyYW5zaXRpb25cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSwgW3JvdXRlciwgYmFzZW5hbWUsIGN1cnJlbnRSb3V0ZUlkXSk7XHJcbn1cclxuLy8gdjc6IEV2ZW50dWFsbHkgd2Ugc2hvdWxkIGRlcHJlY2F0ZSB0aGlzIGVudGlyZWx5IGluIGZhdm9yIG9mIHVzaW5nIHRoZVxyXG4vLyByb3V0ZXIgbWV0aG9kIGRpcmVjdGx5P1xyXG5mdW5jdGlvbiB1c2VGb3JtQWN0aW9uKGFjdGlvbiwgX3RlbXAyKSB7XHJcbiAgbGV0IHtcclxuICAgIHJlbGF0aXZlXHJcbiAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XHJcbiAgbGV0IHtcclxuICAgIGJhc2VuYW1lXHJcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcclxuICBsZXQgcm91dGVDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfUm91dGVDb250ZXh0KTtcclxuICAhcm91dGVDb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGb3JtQWN0aW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICBsZXQgW21hdGNoXSA9IHJvdXRlQ29udGV4dC5tYXRjaGVzLnNsaWNlKC0xKTtcclxuICAvLyBTaGFsbG93IGNsb25lIHBhdGggc28gd2UgY2FuIG1vZGlmeSBpdCBiZWxvdywgb3RoZXJ3aXNlIHdlIG1vZGlmeSB0aGVcclxuICAvLyBvYmplY3QgcmVmZXJlbmNlZCBieSB1c2VNZW1vIGluc2lkZSB1c2VSZXNvbHZlZFBhdGhcclxuICBsZXQgcGF0aCA9IF9leHRlbmRzKHt9LCB1c2VSZXNvbHZlZFBhdGgoYWN0aW9uID8gYWN0aW9uIDogXCIuXCIsIHtcclxuICAgIHJlbGF0aXZlXHJcbiAgfSkpO1xyXG4gIC8vIElmIG5vIGFjdGlvbiB3YXMgc3BlY2lmaWVkLCBicm93c2VycyB3aWxsIHBlcnNpc3QgY3VycmVudCBzZWFyY2ggcGFyYW1zXHJcbiAgLy8gd2hlbiBkZXRlcm1pbmluZyB0aGUgcGF0aCwgc28gbWF0Y2ggdGhhdCBiZWhhdmlvclxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xyXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XHJcbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XHJcbiAgICAvLyBTYWZlIHRvIHdyaXRlIHRvIHRoaXMgZGlyZWN0bHkgaGVyZSBzaW5jZSBpZiBhY3Rpb24gd2FzIHVuZGVmaW5lZCwgd2VcclxuICAgIC8vIHdvdWxkIGhhdmUgY2FsbGVkIHVzZVJlc29sdmVkUGF0aChcIi5cIikgd2hpY2ggd2lsbCBuZXZlciBpbmNsdWRlIGEgc2VhcmNoXHJcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcclxuICAgIC8vIFdoZW4gZ3JhYmJpbmcgc2VhcmNoIHBhcmFtcyBmcm9tIHRoZSBVUkwsIHJlbW92ZSBhbnkgaW5jbHVkZWQgP2luZGV4IHBhcmFtXHJcbiAgICAvLyBzaW5jZSBpdCBtaWdodCBub3QgYXBwbHkgdG8gb3VyIGNvbnRleHR1YWwgcm91dGUuICBXZSBhZGQgaXQgYmFjayBiYXNlZFxyXG4gICAgLy8gb24gbWF0Y2gucm91dGUuaW5kZXggYmVsb3dcclxuICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGguc2VhcmNoKTtcclxuICAgIGxldCBpbmRleFZhbHVlcyA9IHBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcclxuICAgIGxldCBoYXNOYWtlZEluZGV4UGFyYW0gPSBpbmRleFZhbHVlcy5zb21lKHYgPT4gdiA9PT0gXCJcIik7XHJcbiAgICBpZiAoaGFzTmFrZWRJbmRleFBhcmFtKSB7XHJcbiAgICAgIHBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcclxuICAgICAgaW5kZXhWYWx1ZXMuZmlsdGVyKHYgPT4gdikuZm9yRWFjaCh2ID0+IHBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB2KSk7XHJcbiAgICAgIGxldCBxcyA9IHBhcmFtcy50b1N0cmluZygpO1xyXG4gICAgICBwYXRoLnNlYXJjaCA9IHFzID8gXCI/XCIgKyBxcyA6IFwiXCI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xyXG4gICAgcGF0aC5zZWFyY2ggPSBwYXRoLnNlYXJjaCA/IHBhdGguc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIj9pbmRleCZcIikgOiBcIj9pbmRleFwiO1xyXG4gIH1cclxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXHJcbiAgLy8gdG8gY3JlYXRpbmcgdGhlIGZvcm0gYWN0aW9uLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZVxyXG4gIC8vIHRoZSByYXcgYmFzZW5hbWUgd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZVxyXG4gIC8vIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBhY3Rpb25zXHJcbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xyXG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xyXG59XHJcbi8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSB1c2VGZXRjaGVyIGdlbmVyaWMgZGVmYXVsdCBmcm9tIGBhbnlgIHRvIGB1bmtub3duYFxyXG4vKipcclxuICogSW50ZXJhY3RzIHdpdGggcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyB3aXRob3V0IGNhdXNpbmcgYSBuYXZpZ2F0aW9uLiBHcmVhdFxyXG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cclxuICovXHJcbmZ1bmN0aW9uIHVzZUZldGNoZXIoX3RlbXAzKSB7XHJcbiAgdmFyIF9yb3V0ZSRtYXRjaGVzO1xyXG4gIGxldCB7XHJcbiAgICBrZXlcclxuICB9ID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMztcclxuICBsZXQge1xyXG4gICAgcm91dGVyXHJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUZldGNoZXIpO1xyXG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXIpO1xyXG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0LnVzZUNvbnRleHQoRmV0Y2hlcnNDb250ZXh0KTtcclxuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xyXG4gIGxldCByb3V0ZUlkID0gKF9yb3V0ZSRtYXRjaGVzID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlJG1hdGNoZXMucm91dGUuaWQ7XHJcbiAgIWZldGNoZXJEYXRhID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBGZXRjaGVyc0NvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICAhcm91dGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICEocm91dGVJZCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwidXNlRmV0Y2hlciBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXFxcImlkXFxcIlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gIC8vIEZldGNoZXIga2V5IGhhbmRsaW5nXHJcbiAgLy8gT0sgdG8gY2FsbCBjb25kaXRpb25hbGx5IHRvIGZlYXR1cmUgZGV0ZWN0IGB1c2VJZGBcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcclxuICBsZXQgZGVmYXVsdEtleSA9IHVzZUlkSW1wbCA/IHVzZUlkSW1wbCgpIDogXCJcIjtcclxuICBsZXQgW2ZldGNoZXJLZXksIHNldEZldGNoZXJLZXldID0gUmVhY3QudXNlU3RhdGUoa2V5IHx8IGRlZmF1bHRLZXkpO1xyXG4gIGlmIChrZXkgJiYga2V5ICE9PSBmZXRjaGVyS2V5KSB7XHJcbiAgICBzZXRGZXRjaGVyS2V5KGtleSk7XHJcbiAgfSBlbHNlIGlmICghZmV0Y2hlcktleSkge1xyXG4gICAgLy8gV2Ugd2lsbCBvbmx5IGZhbGwgdGhyb3VnaCBoZXJlIHdoZW4gYHVzZUlkYCBpcyBub3QgYXZhaWxhYmxlXHJcbiAgICBzZXRGZXRjaGVyS2V5KGdldFVuaXF1ZUZldGNoZXJJZCgpKTtcclxuICB9XHJcbiAgLy8gUmVnaXN0cmF0aW9uL2NsZWFudXBcclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgcm91dGVyLmdldEZldGNoZXIoZmV0Y2hlcktleSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAvLyBUZWxsIHRoZSByb3V0ZXIgd2UndmUgdW5tb3VudGVkIC0gaWYgdjdfZmV0Y2hlclBlcnNpc3QgaXMgZW5hYmxlZCB0aGlzXHJcbiAgICAgIC8vIHdpbGwgbm90IGRlbGV0ZSBpbW1lZGlhdGVseSBidXQgaW5zdGVhZCBxdWV1ZSB1cCBhIGRlbGV0ZSBhZnRlciB0aGVcclxuICAgICAgLy8gZmV0Y2hlciByZXR1cm5zIHRvIGFuIGBpZGxlYCBzdGF0ZVxyXG4gICAgICByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcclxuICAgIH07XHJcbiAgfSwgW3JvdXRlciwgZmV0Y2hlcktleV0pO1xyXG4gIC8vIEZldGNoZXIgYWRkaXRpb25zXHJcbiAgbGV0IGxvYWQgPSBSZWFjdC51c2VDYWxsYmFjaygoaHJlZiwgb3B0cykgPT4ge1xyXG4gICAgIXJvdXRlSWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYsIG9wdHMpO1xyXG4gIH0sIFtmZXRjaGVyS2V5LCByb3V0ZUlkLCByb3V0ZXJdKTtcclxuICBsZXQgc3VibWl0SW1wbCA9IHVzZVN1Ym1pdCgpO1xyXG4gIGxldCBzdWJtaXQgPSBSZWFjdC51c2VDYWxsYmFjaygodGFyZ2V0LCBvcHRzKSA9PiB7XHJcbiAgICBzdWJtaXRJbXBsKHRhcmdldCwgX2V4dGVuZHMoe30sIG9wdHMsIHtcclxuICAgICAgbmF2aWdhdGU6IGZhbHNlLFxyXG4gICAgICBmZXRjaGVyS2V5XHJcbiAgICB9KSk7XHJcbiAgfSwgW2ZldGNoZXJLZXksIHN1Ym1pdEltcGxdKTtcclxuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcclxuICAgIGxldCBGZXRjaGVyRm9ybSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcclxuICAgICAgICBuYXZpZ2F0ZTogZmFsc2UsXHJcbiAgICAgICAgZmV0Y2hlcktleTogZmV0Y2hlcktleSxcclxuICAgICAgICByZWY6IHJlZlxyXG4gICAgICB9KSk7XHJcbiAgICB9KTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgRmV0Y2hlckZvcm0uZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEZldGNoZXJGb3JtO1xyXG4gIH0sIFtmZXRjaGVyS2V5XSk7XHJcbiAgLy8gRXhwb3NlZCBGZXRjaGVyV2l0aENvbXBvbmVudHNcclxuICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChmZXRjaGVyS2V5KSB8fCBJRExFX0ZFVENIRVI7XHJcbiAgbGV0IGRhdGEgPSBmZXRjaGVyRGF0YS5nZXQoZmV0Y2hlcktleSk7XHJcbiAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gX2V4dGVuZHMoe1xyXG4gICAgRm9ybTogRmV0Y2hlckZvcm0sXHJcbiAgICBzdWJtaXQsXHJcbiAgICBsb2FkXHJcbiAgfSwgZmV0Y2hlciwge1xyXG4gICAgZGF0YVxyXG4gIH0pLCBbRmV0Y2hlckZvcm0sIHN1Ym1pdCwgbG9hZCwgZmV0Y2hlciwgZGF0YV0pO1xyXG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGFsbCBmZXRjaGVycyBjdXJyZW50bHkgb24gdGhlIHBhZ2UuIFVzZWZ1bCBmb3IgbGF5b3V0cyBhbmQgcGFyZW50XHJcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cclxuICovXHJcbmZ1bmN0aW9uIHVzZUZldGNoZXJzKCkge1xyXG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXJzKTtcclxuICByZXR1cm4gQXJyYXkuZnJvbShzdGF0ZS5mZXRjaGVycy5lbnRyaWVzKCkpLm1hcChfcmVmMTEgPT4ge1xyXG4gICAgbGV0IFtrZXksIGZldGNoZXJdID0gX3JlZjExO1xyXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBmZXRjaGVyLCB7XHJcbiAgICAgIGtleVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuY29uc3QgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZID0gXCJyZWFjdC1yb3V0ZXItc2Nyb2xsLXBvc2l0aW9uc1wiO1xyXG5sZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSB7fTtcclxuLyoqXHJcbiAqIFdoZW4gcmVuZGVyZWQgaW5zaWRlIGEgUm91dGVyUHJvdmlkZXIsIHdpbGwgcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25zIG9uIG5hdmlnYXRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbihfdGVtcDQpIHtcclxuICBsZXQge1xyXG4gICAgZ2V0S2V5LFxyXG4gICAgc3RvcmFnZUtleVxyXG4gIH0gPSBfdGVtcDQgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA0O1xyXG4gIGxldCB7XHJcbiAgICByb3V0ZXJcclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xyXG4gIGxldCB7XHJcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb24sXHJcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcclxuICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xyXG4gIGxldCB7XHJcbiAgICBiYXNlbmFtZVxyXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XHJcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcclxuICBsZXQgbWF0Y2hlcyA9IHVzZU1hdGNoZXMoKTtcclxuICBsZXQgbmF2aWdhdGlvbiA9IHVzZU5hdmlnYXRpb24oKTtcclxuICAvLyBUcmlnZ2VyIG1hbnVhbCBzY3JvbGwgcmVzdG9yYXRpb24gd2hpbGUgd2UncmUgYWN0aXZlXHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XHJcbiAgICB9O1xyXG4gIH0sIFtdKTtcclxuICAvLyBTYXZlIHBvc2l0aW9ucyBvbiBwYWdlaGlkZVxyXG4gIHVzZVBhZ2VIaWRlKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChuYXZpZ2F0aW9uLnN0YXRlID09PSBcImlkbGVcIikge1xyXG4gICAgICBsZXQga2V5ID0gKGdldEtleSA/IGdldEtleShsb2NhdGlvbiwgbWF0Y2hlcykgOiBudWxsKSB8fCBsb2NhdGlvbi5rZXk7XHJcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHNhdmVkU2Nyb2xsUG9zaXRpb25zKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJGYWlsZWQgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlLCA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gd2lsbCBub3Qgd29yayBwcm9wZXJseSAoXCIgKyBlcnJvciArIFwiKS5cIikgOiB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xyXG4gIH0sIFtzdG9yYWdlS2V5LCBnZXRLZXksIG5hdmlnYXRpb24uc3RhdGUsIGxvY2F0aW9uLCBtYXRjaGVzXSkpO1xyXG4gIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcclxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcclxuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZKTtcclxuICAgICAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xyXG4gICAgICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIG5vLW9wLCB1c2UgZGVmYXVsdCBlbXB0eSBvYmplY3RcclxuICAgICAgfVxyXG4gICAgfSwgW3N0b3JhZ2VLZXldKTtcclxuICAgIC8vIEVuYWJsZSBzY3JvbGwgcmVzdG9yYXRpb24gaW4gdGhlIHJvdXRlclxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXHJcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBsZXQgZ2V0S2V5V2l0aG91dEJhc2VuYW1lID0gZ2V0S2V5ICYmIGJhc2VuYW1lICE9PSBcIi9cIiA/IChsb2NhdGlvbiwgbWF0Y2hlcykgPT4gZ2V0S2V5KCAvLyBTdHJpcCB0aGUgYmFzZW5hbWUgdG8gbWF0Y2ggdXNlTG9jYXRpb24oKVxyXG4gICAgICBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcclxuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lXHJcbiAgICAgIH0pLCBtYXRjaGVzKSA6IGdldEtleTtcclxuICAgICAgbGV0IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiA9IHJvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcm91dGVyLmVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKHNhdmVkU2Nyb2xsUG9zaXRpb25zLCAoKSA9PiB3aW5kb3cuc2Nyb2xsWSwgZ2V0S2V5V2l0aG91dEJhc2VuYW1lKTtcclxuICAgICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcclxuICAgIH0sIFtyb3V0ZXIsIGJhc2VuYW1lLCBnZXRLZXldKTtcclxuICAgIC8vIFJlc3RvcmUgc2Nyb2xsaW5nIHdoZW4gc3RhdGUucmVzdG9yZVNjcm9sbFBvc2l0aW9uIGNoYW5nZXNcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xyXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgLy8gRXhwbGljaXQgZmFsc2UgbWVhbnMgZG9uJ3QgZG8gYW55dGhpbmcgKHVzZWQgZm9yIHN1Ym1pc3Npb25zKVxyXG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcclxuICAgICAgaWYgKHR5cGVvZiByZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gdHJ5IHRvIHNjcm9sbCB0byB0aGUgaGFzaFxyXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKSk7XHJcbiAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBEb24ndCByZXNldCBpZiB0aGlzIG5hdmlnYXRpb24gb3B0ZWQgb3V0XHJcbiAgICAgIGlmIChwcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xyXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XHJcbiAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBTZXR1cCBhIGNhbGxiYWNrIHRvIGJlIGZpcmVkIG9uIHRoZSB3aW5kb3cncyBgYmVmb3JldW5sb2FkYCBldmVudC4gVGhpcyBpc1xyXG4gKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXHJcbiAqIHJlZnJlc2hlcy5cclxuICpcclxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXHJcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cclxuICovXHJcbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xyXG4gIGxldCB7XHJcbiAgICBjYXB0dXJlXHJcbiAgfSA9IG9wdGlvbnMgfHwge307XHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xyXG4gICAgICBjYXB0dXJlXHJcbiAgICB9IDogdW5kZWZpbmVkO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xyXG4gICAgfTtcclxuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcclxufVxyXG4vKipcclxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYHBhZ2VoaWRlYCBldmVudC4gVGhpcyBpc1xyXG4gKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXHJcbiAqIHJlZnJlc2hlcy4gIFRoaXMgZXZlbnQgaXMgYmV0dGVyIHN1cHBvcnRlZCB0aGFuIGJlZm9yZXVubG9hZCBhY3Jvc3MgYnJvd3NlcnMuXHJcbiAqXHJcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxyXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VQYWdlSGlkZShjYWxsYmFjaywgb3B0aW9ucykge1xyXG4gIGxldCB7XHJcbiAgICBjYXB0dXJlXHJcbiAgfSA9IG9wdGlvbnMgfHwge307XHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xyXG4gICAgICBjYXB0dXJlXHJcbiAgICB9IDogdW5kZWZpbmVkO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcclxuICAgIH07XHJcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XHJcbn1cclxuLyoqXHJcbiAqIFdyYXBwZXIgYXJvdW5kIHVzZUJsb2NrZXIgdG8gc2hvdyBhIHdpbmRvdy5jb25maXJtIHByb21wdCB0byB1c2VycyBpbnN0ZWFkXHJcbiAqIG9mIGJ1aWxkaW5nIGEgY3VzdG9tIFVJIHdpdGggdXNlQmxvY2tlci5cclxuICpcclxuICogV2FybmluZzogVGhpcyBoYXMgKmEgbG90IG9mIHJvdWdoIGVkZ2VzKiBhbmQgYmVoYXZlcyB2ZXJ5IGRpZmZlcmVudGx5IChhbmRcclxuICogdmVyeSBpbmNvcnJlY3RseSBpbiBzb21lIGNhc2VzKSBhY3Jvc3MgYnJvd3NlcnMgaWYgdXNlciBjbGljayBhZGRpdGlvblxyXG4gKiBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbnMgd2hpbGUgdGhlIGNvbmZpcm0gaXMgb3Blbi4gIFVzZSBhdCB5b3VyIG93biByaXNrLlxyXG4gKi9cclxuZnVuY3Rpb24gdXNlUHJvbXB0KF9yZWYxMikge1xyXG4gIGxldCB7XHJcbiAgICB3aGVuLFxyXG4gICAgbWVzc2FnZVxyXG4gIH0gPSBfcmVmMTI7XHJcbiAgbGV0IGJsb2NrZXIgPSB1c2VCbG9ja2VyKHdoZW4pO1xyXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcclxuICAgICAgbGV0IHByb2NlZWQgPSB3aW5kb3cuY29uZmlybShtZXNzYWdlKTtcclxuICAgICAgaWYgKHByb2NlZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgaXMgbmVlZGVkIHRvIGF2b2lkIGEgd2VpcmQgXCJyYWNlXCIgb24gUE9QIG5hdmlnYXRpb25zXHJcbiAgICAgICAgLy8gYmV0d2VlbiB0aGUgYHdpbmRvdy5oaXN0b3J5YCByZXZlcnQgbmF2aWdhdGlvbiBhbmQgdGhlIHJlc3VsdCBvZlxyXG4gICAgICAgIC8vIGB3aW5kb3cuY29uZmlybWBcclxuICAgICAgICBzZXRUaW1lb3V0KGJsb2NrZXIucHJvY2VlZCwgMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmxvY2tlci5yZXNldCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW2Jsb2NrZXIsIG1lc3NhZ2VdKTtcclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmICF3aGVuKSB7XHJcbiAgICAgIGJsb2NrZXIucmVzZXQoKTtcclxuICAgIH1cclxuICB9LCBbYmxvY2tlciwgd2hlbl0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlcmUgaXMgYW4gYWN0aXZlIHZpZXcgdHJhbnNpdGlvbiB0byB0aGVcclxuICogZ2l2ZW4gaHJlZi4gIFlvdSBjYW4gdXNlIHRoaXMgdmFsdWUgdG8gcmVuZGVyIENTUyBjbGFzc2VzIG9yIHZpZXdUcmFuc2l0aW9uTmFtZVxyXG4gKiBzdHlsZXMgb250byB5b3VyIGVsZW1lbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSBocmVmIFRoZSBkZXN0aW5hdGlvbiBocmVmXHJcbiAqIEBwYXJhbSBbb3B0cy5yZWxhdGl2ZV0gUmVsYXRpdmUgcm91dGluZyB0eXBlIChcInJvdXRlXCIgfCBcInBhdGhcIilcclxuICovXHJcbmZ1bmN0aW9uIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUodG8sIG9wdHMpIHtcclxuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XHJcbiAgICBvcHRzID0ge307XHJcbiAgfVxyXG4gIGxldCB2dENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFZpZXdUcmFuc2l0aW9uQ29udGV4dCk7XHJcbiAgISh2dENvbnRleHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcImB1c2VWaWV3VHJhbnNpdGlvblN0YXRlYCBtdXN0IGJlIHVzZWQgd2l0aGluIGByZWFjdC1yb3V0ZXItZG9tYCdzIGBSb3V0ZXJQcm92aWRlcmAuICBcIiArIFwiRGlkIHlvdSBhY2NpZGVudGFsbHkgaW1wb3J0IGBSb3V0ZXJQcm92aWRlcmAgZnJvbSBgcmVhY3Qtcm91dGVyYD9cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICBsZXQge1xyXG4gICAgYmFzZW5hbWVcclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2sudXNlVmlld1RyYW5zaXRpb25TdGF0ZSk7XHJcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcclxuICAgIHJlbGF0aXZlOiBvcHRzLnJlbGF0aXZlXHJcbiAgfSk7XHJcbiAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGxldCBjdXJyZW50UGF0aCA9IHN0cmlwQmFzZW5hbWUodnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XHJcbiAgbGV0IG5leHRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcclxuICAvLyBUcmFuc2l0aW9uIGlzIGFjdGl2ZSBpZiB3ZSdyZSBnb2luZyB0byBvciBjb21pbmcgZnJvbSB0aGUgaW5kaWNhdGVkXHJcbiAgLy8gZGVzdGluYXRpb24uICBUaGlzIGVuc3VyZXMgdGhhdCBvdGhlciBQVVNIIG5hdmlnYXRpb25zIHRoYXQgcmV2ZXJzZVxyXG4gIC8vIGFuIGluZGljYXRlZCB0cmFuc2l0aW9uIGFwcGx5LiAgSS5lLiwgb24gdGhlIGxpc3QgdmlldyB5b3UgaGF2ZTpcclxuICAvL1xyXG4gIC8vICAgPE5hdkxpbmsgdG89XCIvZGV0YWlscy8xXCIgdmlld1RyYW5zaXRpb24+XHJcbiAgLy9cclxuICAvLyBJZiB5b3UgY2xpY2sgdGhlIGJyZWFkY3J1bWIgYmFjayB0byB0aGUgbGlzdCB2aWV3OlxyXG4gIC8vXHJcbiAgLy8gICA8TmF2TGluayB0bz1cIi9saXN0XCIgdmlld1RyYW5zaXRpb24+XHJcbiAgLy9cclxuICAvLyBXZSBzaG91bGQgYXBwbHkgdGhlIHRyYW5zaXRpb24gYmVjYXVzZSBpdCdzIGluZGljYXRlZCBhcyBhY3RpdmUgZ29pbmdcclxuICAvLyBmcm9tIC9saXN0IC0+IC9kZXRhaWxzLzEgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgYWN0aXZlIG9uIHRoZSByZXZlcnNlXHJcbiAgLy8gKGV2ZW4gdGhvdWdoIHRoaXMgaXNuJ3Qgc3RyaWN0bHkgYSBQT1AgcmV2ZXJzZSlcclxuICByZXR1cm4gbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIG5leHRQYXRoKSAhPSBudWxsIHx8IG1hdGNoUGF0aChwYXRoLnBhdGhuYW1lLCBjdXJyZW50UGF0aCkgIT0gbnVsbDtcclxufVxyXG4vLyNlbmRyZWdpb25cclxuXHJcbmV4cG9ydCB7IEJyb3dzZXJSb3V0ZXIsIEZvcm0sIEhhc2hSb3V0ZXIsIExpbmssIE5hdkxpbmssIFJvdXRlclByb3ZpZGVyLCBTY3JvbGxSZXN0b3JhdGlvbiwgRmV0Y2hlcnNDb250ZXh0IGFzIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQsIFZpZXdUcmFuc2l0aW9uQ29udGV4dCBhcyBVTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0LCB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24sIGNyZWF0ZUJyb3dzZXJSb3V0ZXIsIGNyZWF0ZUhhc2hSb3V0ZXIsIGNyZWF0ZVNlYXJjaFBhcmFtcywgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyLCB1c2VQcm9tcHQgYXMgdW5zdGFibGVfdXNlUHJvbXB0LCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMaW5rQ2xpY2tIYW5kbGVyLCB1c2VTZWFyY2hQYXJhbXMsIHVzZVN1Ym1pdCwgdXNlVmlld1RyYW5zaXRpb25TdGF0ZSB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-router-dom/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   UNSAFE_mapRouteProperties: () => (/* binding */ mapRouteProperties),\n/* harmony export */   UNSAFE_useRouteId: () => (/* binding */ useRouteId),\n/* harmony export */   UNSAFE_useRoutesImpl: () => (/* binding */ useRoutesImpl),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   defer: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   replace: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.replace),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useBlocker: () => (/* binding */ useBlocker),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"./node_modules/@remix-run/router/dist/router.js\");\n/**\r\n * React Router v6.27.0\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\r\n\r\n\r\n\r\n\r\nfunction _extends() {\r\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n    return target;\r\n  };\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\n// Create react-specific types from the agnostic types in @remix-run/router to\r\n// export from react-router\r\nconst DataRouterContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\r\nif (true) {\r\n  DataRouterContext.displayName = \"DataRouter\";\r\n}\r\nconst DataRouterStateContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\r\nif (true) {\r\n  DataRouterStateContext.displayName = \"DataRouterState\";\r\n}\r\nconst AwaitContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\r\nif (true) {\r\n  AwaitContext.displayName = \"Await\";\r\n}\r\n\r\n/**\r\n * A Navigator is a \"location changer\"; it's how you get to different locations.\r\n *\r\n * Every history instance conforms to the Navigator interface, but the\r\n * distinction is useful primarily when it comes to the low-level `<Router>` API\r\n * where both the location and a navigator must be provided separately in order\r\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\r\n * and/or location were to be read directly from the history instance.\r\n */\r\n\r\nconst NavigationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\r\nif (true) {\r\n  NavigationContext.displayName = \"Navigation\";\r\n}\r\nconst LocationContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\r\nif (true) {\r\n  LocationContext.displayName = \"Location\";\r\n}\r\nconst RouteContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\r\n  outlet: null,\r\n  matches: [],\r\n  isDataRoute: false\r\n});\r\nif (true) {\r\n  RouteContext.displayName = \"Route\";\r\n}\r\nconst RouteErrorContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\r\nif (true) {\r\n  RouteErrorContext.displayName = \"RouteError\";\r\n}\r\n\r\n/**\r\n * Returns the full href for the given \"to\" value. This is useful for building\r\n * custom links that are also accessible and preserve right-click behavior.\r\n *\r\n * @see https://reactrouter.com/hooks/use-href\r\n */\r\nfunction useHref(to, _temp) {\r\n  let {\r\n    relative\r\n  } = _temp === void 0 ? {} : _temp;\r\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\r\n  let {\r\n    basename,\r\n    navigator\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\r\n  let {\r\n    hash,\r\n    pathname,\r\n    search\r\n  } = useResolvedPath(to, {\r\n    relative\r\n  });\r\n  let joinedPathname = pathname;\r\n\r\n  // If we're operating within a basename, prepend it to the pathname prior\r\n  // to creating the href.  If this is a root navigation, then just use the raw\r\n  // basename which allows the basename to have full control over the presence\r\n  // of a trailing slash on root links\r\n  if (basename !== \"/\") {\r\n    joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([basename, pathname]);\r\n  }\r\n  return navigator.createHref({\r\n    pathname: joinedPathname,\r\n    search,\r\n    hash\r\n  });\r\n}\r\n\r\n/**\r\n * Returns true if this component is a descendant of a `<Router>`.\r\n *\r\n * @see https://reactrouter.com/hooks/use-in-router-context\r\n */\r\nfunction useInRouterContext() {\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\r\n}\r\n\r\n/**\r\n * Returns the current location object, which represents the current URL in web\r\n * browsers.\r\n *\r\n * Note: If you're using this it may mean you're doing some of your own\r\n * \"routing\" in your app, and we'd like to know what your use case is. We may\r\n * be able to provide something higher-level to better suit your needs.\r\n *\r\n * @see https://reactrouter.com/hooks/use-location\r\n */\r\nfunction useLocation() {\r\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\r\n}\r\n\r\n/**\r\n * Returns the current navigation action which describes how the router came to\r\n * the current location, either by a pop, push, or replace on the history stack.\r\n *\r\n * @see https://reactrouter.com/hooks/use-navigation-type\r\n */\r\nfunction useNavigationType() {\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\r\n}\r\n\r\n/**\r\n * Returns a PathMatch object if the given pattern matches the current URL.\r\n * This is useful for components that need to know \"active\" state, e.g.\r\n * `<NavLink>`.\r\n *\r\n * @see https://reactrouter.com/hooks/use-match\r\n */\r\nfunction useMatch(pattern) {\r\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\r\n  let {\r\n    pathname\r\n  } = useLocation();\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(pattern, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_decodePath)(pathname)), [pathname, pattern]);\r\n}\r\n\r\n/**\r\n * The interface for the navigate() function returned from useNavigate().\r\n */\r\n\r\nconst navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\r\n\r\n// Mute warnings for calls to useNavigate in SSR environments\r\nfunction useIsomorphicLayoutEffect(cb) {\r\n  let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\r\n  if (!isStatic) {\r\n    // We should be able to get rid of this once react 18.3 is released\r\n    // See: https://github.com/facebook/react/pull/26395\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\r\n * may also be used by other elements to change the location.\r\n *\r\n * @see https://reactrouter.com/hooks/use-navigate\r\n */\r\nfunction useNavigate() {\r\n  let {\r\n    isDataRoute\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\r\n  // Conditional usage is OK here because the usage of a data router is static\r\n  // eslint-disable-next-line react-hooks/rules-of-hooks\r\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\r\n}\r\nfunction useNavigateUnstable() {\r\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\r\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\r\n  let {\r\n    basename,\r\n    future,\r\n    navigator\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\r\n  let {\r\n    matches\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\r\n  let {\r\n    pathname: locationPathname\r\n  } = useLocation();\r\n  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\r\n  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\r\n  useIsomorphicLayoutEffect(() => {\r\n    activeRef.current = true;\r\n  });\r\n  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\r\n\r\n    // Short circuit here since if this happens on first render the navigate\r\n    // is useless because we haven't wired up our history listener yet\r\n    if (!activeRef.current) return;\r\n    if (typeof to === \"number\") {\r\n      navigator.go(to);\r\n      return;\r\n    }\r\n    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\r\n\r\n    // If we're operating within a basename, prepend it to the pathname prior\r\n    // to handing off to history (but only if we're not in a data router,\r\n    // otherwise it'll prepend the basename inside of the router).\r\n    // If this is a root navigation, then we navigate to the raw basename\r\n    // which allows the basename to have full control over the presence of a\r\n    // trailing slash on root links\r\n    if (dataRouterContext == null && basename !== \"/\") {\r\n      path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([basename, path.pathname]);\r\n    }\r\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\r\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\r\n  return navigate;\r\n}\r\nconst OutletContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\r\n\r\n/**\r\n * Returns the context (if provided) for the child route at this level of the route\r\n * hierarchy.\r\n * @see https://reactrouter.com/hooks/use-outlet-context\r\n */\r\nfunction useOutletContext() {\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\r\n}\r\n\r\n/**\r\n * Returns the element for the child route at this level of the route\r\n * hierarchy. Used internally by `<Outlet>` to render child routes.\r\n *\r\n * @see https://reactrouter.com/hooks/use-outlet\r\n */\r\nfunction useOutlet(context) {\r\n  let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\r\n  if (outlet) {\r\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\r\n      value: context\r\n    }, outlet);\r\n  }\r\n  return outlet;\r\n}\r\n\r\n/**\r\n * Returns an object of key/value pairs of the dynamic params from the current\r\n * URL that were matched by the route path.\r\n *\r\n * @see https://reactrouter.com/hooks/use-params\r\n */\r\nfunction useParams() {\r\n  let {\r\n    matches\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\r\n  let routeMatch = matches[matches.length - 1];\r\n  return routeMatch ? routeMatch.params : {};\r\n}\r\n\r\n/**\r\n * Resolves the pathname of the given `to` value against the current location.\r\n *\r\n * @see https://reactrouter.com/hooks/use-resolved-path\r\n */\r\nfunction useResolvedPath(to, _temp2) {\r\n  let {\r\n    relative\r\n  } = _temp2 === void 0 ? {} : _temp2;\r\n  let {\r\n    future\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\r\n  let {\r\n    matches\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\r\n  let {\r\n    pathname: locationPathname\r\n  } = useLocation();\r\n  let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\r\n}\r\n\r\n/**\r\n * Returns the element of the route that matched the current location, prepared\r\n * with the correct context to render the remainder of the route tree. Route\r\n * elements in the tree must render an `<Outlet>` to render their child route's\r\n * element.\r\n *\r\n * @see https://reactrouter.com/hooks/use-routes\r\n */\r\nfunction useRoutes(routes, locationArg) {\r\n  return useRoutesImpl(routes, locationArg);\r\n}\r\n\r\n// Internal implementation with accept optional param for RouterProvider usage\r\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\r\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\r\n  let {\r\n    navigator\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\r\n  let {\r\n    matches: parentMatches\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\r\n  let routeMatch = parentMatches[parentMatches.length - 1];\r\n  let parentParams = routeMatch ? routeMatch.params : {};\r\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\r\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\r\n  let parentRoute = routeMatch && routeMatch.route;\r\n  if (true) {\r\n    // You won't get a warning about 2 different <Routes> under a <Route>\r\n    // without a trailing *, but this is a best-effort warning anyway since we\r\n    // cannot even give the warning unless they land at the parent route.\r\n    //\r\n    // Example:\r\n    //\r\n    // <Routes>\r\n    //   {/* This route path MUST end with /* because otherwise\r\n    //       it will never match /blog/post/123 */}\r\n    //   <Route path=\"blog\" element={<Blog />} />\r\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\r\n    // </Routes>\r\n    //\r\n    // function Blog() {\r\n    //   return (\r\n    //     <Routes>\r\n    //       <Route path=\"post/:id\" element={<Post />} />\r\n    //     </Routes>\r\n    //   );\r\n    // }\r\n    let parentPath = parentRoute && parentRoute.path || \"\";\r\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\r\n  }\r\n  let locationFromContext = useLocation();\r\n  let location;\r\n  if (locationArg) {\r\n    var _parsedLocationArg$pa;\r\n    let parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;\r\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : 0 : void 0;\r\n    location = parsedLocationArg;\r\n  } else {\r\n    location = locationFromContext;\r\n  }\r\n  let pathname = location.pathname || \"/\";\r\n  let remainingPathname = pathname;\r\n  if (parentPathnameBase !== \"/\") {\r\n    // Determine the remaining pathname by removing the # of URL segments the\r\n    // parentPathnameBase has, instead of removing based on character count.\r\n    // This is because we can't guarantee that incoming/outgoing encodings/\r\n    // decodings will match exactly.\r\n    // We decode paths before matching on a per-segment basis with\r\n    // decodeURIComponent(), but we re-encode pathnames via `new URL()` so they\r\n    // match what `window.location.pathname` would reflect.  Those don't 100%\r\n    // align when it comes to encoded URI characters such as % and &.\r\n    //\r\n    // So we may end up with:\r\n    //   pathname:           \"/descendant/a%25b/match\"\r\n    //   parentPathnameBase: \"/descendant/a%b\"\r\n    //\r\n    // And the direct substring removal approach won't work :/\r\n    let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\r\n    let segments = pathname.replace(/^\\//, \"\").split(\"/\");\r\n    remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\r\n  }\r\n  let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, {\r\n    pathname: remainingPathname\r\n  });\r\n  if (true) {\r\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : 0;\r\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") : 0;\r\n  }\r\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\r\n    params: Object.assign({}, parentParams, match.params),\r\n    pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([parentPathnameBase,\r\n    // Re-encode pathnames that were decoded inside matchRoutes\r\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\r\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([parentPathnameBase,\r\n    // Re-encode pathnames that were decoded inside matchRoutes\r\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\r\n  })), parentMatches, dataRouterState, future);\r\n\r\n  // When a user passes in a `locationArg`, the associated routes need to\r\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\r\n  // to use the scoped location instead of the global location.\r\n  if (locationArg && renderedMatches) {\r\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\r\n      value: {\r\n        location: _extends({\r\n          pathname: \"/\",\r\n          search: \"\",\r\n          hash: \"\",\r\n          state: null,\r\n          key: \"default\"\r\n        }, location),\r\n        navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop\r\n      }\r\n    }, renderedMatches);\r\n  }\r\n  return renderedMatches;\r\n}\r\nfunction DefaultErrorComponent() {\r\n  let error = useRouteError();\r\n  let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\r\n  let stack = error instanceof Error ? error.stack : null;\r\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\r\n  let preStyles = {\r\n    padding: \"0.5rem\",\r\n    backgroundColor: lightgrey\r\n  };\r\n  let codeStyles = {\r\n    padding: \"2px 4px\",\r\n    backgroundColor: lightgrey\r\n  };\r\n  let devInfo = null;\r\n  if (true) {\r\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\r\n    devInfo = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\r\n      style: codeStyles\r\n    }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\r\n      style: codeStyles\r\n    }, \"errorElement\"), \" prop on your route.\"));\r\n  }\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", {\r\n    style: {\r\n      fontStyle: \"italic\"\r\n    }\r\n  }, message), stack ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", {\r\n    style: preStyles\r\n  }, stack) : null, devInfo);\r\n}\r\nconst defaultErrorElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\r\nclass RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      location: props.location,\r\n      revalidation: props.revalidation,\r\n      error: props.error\r\n    };\r\n  }\r\n  static getDerivedStateFromError(error) {\r\n    return {\r\n      error: error\r\n    };\r\n  }\r\n  static getDerivedStateFromProps(props, state) {\r\n    // When we get into an error state, the user will likely click \"back\" to the\r\n    // previous page that didn't have an error. Because this wraps the entire\r\n    // application, that will have no effect--the error page continues to display.\r\n    // This gives us a mechanism to recover from the error when the location changes.\r\n    //\r\n    // Whether we're in an error state or not, we update the location in state\r\n    // so that when we are in an error state, it gets reset when a new location\r\n    // comes in and the user recovers from the error.\r\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\r\n      return {\r\n        error: props.error,\r\n        location: props.location,\r\n        revalidation: props.revalidation\r\n      };\r\n    }\r\n\r\n    // If we're not changing locations, preserve the location but still surface\r\n    // any new errors that may come through. We retain the existing error, we do\r\n    // this because the error provided from the app state may be cleared without\r\n    // the location changing.\r\n    return {\r\n      error: props.error !== undefined ? props.error : state.error,\r\n      location: state.location,\r\n      revalidation: props.revalidation || state.revalidation\r\n    };\r\n  }\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\r\n  }\r\n  render() {\r\n    return this.state.error !== undefined ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\r\n      value: this.props.routeContext\r\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\r\n      value: this.state.error,\r\n      children: this.props.component\r\n    })) : this.props.children;\r\n  }\r\n}\r\nfunction RenderedRoute(_ref) {\r\n  let {\r\n    routeContext,\r\n    match,\r\n    children\r\n  } = _ref;\r\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\r\n\r\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\r\n  // in a DataStaticRouter\r\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\r\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\r\n  }\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\r\n    value: routeContext\r\n  }, children);\r\n}\r\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\r\n  var _dataRouterState;\r\n  if (parentMatches === void 0) {\r\n    parentMatches = [];\r\n  }\r\n  if (dataRouterState === void 0) {\r\n    dataRouterState = null;\r\n  }\r\n  if (future === void 0) {\r\n    future = null;\r\n  }\r\n  if (matches == null) {\r\n    var _future;\r\n    if (!dataRouterState) {\r\n      return null;\r\n    }\r\n    if (dataRouterState.errors) {\r\n      // Don't bail if we have data router errors so we can render them in the\r\n      // boundary.  Use the pre-matched (or shimmed) matches\r\n      matches = dataRouterState.matches;\r\n    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\r\n      // Don't bail if we're initializing with partial hydration and we have\r\n      // router matches.  That means we're actively running `patchRoutesOnNavigation`\r\n      // so we should render down the partial matches to the appropriate\r\n      // `HydrateFallback`.  We only do this if `parentMatches` is empty so it\r\n      // only impacts the root matches for `RouterProvider` and no descendant\r\n      // `<Routes>`\r\n      matches = dataRouterState.matches;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  let renderedMatches = matches;\r\n\r\n  // If we have data errors, trim matches to the highest error boundary\r\n  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;\r\n  if (errors != null) {\r\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== undefined);\r\n    !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : 0 : void 0;\r\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\r\n  }\r\n\r\n  // If we're in a partial hydration mode, detect if we need to render down to\r\n  // a given HydrateFallback while we load the rest of the hydration data\r\n  let renderFallback = false;\r\n  let fallbackIndex = -1;\r\n  if (dataRouterState && future && future.v7_partialHydration) {\r\n    for (let i = 0; i < renderedMatches.length; i++) {\r\n      let match = renderedMatches[i];\r\n      // Track the deepest fallback up until the first route without data\r\n      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\r\n        fallbackIndex = i;\r\n      }\r\n      if (match.route.id) {\r\n        let {\r\n          loaderData,\r\n          errors\r\n        } = dataRouterState;\r\n        let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\r\n        if (match.route.lazy || needsToRunLoader) {\r\n          // We found the first route that's not ready to render (waiting on\r\n          // lazy, or has a loader that hasn't run yet).  Flag that we need to\r\n          // render a fallback and render up until the appropriate fallback\r\n          renderFallback = true;\r\n          if (fallbackIndex >= 0) {\r\n            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\r\n          } else {\r\n            renderedMatches = [renderedMatches[0]];\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return renderedMatches.reduceRight((outlet, match, index) => {\r\n    // Only data routers handle errors/fallbacks\r\n    let error;\r\n    let shouldRenderHydrateFallback = false;\r\n    let errorElement = null;\r\n    let hydrateFallbackElement = null;\r\n    if (dataRouterState) {\r\n      error = errors && match.route.id ? errors[match.route.id] : undefined;\r\n      errorElement = match.route.errorElement || defaultErrorElement;\r\n      if (renderFallback) {\r\n        if (fallbackIndex < 0 && index === 0) {\r\n          warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\r\n          shouldRenderHydrateFallback = true;\r\n          hydrateFallbackElement = null;\r\n        } else if (fallbackIndex === index) {\r\n          shouldRenderHydrateFallback = true;\r\n          hydrateFallbackElement = match.route.hydrateFallbackElement || null;\r\n        }\r\n      }\r\n    }\r\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\r\n    let getChildren = () => {\r\n      let children;\r\n      if (error) {\r\n        children = errorElement;\r\n      } else if (shouldRenderHydrateFallback) {\r\n        children = hydrateFallbackElement;\r\n      } else if (match.route.Component) {\r\n        // Note: This is a de-optimized path since React won't re-use the\r\n        // ReactElement since it's identity changes with each new\r\n        // React.createElement call.  We keep this so folks can use\r\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\r\n        // usage is only advised in `RouterProvider` when we can convert it to\r\n        // `element` ahead of time.\r\n        children = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\r\n      } else if (match.route.element) {\r\n        children = match.route.element;\r\n      } else {\r\n        children = outlet;\r\n      }\r\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\r\n        match: match,\r\n        routeContext: {\r\n          outlet,\r\n          matches,\r\n          isDataRoute: dataRouterState != null\r\n        },\r\n        children: children\r\n      });\r\n    };\r\n    // Only wrap in an error boundary within data router usages when we have an\r\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\r\n    // an ancestor ErrorBoundary/errorElement\r\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\r\n      location: dataRouterState.location,\r\n      revalidation: dataRouterState.revalidation,\r\n      component: errorElement,\r\n      error: error,\r\n      children: getChildren(),\r\n      routeContext: {\r\n        outlet: null,\r\n        matches,\r\n        isDataRoute: true\r\n      }\r\n    }) : getChildren();\r\n  }, null);\r\n}\r\nvar DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\r\n  DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\r\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\r\n  DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\r\n  return DataRouterHook;\r\n}(DataRouterHook || {});\r\nvar DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\r\n  DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\r\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\r\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\r\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\r\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\r\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\r\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\r\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\r\n  DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\r\n  DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\r\n  return DataRouterStateHook;\r\n}(DataRouterStateHook || {});\r\nfunction getDataRouterConsoleError(hookName) {\r\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\r\n}\r\nfunction useDataRouterContext(hookName) {\r\n  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\r\n  !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\r\n  return ctx;\r\n}\r\nfunction useDataRouterState(hookName) {\r\n  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\r\n  !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\r\n  return state;\r\n}\r\nfunction useRouteContext(hookName) {\r\n  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\r\n  !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\r\n  return route;\r\n}\r\n\r\n// Internal version with hookName-aware debugging\r\nfunction useCurrentRouteId(hookName) {\r\n  let route = useRouteContext(hookName);\r\n  let thisRoute = route.matches[route.matches.length - 1];\r\n  !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : 0 : void 0;\r\n  return thisRoute.route.id;\r\n}\r\n\r\n/**\r\n * Returns the ID for the nearest contextual route\r\n */\r\nfunction useRouteId() {\r\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\r\n}\r\n\r\n/**\r\n * Returns the current navigation, defaulting to an \"idle\" navigation when\r\n * no navigation is in progress\r\n */\r\nfunction useNavigation() {\r\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\r\n  return state.navigation;\r\n}\r\n\r\n/**\r\n * Returns a revalidate function for manually triggering revalidation, as well\r\n * as the current state of any manual revalidations\r\n */\r\nfunction useRevalidator() {\r\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\r\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\r\n    revalidate: dataRouterContext.router.revalidate,\r\n    state: state.revalidation\r\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\r\n}\r\n\r\n/**\r\n * Returns the active route matches, useful for accessing loaderData for\r\n * parent/child routes or the route \"handle\" property\r\n */\r\nfunction useMatches() {\r\n  let {\r\n    matches,\r\n    loaderData\r\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => matches.map(m => (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_convertRouteMatchToUiMatch)(m, loaderData)), [matches, loaderData]);\r\n}\r\n\r\n/**\r\n * Returns the loader data for the nearest ancestor Route loader\r\n */\r\nfunction useLoaderData() {\r\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\r\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\r\n  if (state.errors && state.errors[routeId] != null) {\r\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\r\n    return undefined;\r\n  }\r\n  return state.loaderData[routeId];\r\n}\r\n\r\n/**\r\n * Returns the loaderData for the given routeId\r\n */\r\nfunction useRouteLoaderData(routeId) {\r\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\r\n  return state.loaderData[routeId];\r\n}\r\n\r\n/**\r\n * Returns the action data for the nearest ancestor Route action\r\n */\r\nfunction useActionData() {\r\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\r\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\r\n  return state.actionData ? state.actionData[routeId] : undefined;\r\n}\r\n\r\n/**\r\n * Returns the nearest ancestor Route error, which could be a loader/action\r\n * error or a render error.  This is intended to be called from your\r\n * ErrorBoundary/errorElement to display a proper error message.\r\n */\r\nfunction useRouteError() {\r\n  var _state$errors;\r\n  let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\r\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\r\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\r\n\r\n  // If this was a render error, we put it in a RouteError context inside\r\n  // of RenderErrorBoundary\r\n  if (error !== undefined) {\r\n    return error;\r\n  }\r\n\r\n  // Otherwise look for errors from our data router state\r\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\r\n}\r\n\r\n/**\r\n * Returns the happy-path data from the nearest ancestor `<Await />` value\r\n */\r\nfunction useAsyncValue() {\r\n  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\r\n  return value == null ? void 0 : value._data;\r\n}\r\n\r\n/**\r\n * Returns the error from the nearest ancestor `<Await />` value\r\n */\r\nfunction useAsyncError() {\r\n  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\r\n  return value == null ? void 0 : value._error;\r\n}\r\nlet blockerId = 0;\r\n\r\n/**\r\n * Allow the application to block navigations within the SPA and present the\r\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\r\n * using half-filled form data.  This does not handle hard-reloads or\r\n * cross-origin navigations.\r\n */\r\nfunction useBlocker(shouldBlock) {\r\n  let {\r\n    router,\r\n    basename\r\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\r\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\r\n  let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\");\r\n  let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(arg => {\r\n    if (typeof shouldBlock !== \"function\") {\r\n      return !!shouldBlock;\r\n    }\r\n    if (basename === \"/\") {\r\n      return shouldBlock(arg);\r\n    }\r\n\r\n    // If they provided us a function and we've got an active basename, strip\r\n    // it from the locations we expose to the user to match the behavior of\r\n    // useLocation\r\n    let {\r\n      currentLocation,\r\n      nextLocation,\r\n      historyAction\r\n    } = arg;\r\n    return shouldBlock({\r\n      currentLocation: _extends({}, currentLocation, {\r\n        pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\r\n      }),\r\n      nextLocation: _extends({}, nextLocation, {\r\n        pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\r\n      }),\r\n      historyAction\r\n    });\r\n  }, [basename, shouldBlock]);\r\n\r\n  // This effect is in charge of blocker key assignment and deletion (which is\r\n  // tightly coupled to the key)\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    let key = String(++blockerId);\r\n    setBlockerKey(key);\r\n    return () => router.deleteBlocker(key);\r\n  }, [router]);\r\n\r\n  // This effect handles assigning the blockerFunction.  This is to handle\r\n  // unstable blocker function identities, and happens only after the prior\r\n  // effect so we don't get an orphaned blockerFunction in the router with a\r\n  // key of \"\".  Until then we just have the IDLE_BLOCKER.\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (blockerKey !== \"\") {\r\n      router.getBlocker(blockerKey, blockerFunction);\r\n    }\r\n  }, [router, blockerKey, blockerFunction]);\r\n\r\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\r\n  // is memoized so this ensures we update on blocker state updates\r\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.IDLE_BLOCKER;\r\n}\r\n\r\n/**\r\n * Stable version of useNavigate that is used when we are in the context of\r\n * a RouterProvider.\r\n */\r\nfunction useNavigateStable() {\r\n  let {\r\n    router\r\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\r\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\r\n  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\r\n  useIsomorphicLayoutEffect(() => {\r\n    activeRef.current = true;\r\n  });\r\n  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (to, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\r\n\r\n    // Short circuit here since if this happens on first render the navigate\r\n    // is useless because we haven't wired up our router subscriber yet\r\n    if (!activeRef.current) return;\r\n    if (typeof to === \"number\") {\r\n      router.navigate(to);\r\n    } else {\r\n      router.navigate(to, _extends({\r\n        fromRouteId: id\r\n      }, options));\r\n    }\r\n  }, [router, id]);\r\n  return navigate;\r\n}\r\nconst alreadyWarned = {};\r\nfunction warningOnce(key, cond, message) {\r\n  if (!cond && !alreadyWarned[key]) {\r\n    alreadyWarned[key] = true;\r\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, message) : 0;\r\n  }\r\n}\r\n\r\n/**\r\n  Webpack + React 17 fails to compile on any of the following because webpack\r\n  complains that `startTransition` doesn't exist in `React`:\r\n  * import { startTransition } from \"react\"\r\n  * import * as React from from \"react\";\r\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\r\n  * import * as React from from \"react\";\r\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\r\n\r\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\r\n  * import * as React from from \"react\";\r\n    const START_TRANSITION = \"startTransition\";\r\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\r\n\r\n  However, that introduces webpack/terser minification issues in production builds\r\n  in React 18 where minification/obfuscation ends up removing the call of\r\n  React.startTransition entirely from the first half of the ternary.  Grabbing\r\n  this exported reference once up front resolves that issue.\r\n\r\n  See https://github.com/remix-run/react-router/issues/10579\r\n*/\r\nconst START_TRANSITION = \"startTransition\";\r\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\r\n\r\n/**\r\n * Given a Remix Router instance, render the appropriate UI\r\n */\r\nfunction RouterProvider(_ref) {\r\n  let {\r\n    fallbackElement,\r\n    router,\r\n    future\r\n  } = _ref;\r\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\r\n  let {\r\n    v7_startTransition\r\n  } = future || {};\r\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\r\n    if (v7_startTransition && startTransitionImpl) {\r\n      startTransitionImpl(() => setStateImpl(newState));\r\n    } else {\r\n      setStateImpl(newState);\r\n    }\r\n  }, [setStateImpl, v7_startTransition]);\r\n\r\n  // Need to use a layout effect here so we are subscribed early enough to\r\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\r\n    // Only log this once on initial mount\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n  let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    return {\r\n      createHref: router.createHref,\r\n      encodeLocation: router.encodeLocation,\r\n      go: n => router.navigate(n),\r\n      push: (to, state, opts) => router.navigate(to, {\r\n        state,\r\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\r\n      }),\r\n      replace: (to, state, opts) => router.navigate(to, {\r\n        replace: true,\r\n        state,\r\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\r\n      })\r\n    };\r\n  }, [router]);\r\n  let basename = router.basename || \"/\";\r\n  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\r\n    router,\r\n    navigator,\r\n    static: false,\r\n    basename\r\n  }), [router, navigator, basename]);\r\n\r\n  // The fragment and {null} here are important!  We need them to keep React 18's\r\n  // useId happy when we are server-rendering since we may have a <script> here\r\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\r\n  // useId relies on the component tree structure to generate deterministic id's\r\n  // so we need to ensure it remains the same on the client even though\r\n  // we don't need the <script> tag\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\r\n    value: dataRouterContext\r\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\r\n    value: state\r\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\r\n    basename: basename,\r\n    location: state.location,\r\n    navigationType: state.historyAction,\r\n    navigator: navigator,\r\n    future: {\r\n      v7_relativeSplatPath: router.future.v7_relativeSplatPath\r\n    }\r\n  }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\r\n    routes: router.routes,\r\n    future: router.future,\r\n    state: state\r\n  }) : fallbackElement))), null);\r\n}\r\nfunction DataRoutes(_ref2) {\r\n  let {\r\n    routes,\r\n    future,\r\n    state\r\n  } = _ref2;\r\n  return useRoutesImpl(routes, undefined, state, future);\r\n}\r\n/**\r\n * A `<Router>` that stores all entries in memory.\r\n *\r\n * @see https://reactrouter.com/router-components/memory-router\r\n */\r\nfunction MemoryRouter(_ref3) {\r\n  let {\r\n    basename,\r\n    children,\r\n    initialEntries,\r\n    initialIndex,\r\n    future\r\n  } = _ref3;\r\n  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\r\n  if (historyRef.current == null) {\r\n    historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\r\n      initialEntries,\r\n      initialIndex,\r\n      v5Compat: true\r\n    });\r\n  }\r\n  let history = historyRef.current;\r\n  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  let {\r\n    v7_startTransition\r\n  } = future || {};\r\n  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {\r\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\r\n  }, [setStateImpl, v7_startTransition]);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\r\n    basename: basename,\r\n    children: children,\r\n    location: state.location,\r\n    navigationType: state.action,\r\n    navigator: history,\r\n    future: future\r\n  });\r\n}\r\n/**\r\n * Changes the current location.\r\n *\r\n * Note: This API is mostly useful in React.Component subclasses that are not\r\n * able to use hooks. In functional components, we recommend you use the\r\n * `useNavigate` hook instead.\r\n *\r\n * @see https://reactrouter.com/components/navigate\r\n */\r\nfunction Navigate(_ref4) {\r\n  let {\r\n    to,\r\n    replace,\r\n    state,\r\n    relative\r\n  } = _ref4;\r\n  !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // TODO: This error is probably because they somehow have 2 versions of\r\n  // the router loaded. We can help them understand how to avoid that.\r\n  \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\r\n  let {\r\n    future,\r\n    static: isStatic\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\r\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\r\n  let {\r\n    matches\r\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\r\n  let {\r\n    pathname: locationPathname\r\n  } = useLocation();\r\n  let navigate = useNavigate();\r\n\r\n  // Resolve the path outside of the effect so that when effects run twice in\r\n  // StrictMode they navigate to the same place\r\n  let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\r\n  let jsonPath = JSON.stringify(path);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => navigate(JSON.parse(jsonPath), {\r\n    replace,\r\n    state,\r\n    relative\r\n  }), [navigate, jsonPath, relative, replace, state]);\r\n  return null;\r\n}\r\n/**\r\n * Renders the child route's element, if there is one.\r\n *\r\n * @see https://reactrouter.com/components/outlet\r\n */\r\nfunction Outlet(props) {\r\n  return useOutlet(props.context);\r\n}\r\n/**\r\n * Declares an element that should be rendered at a certain URL path.\r\n *\r\n * @see https://reactrouter.com/components/route\r\n */\r\nfunction Route(_props) {\r\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0 ;\r\n}\r\n/**\r\n * Provides location context for the rest of the app.\r\n *\r\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\r\n * router that is more specific to your environment such as a `<BrowserRouter>`\r\n * in web browsers or a `<StaticRouter>` for server rendering.\r\n *\r\n * @see https://reactrouter.com/router-components/router\r\n */\r\nfunction Router(_ref5) {\r\n  let {\r\n    basename: basenameProp = \"/\",\r\n    children = null,\r\n    location: locationProp,\r\n    navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop,\r\n    navigator,\r\n    static: staticProp = false,\r\n    future\r\n  } = _ref5;\r\n  !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0;\r\n\r\n  // Preserve trailing slashes on basename, so we can let the user control\r\n  // the enforcement of trailing slashes throughout the app\r\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\r\n  let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\r\n    basename,\r\n    navigator,\r\n    static: staticProp,\r\n    future: _extends({\r\n      v7_relativeSplatPath: false\r\n    }, future)\r\n  }), [basename, future, navigator, staticProp]);\r\n  if (typeof locationProp === \"string\") {\r\n    locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);\r\n  }\r\n  let {\r\n    pathname = \"/\",\r\n    search = \"\",\r\n    hash = \"\",\r\n    state = null,\r\n    key = \"default\"\r\n  } = locationProp;\r\n  let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, basename);\r\n    if (trailingPathname == null) {\r\n      return null;\r\n    }\r\n    return {\r\n      location: {\r\n        pathname: trailingPathname,\r\n        search,\r\n        hash,\r\n        state,\r\n        key\r\n      },\r\n      navigationType\r\n    };\r\n  }, [basename, pathname, search, hash, state, key, navigationType]);\r\n   true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : 0;\r\n  if (locationContext == null) {\r\n    return null;\r\n  }\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\r\n    value: navigationContext\r\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\r\n    children: children,\r\n    value: locationContext\r\n  }));\r\n}\r\n/**\r\n * A container for a nested tree of `<Route>` elements that renders the branch\r\n * that best matches the current location.\r\n *\r\n * @see https://reactrouter.com/components/routes\r\n */\r\nfunction Routes(_ref6) {\r\n  let {\r\n    children,\r\n    location\r\n  } = _ref6;\r\n  return useRoutes(createRoutesFromChildren(children), location);\r\n}\r\n/**\r\n * Component to use for rendering lazily loaded data from returning defer()\r\n * in a loader function\r\n */\r\nfunction Await(_ref7) {\r\n  let {\r\n    children,\r\n    errorElement,\r\n    resolve\r\n  } = _ref7;\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {\r\n    resolve: resolve,\r\n    errorElement: errorElement\r\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));\r\n}\r\nvar AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\r\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\r\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\r\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\r\n  return AwaitRenderStatus;\r\n}(AwaitRenderStatus || {});\r\nconst neverSettledPromise = new Promise(() => {});\r\nclass AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      error: null\r\n    };\r\n  }\r\n  static getDerivedStateFromError(error) {\r\n    return {\r\n      error\r\n    };\r\n  }\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\r\n  }\r\n  render() {\r\n    let {\r\n      children,\r\n      errorElement,\r\n      resolve\r\n    } = this.props;\r\n    let promise = null;\r\n    let status = AwaitRenderStatus.pending;\r\n    if (!(resolve instanceof Promise)) {\r\n      // Didn't get a promise - provide as a resolved promise\r\n      status = AwaitRenderStatus.success;\r\n      promise = Promise.resolve();\r\n      Object.defineProperty(promise, \"_tracked\", {\r\n        get: () => true\r\n      });\r\n      Object.defineProperty(promise, \"_data\", {\r\n        get: () => resolve\r\n      });\r\n    } else if (this.state.error) {\r\n      // Caught a render error, provide it as a rejected promise\r\n      status = AwaitRenderStatus.error;\r\n      let renderError = this.state.error;\r\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\r\n      Object.defineProperty(promise, \"_tracked\", {\r\n        get: () => true\r\n      });\r\n      Object.defineProperty(promise, \"_error\", {\r\n        get: () => renderError\r\n      });\r\n    } else if (resolve._tracked) {\r\n      // Already tracked promise - check contents\r\n      promise = resolve;\r\n      status = \"_error\" in promise ? AwaitRenderStatus.error : \"_data\" in promise ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\r\n    } else {\r\n      // Raw (untracked) promise - track it\r\n      status = AwaitRenderStatus.pending;\r\n      Object.defineProperty(resolve, \"_tracked\", {\r\n        get: () => true\r\n      });\r\n      promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\r\n        get: () => data\r\n      }), error => Object.defineProperty(resolve, \"_error\", {\r\n        get: () => error\r\n      }));\r\n    }\r\n    if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError) {\r\n      // Freeze the UI by throwing a never resolved promise\r\n      throw neverSettledPromise;\r\n    }\r\n    if (status === AwaitRenderStatus.error && !errorElement) {\r\n      // No errorElement, throw to the nearest route-level error boundary\r\n      throw promise._error;\r\n    }\r\n    if (status === AwaitRenderStatus.error) {\r\n      // Render via our errorElement\r\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\r\n        value: promise,\r\n        children: errorElement\r\n      });\r\n    }\r\n    if (status === AwaitRenderStatus.success) {\r\n      // Render children with resolved value\r\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\r\n        value: promise,\r\n        children: children\r\n      });\r\n    }\r\n\r\n    // Throw to the suspense boundary\r\n    throw promise;\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\r\n */\r\nfunction ResolveAwait(_ref8) {\r\n  let {\r\n    children\r\n  } = _ref8;\r\n  let data = useAsyncValue();\r\n  let toRender = typeof children === \"function\" ? children(data) : children;\r\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n// UTILS\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Creates a route config from a React \"children\" object, which is usually\r\n * either a `<Route>` element or an array of them. Used internally by\r\n * `<Routes>` to create a route config from its children.\r\n *\r\n * @see https://reactrouter.com/utils/create-routes-from-children\r\n */\r\nfunction createRoutesFromChildren(children, parentPath) {\r\n  if (parentPath === void 0) {\r\n    parentPath = [];\r\n  }\r\n  let routes = [];\r\n  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index) => {\r\n    if (! /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\r\n      // Ignore non-elements. This allows people to more easily inline\r\n      // conditionals in their route config.\r\n      return;\r\n    }\r\n    let treePath = [...parentPath, index];\r\n    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\r\n      // Transparently support React.Fragment and its children.\r\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\r\n      return;\r\n    }\r\n    !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\r\n    !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\r\n    let route = {\r\n      id: element.props.id || treePath.join(\"-\"),\r\n      caseSensitive: element.props.caseSensitive,\r\n      element: element.props.element,\r\n      Component: element.props.Component,\r\n      index: element.props.index,\r\n      path: element.props.path,\r\n      loader: element.props.loader,\r\n      action: element.props.action,\r\n      errorElement: element.props.errorElement,\r\n      ErrorBoundary: element.props.ErrorBoundary,\r\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\r\n      shouldRevalidate: element.props.shouldRevalidate,\r\n      handle: element.props.handle,\r\n      lazy: element.props.lazy\r\n    };\r\n    if (element.props.children) {\r\n      route.children = createRoutesFromChildren(element.props.children, treePath);\r\n    }\r\n    routes.push(route);\r\n  });\r\n  return routes;\r\n}\r\n\r\n/**\r\n * Renders the result of `matchRoutes()` into a React element.\r\n */\r\nfunction renderMatches(matches) {\r\n  return _renderMatches(matches);\r\n}\r\n\r\nfunction mapRouteProperties(route) {\r\n  let updates = {\r\n    // Note: this check also occurs in createRoutesFromChildren so update\r\n    // there if you change this -- please and thank you!\r\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\r\n  };\r\n  if (route.Component) {\r\n    if (true) {\r\n      if (route.element) {\r\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : 0;\r\n      }\r\n    }\r\n    Object.assign(updates, {\r\n      element: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\r\n      Component: undefined\r\n    });\r\n  }\r\n  if (route.HydrateFallback) {\r\n    if (true) {\r\n      if (route.hydrateFallbackElement) {\r\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") : 0;\r\n      }\r\n    }\r\n    Object.assign(updates, {\r\n      hydrateFallbackElement: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),\r\n      HydrateFallback: undefined\r\n    });\r\n  }\r\n  if (route.ErrorBoundary) {\r\n    if (true) {\r\n      if (route.errorElement) {\r\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : 0;\r\n      }\r\n    }\r\n    Object.assign(updates, {\r\n      errorElement: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\r\n      ErrorBoundary: undefined\r\n    });\r\n  }\r\n  return updates;\r\n}\r\nfunction createMemoryRouter(routes, opts) {\r\n  return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\r\n    basename: opts == null ? void 0 : opts.basename,\r\n    future: _extends({}, opts == null ? void 0 : opts.future, {\r\n      v7_prependBasename: true\r\n    }),\r\n    history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\r\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\r\n      initialIndex: opts == null ? void 0 : opts.initialIndex\r\n    }),\r\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\r\n    routes,\r\n    mapRouteProperties,\r\n    dataStrategy: opts == null ? void 0 : opts.dataStrategy,\r\n    patchRoutesOnNavigation: opts == null ? void 0 : opts.patchRoutesOnNavigation\r\n  }).initialize();\r\n}\r\n\r\n\r\n//# sourceMappingURL=index.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytCO0FBQ3FTO0FBQy9GO0FBQ3JPO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnREFBbUI7QUFDMUQsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0EsNENBQTRDLGdEQUFtQjtBQUMvRCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQW1CO0FBQ3JELElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnREFBbUI7QUFDMUQsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0EscUNBQXFDLGdEQUFtQjtBQUN4RCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQSxrQ0FBa0MsZ0RBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQSx1Q0FBdUMsZ0RBQW1CO0FBQzFELElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUIsMEJBQTBCLEtBQXFDLEdBQUcsbUVBQWdCO0FBQ2xGO0FBQ0EsMEVBQTBFLENBQXVCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLElBQUksRUFBRSw2Q0FBZ0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNERBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBcUMsR0FBRyxtRUFBZ0I7QUFDbEY7QUFDQSw4RUFBOEUsQ0FBdUI7QUFDckcsU0FBUyw2Q0FBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBcUMsR0FBRyxtRUFBZ0I7QUFDbEY7QUFDQSwyRUFBMkUsQ0FBdUI7QUFDbEc7QUFDQTtBQUNBLElBQUk7QUFDSixTQUFTLDBDQUFhLE9BQU8sNERBQVMsVUFBVSxvRUFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLDZDQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQXFDLEdBQUcsbUVBQWdCO0FBQ2xGO0FBQ0EsOEVBQThFLENBQXVCO0FBQ3JHLDBCQUEwQiw2Q0FBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsNkNBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJLEVBQUUsNkNBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMENBQTBDLDZFQUEwQjtBQUNwRSxrQkFBa0IseUNBQVk7QUFDOUI7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsOENBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUMsR0FBRyxpRUFBYyw2Q0FBNkMsQ0FBTTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDREQUFTO0FBQ2xFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQyxnREFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFnQjtBQUMvQjtBQUNBLHdCQUF3QixnREFBbUI7QUFDM0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsNkNBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQSxJQUFJLEVBQUUsNkNBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJLEVBQUUsNkNBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMENBQTBDLDZFQUEwQjtBQUNwRSxTQUFTLDBDQUFhLE9BQU8sNERBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBcUMsR0FBRyxtRUFBZ0I7QUFDbEY7QUFDQSw0RUFBNEUsQ0FBdUI7QUFDbkc7QUFDQTtBQUNBLElBQUksRUFBRSw2Q0FBZ0I7QUFDdEI7QUFDQTtBQUNBLElBQUksRUFBRSw2Q0FBZ0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQywwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNERBQVM7QUFDdkUsc0tBQXNLLEtBQXFDLEdBQUcsbUVBQWdCLHdYQUF3WCxDQUF1QjtBQUM3bUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBVztBQUMzQjtBQUNBLEdBQUc7QUFDSCxNQUFNLElBQXFDO0FBQzNDLElBQUksS0FBcUMsR0FBRyxpRUFBYyxrSUFBa0ksQ0FBTTtBQUNsTSxJQUFJLEtBQXFDLEdBQUcsaUVBQWMsNGJBQTRiLENBQU07QUFDNWY7QUFDQSx1RkFBdUY7QUFDdkYsNEJBQTRCO0FBQzVCLGNBQWMsNERBQVM7QUFDdkI7QUFDQTtBQUNBLG9FQUFvRSw0REFBUztBQUM3RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QixxREFBTTtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBLDJCQUEyQixnREFBbUIsQ0FBQywyQ0FBYyxxQkFBcUIsZ0RBQW1CLHFFQUFxRSxnREFBbUIseUhBQXlILGdEQUFtQjtBQUN6VTtBQUNBLEtBQUssNkNBQTZDLGdEQUFtQjtBQUNyRTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixnREFBbUIsQ0FBQywyQ0FBYyxxQkFBcUIsZ0RBQW1CLDREQUE0RCxnREFBbUI7QUFDL0s7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQ0FBaUMsZ0RBQW1CO0FBQ3ZEO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUNBQXlDLGdEQUFtQjtBQUM1RCxrQ0FBa0MsNENBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnREFBbUI7QUFDNUU7QUFDQSxLQUFLLGVBQWUsZ0RBQW1CO0FBQ3ZDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMEJBQTBCLDZDQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBcUMsR0FBRyxtRUFBZ0IsdUdBQXVHLENBQXVCO0FBQy9NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFtQjtBQUNuRCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBCQUEwQixnREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxnREFBbUI7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBZ0I7QUFDNUIsU0FBUyxLQUFxQyxHQUFHLG1FQUFnQiwrQ0FBK0MsQ0FBdUI7QUFDdkk7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBZ0I7QUFDOUIsV0FBVyxLQUFxQyxHQUFHLG1FQUFnQiwrQ0FBK0MsQ0FBdUI7QUFDekk7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2Q0FBZ0I7QUFDOUIsV0FBVyxLQUFxQyxHQUFHLG1FQUFnQiwrQ0FBK0MsQ0FBdUI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUMsR0FBRyxtRUFBZ0IsaUZBQWlGLENBQXVCO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBDQUFhO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUywwQ0FBYSx3QkFBd0Isb0ZBQWlDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkNBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkNBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQ0FBb0MsMkNBQWM7QUFDbEQsd0JBQXdCLDhDQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0NBQWtDO0FBQ2xDLGtCQUFrQixnRUFBYTtBQUMvQixPQUFPO0FBQ1AsK0JBQStCO0FBQy9CLGtCQUFrQixnRUFBYTtBQUMvQixPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsMkRBQVk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0JBQWtCLHlDQUFZO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLDhDQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQXFDLEdBQUcsaUVBQWMsNkNBQTZDLENBQU07QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFxQyxHQUFHLGlFQUFjLG1CQUFtQixDQUFNO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOEJBQThCLDJDQUFjO0FBQzVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUJBQWlCLDhDQUFpQjtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRSxrREFBcUI7QUFDdkIsRUFBRSw0Q0FBZTtBQUNqQixJQUFJLEtBQXFDLEdBQUcsaUVBQWMsdU1BQXVNLENBQU07QUFDdlE7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsMENBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQkFBMEIsMENBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFtQixDQUFDLDJDQUFjLHFCQUFxQixnREFBbUI7QUFDaEc7QUFDQSxHQUFHLGVBQWUsZ0RBQW1CO0FBQ3JDO0FBQ0EsR0FBRyxlQUFlLGdEQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0VBQXdFLGdEQUFtQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osbUJBQW1CLHlDQUFZO0FBQy9CO0FBQ0EseUJBQXlCLHNFQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBYztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUJBQWlCLDhDQUFpQjtBQUNsQztBQUNBLEdBQUc7QUFDSCxFQUFFLGtEQUFxQjtBQUN2QixzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwwQkFBMEIsS0FBcUMsR0FBRyxtRUFBZ0I7QUFDbEY7QUFDQSwyRUFBMkUsQ0FBdUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLDZDQUFnQjtBQUN0QixFQUFFLEtBQXFDLEdBQUcsaUVBQWMsaVBBQWlQLENBQU07QUFDL1M7QUFDQTtBQUNBLElBQUksRUFBRSw2Q0FBZ0I7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNERBQVMsS0FBSyw2RUFBMEI7QUFDckQ7QUFDQSxFQUFFLDRDQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBcUMsR0FBRyxtRUFBZ0IsdUpBQXVKLENBQXVCO0FBQ3hPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkJBQTJCLEtBQXFDLEdBQUcsbUVBQWdCLHlIQUF5SCxDQUF1QjtBQUNuTztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLG1CQUFtQiw0REFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix3QkFBd0IsMENBQWE7QUFDckMsMkJBQTJCLGdFQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxLQUFxQyxHQUFHLGlFQUFjLHdPQUF3TyxDQUFNO0FBQ3RTO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQSxHQUFHLGVBQWUsZ0RBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQTtBQUNBLEdBQUcsZUFBZSxnREFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekIsZ0RBQWdEO0FBQ2hELGlDQUFpQyw0Q0FBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHO0FBQ2xEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3RUFBd0UsbUVBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBbUI7QUFDN0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0RBQW1CO0FBQzdDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFtQixDQUFDLDJDQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkNBQWM7QUFDaEIsdUJBQXVCLGlEQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJDQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQXFDLEdBQUcsbUVBQWdCLGtNQUFrTSxDQUF1QjtBQUNqVCx5REFBeUQsS0FBcUMsR0FBRyxtRUFBZ0Isc0RBQXNELENBQXVCO0FBQzlMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxRQUFRLEtBQXFDLEdBQUcsaUVBQWMsa0hBQWtILENBQU07QUFDdEw7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFtQjtBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBLFFBQVEsS0FBcUMsR0FBRyxpRUFBYyw2SUFBNkksQ0FBTTtBQUNqTjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0RBQW1CO0FBQzlEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0EsUUFBUSxLQUFxQyxHQUFHLGlFQUFjLCtIQUErSCxDQUFNO0FBQ25NO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnREFBbUI7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFZO0FBQ3JCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMLGFBQWEsc0VBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ3kxQjtBQUN6MUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2luZGV4LmpzPzJhMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFJlYWN0IFJvdXRlciB2Ni4yNy4wXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxyXG4gKlxyXG4gKiBAbGljZW5zZSBNSVRcclxuICovXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgVU5TQUZFX2ludmFyaWFudCwgam9pblBhdGhzLCBtYXRjaFBhdGgsIFVOU0FGRV9kZWNvZGVQYXRoLCBVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcywgVU5TQUZFX3dhcm5pbmcsIHJlc29sdmVUbywgcGFyc2VQYXRoLCBtYXRjaFJvdXRlcywgQWN0aW9uLCBVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gsIHN0cmlwQmFzZW5hbWUsIElETEVfQkxPQ0tFUiwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGNyZWF0ZU1lbW9yeUhpc3RvcnksIEFib3J0ZWREZWZlcnJlZEVycm9yLCBjcmVhdGVSb3V0ZXIgfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XHJcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsIGNyZWF0ZVBhdGgsIGRlZmVyLCBnZW5lcmF0ZVBhdGgsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBqc29uLCBtYXRjaFBhdGgsIG1hdGNoUm91dGVzLCBwYXJzZVBhdGgsIHJlZGlyZWN0LCByZWRpcmVjdERvY3VtZW50LCByZXBsYWNlLCByZXNvbHZlUGF0aCB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcclxuXHJcbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xyXG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XHJcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9O1xyXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG4vLyBDcmVhdGUgcmVhY3Qtc3BlY2lmaWMgdHlwZXMgZnJvbSB0aGUgYWdub3N0aWMgdHlwZXMgaW4gQHJlbWl4LXJ1bi9yb3V0ZXIgdG9cclxuLy8gZXhwb3J0IGZyb20gcmVhY3Qtcm91dGVyXHJcbmNvbnN0IERhdGFSb3V0ZXJDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICBEYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xyXG59XHJcbmNvbnN0IERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJTdGF0ZVwiO1xyXG59XHJcbmNvbnN0IEF3YWl0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgQXdhaXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJBd2FpdFwiO1xyXG59XHJcblxyXG4vKipcclxuICogQSBOYXZpZ2F0b3IgaXMgYSBcImxvY2F0aW9uIGNoYW5nZXJcIjsgaXQncyBob3cgeW91IGdldCB0byBkaWZmZXJlbnQgbG9jYXRpb25zLlxyXG4gKlxyXG4gKiBFdmVyeSBoaXN0b3J5IGluc3RhbmNlIGNvbmZvcm1zIHRvIHRoZSBOYXZpZ2F0b3IgaW50ZXJmYWNlLCBidXQgdGhlXHJcbiAqIGRpc3RpbmN0aW9uIGlzIHVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpdCBjb21lcyB0byB0aGUgbG93LWxldmVsIGA8Um91dGVyPmAgQVBJXHJcbiAqIHdoZXJlIGJvdGggdGhlIGxvY2F0aW9uIGFuZCBhIG5hdmlnYXRvciBtdXN0IGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgaW4gb3JkZXJcclxuICogdG8gYXZvaWQgXCJ0ZWFyaW5nXCIgdGhhdCBtYXkgb2NjdXIgaW4gYSBzdXNwZW5zZS1lbmFibGVkIGFwcCBpZiB0aGUgYWN0aW9uXHJcbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cclxuICovXHJcblxyXG5jb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcclxufVxyXG5jb25zdCBMb2NhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIExvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcclxufVxyXG5jb25zdCBSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XHJcbiAgb3V0bGV0OiBudWxsLFxyXG4gIG1hdGNoZXM6IFtdLFxyXG4gIGlzRGF0YVJvdXRlOiBmYWxzZVxyXG59KTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcclxufVxyXG5jb25zdCBSb3V0ZUVycm9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZ1bGwgaHJlZiBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGJ1aWxkaW5nXHJcbiAqIGN1c3RvbSBsaW5rcyB0aGF0IGFyZSBhbHNvIGFjY2Vzc2libGUgYW5kIHByZXNlcnZlIHJpZ2h0LWNsaWNrIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1ocmVmXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VIcmVmKHRvLCBfdGVtcCkge1xyXG4gIGxldCB7XHJcbiAgICByZWxhdGl2ZVxyXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcclxuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcclxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXHJcbiAgXCJ1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICBsZXQge1xyXG4gICAgYmFzZW5hbWUsXHJcbiAgICBuYXZpZ2F0b3JcclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XHJcbiAgbGV0IHtcclxuICAgIGhhc2gsXHJcbiAgICBwYXRobmFtZSxcclxuICAgIHNlYXJjaFxyXG4gIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcclxuICAgIHJlbGF0aXZlXHJcbiAgfSk7XHJcbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XHJcblxyXG4gIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcclxuICAvLyB0byBjcmVhdGluZyB0aGUgaHJlZi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhd1xyXG4gIC8vIGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2VcclxuICAvLyBvZiBhIHRyYWlsaW5nIHNsYXNoIG9uIHJvb3QgbGlua3NcclxuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XHJcbiAgICBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcclxuICB9XHJcbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHtcclxuICAgIHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSxcclxuICAgIHNlYXJjaCxcclxuICAgIGhhc2hcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYSBgPFJvdXRlcj5gLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1pbi1yb3V0ZXItY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCkge1xyXG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IFVSTCBpbiB3ZWJcclxuICogYnJvd3NlcnMuXHJcbiAqXHJcbiAqIE5vdGU6IElmIHlvdSdyZSB1c2luZyB0aGlzIGl0IG1heSBtZWFuIHlvdSdyZSBkb2luZyBzb21lIG9mIHlvdXIgb3duXHJcbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcclxuICogYmUgYWJsZSB0byBwcm92aWRlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdG8gYmV0dGVyIHN1aXQgeW91ciBuZWVkcy5cclxuICpcclxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbG9jYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xyXG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxyXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cclxuICBcInVzZUxvY2F0aW9uKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xyXG4gKiB0aGUgY3VycmVudCBsb2NhdGlvbiwgZWl0aGVyIGJ5IGEgcG9wLCBwdXNoLCBvciByZXBsYWNlIG9uIHRoZSBoaXN0b3J5IHN0YWNrLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1uYXZpZ2F0aW9uLXR5cGVcclxuICovXHJcbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCkge1xyXG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgUGF0aE1hdGNoIG9iamVjdCBpZiB0aGUgZ2l2ZW4gcGF0dGVybiBtYXRjaGVzIHRoZSBjdXJyZW50IFVSTC5cclxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgXCJhY3RpdmVcIiBzdGF0ZSwgZS5nLlxyXG4gKiBgPE5hdkxpbms+YC5cclxuICpcclxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbWF0Y2hcclxuICovXHJcbmZ1bmN0aW9uIHVzZU1hdGNoKHBhdHRlcm4pIHtcclxuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcclxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXHJcbiAgXCJ1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgbGV0IHtcclxuICAgIHBhdGhuYW1lXHJcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XHJcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hQYXRoKHBhdHRlcm4sIFVOU0FGRV9kZWNvZGVQYXRoKHBhdGhuYW1lKSksIFtwYXRobmFtZSwgcGF0dGVybl0pO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGludGVyZmFjZSBmb3IgdGhlIG5hdmlnYXRlKCkgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbSB1c2VOYXZpZ2F0ZSgpLlxyXG4gKi9cclxuXHJcbmNvbnN0IG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IFwiWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4gXCIgKyBcInlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLlwiO1xyXG5cclxuLy8gTXV0ZSB3YXJuaW5ncyBmb3IgY2FsbHMgdG8gdXNlTmF2aWdhdGUgaW4gU1NSIGVudmlyb25tZW50c1xyXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGNiKSB7XHJcbiAgbGV0IGlzU3RhdGljID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xyXG4gIGlmICghaXNTdGF0aWMpIHtcclxuICAgIC8vIFdlIHNob3VsZCBiZSBhYmxlIHRvIGdldCByaWQgb2YgdGhpcyBvbmNlIHJlYWN0IDE4LjMgaXMgcmVsZWFzZWRcclxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xyXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGNiKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgYDxMaW5rPmBzLCBidXRcclxuICogbWF5IGFsc28gYmUgdXNlZCBieSBvdGhlciBlbGVtZW50cyB0byBjaGFuZ2UgdGhlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1uYXZpZ2F0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdXNlTmF2aWdhdGUoKSB7XHJcbiAgbGV0IHtcclxuICAgIGlzRGF0YVJvdXRlXHJcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcclxuICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXHJcbiAgcmV0dXJuIGlzRGF0YVJvdXRlID8gdXNlTmF2aWdhdGVTdGFibGUoKSA6IHVzZU5hdmlnYXRlVW5zdGFibGUoKTtcclxufVxyXG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCkge1xyXG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxyXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cclxuICBcInVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcclxuICBsZXQge1xyXG4gICAgYmFzZW5hbWUsXHJcbiAgICBmdXR1cmUsXHJcbiAgICBuYXZpZ2F0b3JcclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XHJcbiAgbGV0IHtcclxuICAgIG1hdGNoZXNcclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xyXG4gIGxldCB7XHJcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxyXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xyXG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpKTtcclxuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcclxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICB9KTtcclxuICBsZXQgbmF2aWdhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodG8sIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcclxuICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZykgOiB2b2lkIDA7XHJcblxyXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBoZXJlIHNpbmNlIGlmIHRoaXMgaGFwcGVucyBvbiBmaXJzdCByZW5kZXIgdGhlIG5hdmlnYXRlXHJcbiAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgaGlzdG9yeSBsaXN0ZW5lciB5ZXRcclxuICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSA9PT0gXCJwYXRoXCIpO1xyXG5cclxuICAgIC8vIElmIHdlJ3JlIG9wZXJhdGluZyB3aXRoaW4gYSBiYXNlbmFtZSwgcHJlcGVuZCBpdCB0byB0aGUgcGF0aG5hbWUgcHJpb3JcclxuICAgIC8vIHRvIGhhbmRpbmcgb2ZmIHRvIGhpc3RvcnkgKGJ1dCBvbmx5IGlmIHdlJ3JlIG5vdCBpbiBhIGRhdGEgcm91dGVyLFxyXG4gICAgLy8gb3RoZXJ3aXNlIGl0J2xsIHByZXBlbmQgdGhlIGJhc2VuYW1lIGluc2lkZSBvZiB0aGUgcm91dGVyKS5cclxuICAgIC8vIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4gd2UgbmF2aWdhdGUgdG8gdGhlIHJhdyBiYXNlbmFtZVxyXG4gICAgLy8gd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZSBvZiBhXHJcbiAgICAvLyB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXHJcbiAgICBpZiAoZGF0YVJvdXRlckNvbnRleHQgPT0gbnVsbCAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcclxuICAgICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XHJcbiAgICB9XHJcbiAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IucmVwbGFjZSA6IG5hdmlnYXRvci5wdXNoKShwYXRoLCBvcHRpb25zLnN0YXRlLCBvcHRpb25zKTtcclxuICB9LCBbYmFzZW5hbWUsIG5hdmlnYXRvciwgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCBkYXRhUm91dGVyQ29udGV4dF0pO1xyXG4gIHJldHVybiBuYXZpZ2F0ZTtcclxufVxyXG5jb25zdCBPdXRsZXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcclxuICogaGllcmFyY2h5LlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1vdXRsZXQtY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcclxuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChPdXRsZXRDb250ZXh0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxyXG4gKiBoaWVyYXJjaHkuIFVzZWQgaW50ZXJuYWxseSBieSBgPE91dGxldD5gIHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW91dGxldFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlT3V0bGV0KGNvbnRleHQpIHtcclxuICBsZXQgb3V0bGV0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcclxuICBpZiAob3V0bGV0KSB7XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGV0Q29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgICB2YWx1ZTogY29udGV4dFxyXG4gICAgfSwgb3V0bGV0KTtcclxuICB9XHJcbiAgcmV0dXJuIG91dGxldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxyXG4gKiBVUkwgdGhhdCB3ZXJlIG1hdGNoZWQgYnkgdGhlIHJvdXRlIHBhdGguXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXBhcmFtc1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlUGFyYW1zKCkge1xyXG4gIGxldCB7XHJcbiAgICBtYXRjaGVzXHJcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcclxuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcclxuICByZXR1cm4gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGFyYW1zIDoge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cclxuICpcclxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtcmVzb2x2ZWQtcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvLCBfdGVtcDIpIHtcclxuICBsZXQge1xyXG4gICAgcmVsYXRpdmVcclxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcclxuICBsZXQge1xyXG4gICAgZnV0dXJlXHJcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xyXG4gIGxldCB7XHJcbiAgICBtYXRjaGVzXHJcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcclxuICBsZXQge1xyXG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcclxuICB9ID0gdXNlTG9jYXRpb24oKTtcclxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKSk7XHJcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gcmVzb2x2ZVRvKHRvLCBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlID09PSBcInBhdGhcIiksIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZV0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxyXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHQgdG8gcmVuZGVyIHRoZSByZW1haW5kZXIgb2YgdGhlIHJvdXRlIHRyZWUuIFJvdXRlXHJcbiAqIGVsZW1lbnRzIGluIHRoZSB0cmVlIG11c3QgcmVuZGVyIGFuIGA8T3V0bGV0PmAgdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcclxuICogZWxlbWVudC5cclxuICpcclxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utcm91dGVzXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbkFyZykge1xyXG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcpO1xyXG59XHJcblxyXG4vLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiB3aXRoIGFjY2VwdCBvcHRpb25hbCBwYXJhbSBmb3IgUm91dGVyUHJvdmlkZXIgdXNhZ2VcclxuZnVuY3Rpb24gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xyXG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxyXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cclxuICBcInVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgbGV0IHtcclxuICAgIG5hdmlnYXRvclxyXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcclxuICBsZXQge1xyXG4gICAgbWF0Y2hlczogcGFyZW50TWF0Y2hlc1xyXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XHJcbiAgbGV0IHJvdXRlTWF0Y2ggPSBwYXJlbnRNYXRjaGVzW3BhcmVudE1hdGNoZXMubGVuZ3RoIC0gMV07XHJcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xyXG4gIGxldCBwYXJlbnRQYXRobmFtZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lIDogXCIvXCI7XHJcbiAgbGV0IHBhcmVudFBhdGhuYW1lQmFzZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lQmFzZSA6IFwiL1wiO1xyXG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAvLyBZb3Ugd29uJ3QgZ2V0IGEgd2FybmluZyBhYm91dCAyIGRpZmZlcmVudCA8Um91dGVzPiB1bmRlciBhIDxSb3V0ZT5cclxuICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXHJcbiAgICAvLyBjYW5ub3QgZXZlbiBnaXZlIHRoZSB3YXJuaW5nIHVubGVzcyB0aGV5IGxhbmQgYXQgdGhlIHBhcmVudCByb3V0ZS5cclxuICAgIC8vXHJcbiAgICAvLyBFeGFtcGxlOlxyXG4gICAgLy9cclxuICAgIC8vIDxSb3V0ZXM+XHJcbiAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxyXG4gICAgLy8gICAgICAgaXQgd2lsbCBuZXZlciBtYXRjaCAvYmxvZy9wb3N0LzEyMyAqL31cclxuICAgIC8vICAgPFJvdXRlIHBhdGg9XCJibG9nXCIgZWxlbWVudD17PEJsb2cgLz59IC8+XHJcbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxyXG4gICAgLy8gPC9Sb3V0ZXM+XHJcbiAgICAvL1xyXG4gICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcclxuICAgIC8vICAgcmV0dXJuIChcclxuICAgIC8vICAgICA8Um91dGVzPlxyXG4gICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxyXG4gICAgLy8gICAgIDwvUm91dGVzPlxyXG4gICAgLy8gICApO1xyXG4gICAgLy8gfVxyXG4gICAgbGV0IHBhcmVudFBhdGggPSBwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoIHx8IFwiXCI7XHJcbiAgICB3YXJuaW5nT25jZShwYXJlbnRQYXRobmFtZSwgIXBhcmVudFJvdXRlIHx8IHBhcmVudFBhdGguZW5kc1dpdGgoXCIqXCIpLCBcIllvdSByZW5kZXJlZCBkZXNjZW5kYW50IDxSb3V0ZXM+IChvciBjYWxsZWQgYHVzZVJvdXRlcygpYCkgYXQgXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRobmFtZSArIFwiXFxcIiAodW5kZXIgPFJvdXRlIHBhdGg9XFxcIlwiICsgcGFyZW50UGF0aCArIFwiXFxcIj4pIGJ1dCB0aGUgXCIpICsgXCJwYXJlbnQgcm91dGUgcGF0aCBoYXMgbm8gdHJhaWxpbmcgXFxcIipcXFwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBcIiArIFwiZGVlcGVyLCB0aGUgcGFyZW50IHdvbid0IG1hdGNoIGFueW1vcmUgYW5kIHRoZXJlZm9yZSB0aGUgY2hpbGQgXCIgKyBcInJvdXRlcyB3aWxsIG5ldmVyIHJlbmRlci5cXG5cXG5cIiArIChcIlBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPiB0byA8Um91dGUgXCIpICsgKFwicGF0aD1cXFwiXCIgKyAocGFyZW50UGF0aCA9PT0gXCIvXCIgPyBcIipcIiA6IHBhcmVudFBhdGggKyBcIi8qXCIpICsgXCJcXFwiPi5cIikpO1xyXG4gIH1cclxuICBsZXQgbG9jYXRpb25Gcm9tQ29udGV4dCA9IHVzZUxvY2F0aW9uKCk7XHJcbiAgbGV0IGxvY2F0aW9uO1xyXG4gIGlmIChsb2NhdGlvbkFyZykge1xyXG4gICAgdmFyIF9wYXJzZWRMb2NhdGlvbkFyZyRwYTtcclxuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcclxuICAgICEocGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fCAoKF9wYXJzZWRMb2NhdGlvbkFyZyRwYSA9IHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcnNlZExvY2F0aW9uQXJnJHBhLnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIGA8Um91dGVzIGxvY2F0aW9uPmAgb3IgYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKWAsIFwiICsgXCJ0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgXCIgKyAoXCJtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFxcXCJcIiArIHBhcmVudFBhdGhuYW1lQmFzZSArIFwiXFxcIiBcIikgKyAoXCJidXQgcGF0aG5hbWUgXFxcIlwiICsgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUgKyBcIlxcXCIgd2FzIGdpdmVuIGluIHRoZSBgbG9jYXRpb25gIHByb3AuXCIpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcclxuICB9IGVsc2Uge1xyXG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xyXG4gIH1cclxuICBsZXQgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIjtcclxuICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZTtcclxuICBpZiAocGFyZW50UGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgYnkgcmVtb3ZpbmcgdGhlICMgb2YgVVJMIHNlZ21lbnRzIHRoZVxyXG4gICAgLy8gcGFyZW50UGF0aG5hbWVCYXNlIGhhcywgaW5zdGVhZCBvZiByZW1vdmluZyBiYXNlZCBvbiBjaGFyYWN0ZXIgY291bnQuXHJcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2UgY2FuJ3QgZ3VhcmFudGVlIHRoYXQgaW5jb21pbmcvb3V0Z29pbmcgZW5jb2RpbmdzL1xyXG4gICAgLy8gZGVjb2RpbmdzIHdpbGwgbWF0Y2ggZXhhY3RseS5cclxuICAgIC8vIFdlIGRlY29kZSBwYXRocyBiZWZvcmUgbWF0Y2hpbmcgb24gYSBwZXItc2VnbWVudCBiYXNpcyB3aXRoXHJcbiAgICAvLyBkZWNvZGVVUklDb21wb25lbnQoKSwgYnV0IHdlIHJlLWVuY29kZSBwYXRobmFtZXMgdmlhIGBuZXcgVVJMKClgIHNvIHRoZXlcclxuICAgIC8vIG1hdGNoIHdoYXQgYHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZWAgd291bGQgcmVmbGVjdC4gIFRob3NlIGRvbid0IDEwMCVcclxuICAgIC8vIGFsaWduIHdoZW4gaXQgY29tZXMgdG8gZW5jb2RlZCBVUkkgY2hhcmFjdGVycyBzdWNoIGFzICUgYW5kICYuXHJcbiAgICAvL1xyXG4gICAgLy8gU28gd2UgbWF5IGVuZCB1cCB3aXRoOlxyXG4gICAgLy8gICBwYXRobmFtZTogICAgICAgICAgIFwiL2Rlc2NlbmRhbnQvYSUyNWIvbWF0Y2hcIlxyXG4gICAgLy8gICBwYXJlbnRQYXRobmFtZUJhc2U6IFwiL2Rlc2NlbmRhbnQvYSViXCJcclxuICAgIC8vXHJcbiAgICAvLyBBbmQgdGhlIGRpcmVjdCBzdWJzdHJpbmcgcmVtb3ZhbCBhcHByb2FjaCB3b24ndCB3b3JrIDovXHJcbiAgICBsZXQgcGFyZW50U2VnbWVudHMgPSBwYXJlbnRQYXRobmFtZUJhc2UucmVwbGFjZSgvXlxcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcclxuICAgIGxldCBzZWdtZW50cyA9IHBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCBcIlwiKS5zcGxpdChcIi9cIik7XHJcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IFwiL1wiICsgc2VnbWVudHMuc2xpY2UocGFyZW50U2VnbWVudHMubGVuZ3RoKS5qb2luKFwiL1wiKTtcclxuICB9XHJcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHtcclxuICAgIHBhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZVxyXG4gIH0pO1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCwgXCJObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcXFwiXCIgKyBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2ggKyBcIlxcXCIgXCIpIDogdm9pZCAwO1xyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcobWF0Y2hlcyA9PSBudWxsIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLkNvbXBvbmVudCAhPT0gdW5kZWZpbmVkIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5sYXp5ICE9PSB1bmRlZmluZWQsIFwiTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIiArIFwiZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50IG9yIENvbXBvbmVudC4gVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBcIiArIFwibnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcXFwiZW1wdHlcXFwiIHBhZ2UuXCIpIDogdm9pZCAwO1xyXG4gIH1cclxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyAmJiBtYXRjaGVzLm1hcChtYXRjaCA9PiBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xyXG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXHJcbiAgICBwYXRobmFtZTogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsXHJcbiAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xyXG4gICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lXSksXHJcbiAgICBwYXRobmFtZUJhc2U6IG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgPyBwYXJlbnRQYXRobmFtZUJhc2UgOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSxcclxuICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXHJcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZV0pXHJcbiAgfSkpLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSk7XHJcblxyXG4gIC8vIFdoZW4gYSB1c2VyIHBhc3NlcyBpbiBhIGBsb2NhdGlvbkFyZ2AsIHRoZSBhc3NvY2lhdGVkIHJvdXRlcyBuZWVkIHRvXHJcbiAgLy8gYmUgd3JhcHBlZCBpbiBhIG5ldyBgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyYCBpbiBvcmRlciBmb3IgYHVzZUxvY2F0aW9uYFxyXG4gIC8vIHRvIHVzZSB0aGUgc2NvcGVkIGxvY2F0aW9uIGluc3RlYWQgb2YgdGhlIGdsb2JhbCBsb2NhdGlvbi5cclxuICBpZiAobG9jYXRpb25BcmcgJiYgcmVuZGVyZWRNYXRjaGVzKSB7XHJcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XHJcbiAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgbG9jYXRpb246IF9leHRlbmRzKHtcclxuICAgICAgICAgIHBhdGhuYW1lOiBcIi9cIixcclxuICAgICAgICAgIHNlYXJjaDogXCJcIixcclxuICAgICAgICAgIGhhc2g6IFwiXCIsXHJcbiAgICAgICAgICBzdGF0ZTogbnVsbCxcclxuICAgICAgICAgIGtleTogXCJkZWZhdWx0XCJcclxuICAgICAgICB9LCBsb2NhdGlvbiksXHJcbiAgICAgICAgbmF2aWdhdGlvblR5cGU6IEFjdGlvbi5Qb3BcclxuICAgICAgfVxyXG4gICAgfSwgcmVuZGVyZWRNYXRjaGVzKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcztcclxufVxyXG5mdW5jdGlvbiBEZWZhdWx0RXJyb3JDb21wb25lbnQoKSB7XHJcbiAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xyXG4gIGxldCBtZXNzYWdlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gZXJyb3Iuc3RhdHVzICsgXCIgXCIgKyBlcnJvci5zdGF0dXNUZXh0IDogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XHJcbiAgbGV0IHN0YWNrID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcclxuICBsZXQgbGlnaHRncmV5ID0gXCJyZ2JhKDIwMCwyMDAsMjAwLCAwLjUpXCI7XHJcbiAgbGV0IHByZVN0eWxlcyA9IHtcclxuICAgIHBhZGRpbmc6IFwiMC41cmVtXCIsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleVxyXG4gIH07XHJcbiAgbGV0IGNvZGVTdHlsZXMgPSB7XHJcbiAgICBwYWRkaW5nOiBcIjJweCA0cHhcIixcclxuICAgIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5XHJcbiAgfTtcclxuICBsZXQgZGV2SW5mbyA9IG51bGw7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsZWQgYnkgUmVhY3QgUm91dGVyIGRlZmF1bHQgRXJyb3JCb3VuZGFyeTpcIiwgZXJyb3IpO1xyXG4gICAgZGV2SW5mbyA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJcXHVEODNEXFx1RENCRiBIZXkgZGV2ZWxvcGVyIFxcdUQ4M0RcXHVEQzRCXCIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMgYnkgcHJvdmlkaW5nIHlvdXIgb3duIFwiLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge1xyXG4gICAgICBzdHlsZTogY29kZVN0eWxlc1xyXG4gICAgfSwgXCJFcnJvckJvdW5kYXJ5XCIpLCBcIiBvclwiLCBcIiBcIiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtcclxuICAgICAgc3R5bGU6IGNvZGVTdHlsZXNcclxuICAgIH0sIFwiZXJyb3JFbGVtZW50XCIpLCBcIiBwcm9wIG9uIHlvdXIgcm91dGUuXCIpKTtcclxuICB9XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImgyXCIsIG51bGwsIFwiVW5leHBlY3RlZCBBcHBsaWNhdGlvbiBFcnJvciFcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDNcIiwge1xyXG4gICAgc3R5bGU6IHtcclxuICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXHJcbiAgICB9XHJcbiAgfSwgbWVzc2FnZSksIHN0YWNrID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xyXG4gICAgc3R5bGU6IHByZVN0eWxlc1xyXG4gIH0sIHN0YWNrKSA6IG51bGwsIGRldkluZm8pO1xyXG59XHJcbmNvbnN0IGRlZmF1bHRFcnJvckVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0RXJyb3JDb21wb25lbnQsIG51bGwpO1xyXG5jbGFzcyBSZW5kZXJFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxyXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbixcclxuICAgICAgZXJyb3I6IHByb3BzLmVycm9yXHJcbiAgICB9O1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlcnJvcjogZXJyb3JcclxuICAgIH07XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XHJcbiAgICAvLyBXaGVuIHdlIGdldCBpbnRvIGFuIGVycm9yIHN0YXRlLCB0aGUgdXNlciB3aWxsIGxpa2VseSBjbGljayBcImJhY2tcIiB0byB0aGVcclxuICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcclxuICAgIC8vIGFwcGxpY2F0aW9uLCB0aGF0IHdpbGwgaGF2ZSBubyBlZmZlY3QtLXRoZSBlcnJvciBwYWdlIGNvbnRpbnVlcyB0byBkaXNwbGF5LlxyXG4gICAgLy8gVGhpcyBnaXZlcyB1cyBhIG1lY2hhbmlzbSB0byByZWNvdmVyIGZyb20gdGhlIGVycm9yIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXHJcbiAgICAvL1xyXG4gICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcclxuICAgIC8vIHNvIHRoYXQgd2hlbiB3ZSBhcmUgaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGdldHMgcmVzZXQgd2hlbiBhIG5ldyBsb2NhdGlvblxyXG4gICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxyXG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb24gIT09IFwiaWRsZVwiICYmIHByb3BzLnJldmFsaWRhdGlvbiA9PT0gXCJpZGxlXCIpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBlcnJvcjogcHJvcHMuZXJyb3IsXHJcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxyXG4gICAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgd2UncmUgbm90IGNoYW5naW5nIGxvY2F0aW9ucywgcHJlc2VydmUgdGhlIGxvY2F0aW9uIGJ1dCBzdGlsbCBzdXJmYWNlXHJcbiAgICAvLyBhbnkgbmV3IGVycm9ycyB0aGF0IG1heSBjb21lIHRocm91Z2guIFdlIHJldGFpbiB0aGUgZXhpc3RpbmcgZXJyb3IsIHdlIGRvXHJcbiAgICAvLyB0aGlzIGJlY2F1c2UgdGhlIGVycm9yIHByb3ZpZGVkIGZyb20gdGhlIGFwcCBzdGF0ZSBtYXkgYmUgY2xlYXJlZCB3aXRob3V0XHJcbiAgICAvLyB0aGUgbG9jYXRpb24gY2hhbmdpbmcuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgIT09IHVuZGVmaW5lZCA/IHByb3BzLmVycm9yIDogc3RhdGUuZXJyb3IsXHJcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcclxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uXHJcbiAgICB9O1xyXG4gIH1cclxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiUmVhY3QgUm91dGVyIGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIiwgZXJyb3IsIGVycm9ySW5mbyk7XHJcbiAgfVxyXG4gIHJlbmRlcigpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yICE9PSB1bmRlZmluZWQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcclxuICAgICAgdmFsdWU6IHRoaXMucHJvcHMucm91dGVDb250ZXh0XHJcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUVycm9yQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5lcnJvcixcclxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY29tcG9uZW50XHJcbiAgICB9KSkgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKF9yZWYpIHtcclxuICBsZXQge1xyXG4gICAgcm91dGVDb250ZXh0LFxyXG4gICAgbWF0Y2gsXHJcbiAgICBjaGlsZHJlblxyXG4gIH0gPSBfcmVmO1xyXG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xyXG5cclxuICAvLyBUcmFjayBob3cgZGVlcCB3ZSBnb3QgaW4gb3VyIHJlbmRlciBwYXNzIHRvIGVtdWxhdGUgU1NSIGNvbXBvbmVudERpZENhdGNoXHJcbiAgLy8gaW4gYSBEYXRhU3RhdGljUm91dGVyXHJcbiAgaWYgKGRhdGFSb3V0ZXJDb250ZXh0ICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpYyAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNDb250ZXh0ICYmIChtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgbWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSkpIHtcclxuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcclxuICB9XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgdmFsdWU6IHJvdXRlQ29udGV4dFxyXG4gIH0sIGNoaWxkcmVuKTtcclxufVxyXG5mdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSkge1xyXG4gIHZhciBfZGF0YVJvdXRlclN0YXRlO1xyXG4gIGlmIChwYXJlbnRNYXRjaGVzID09PSB2b2lkIDApIHtcclxuICAgIHBhcmVudE1hdGNoZXMgPSBbXTtcclxuICB9XHJcbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICBkYXRhUm91dGVyU3RhdGUgPSBudWxsO1xyXG4gIH1cclxuICBpZiAoZnV0dXJlID09PSB2b2lkIDApIHtcclxuICAgIGZ1dHVyZSA9IG51bGw7XHJcbiAgfVxyXG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcclxuICAgIHZhciBfZnV0dXJlO1xyXG4gICAgaWYgKCFkYXRhUm91dGVyU3RhdGUpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlLmVycm9ycykge1xyXG4gICAgICAvLyBEb24ndCBiYWlsIGlmIHdlIGhhdmUgZGF0YSByb3V0ZXIgZXJyb3JzIHNvIHdlIGNhbiByZW5kZXIgdGhlbSBpbiB0aGVcclxuICAgICAgLy8gYm91bmRhcnkuICBVc2UgdGhlIHByZS1tYXRjaGVkIChvciBzaGltbWVkKSBtYXRjaGVzXHJcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcztcclxuICAgIH0gZWxzZSBpZiAoKF9mdXR1cmUgPSBmdXR1cmUpICE9IG51bGwgJiYgX2Z1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uICYmIHBhcmVudE1hdGNoZXMubGVuZ3RoID09PSAwICYmICFkYXRhUm91dGVyU3RhdGUuaW5pdGlhbGl6ZWQgJiYgZGF0YVJvdXRlclN0YXRlLm1hdGNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAvLyBEb24ndCBiYWlsIGlmIHdlJ3JlIGluaXRpYWxpemluZyB3aXRoIHBhcnRpYWwgaHlkcmF0aW9uIGFuZCB3ZSBoYXZlXHJcbiAgICAgIC8vIHJvdXRlciBtYXRjaGVzLiAgVGhhdCBtZWFucyB3ZSdyZSBhY3RpdmVseSBydW5uaW5nIGBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbmBcclxuICAgICAgLy8gc28gd2Ugc2hvdWxkIHJlbmRlciBkb3duIHRoZSBwYXJ0aWFsIG1hdGNoZXMgdG8gdGhlIGFwcHJvcHJpYXRlXHJcbiAgICAgIC8vIGBIeWRyYXRlRmFsbGJhY2tgLiAgV2Ugb25seSBkbyB0aGlzIGlmIGBwYXJlbnRNYXRjaGVzYCBpcyBlbXB0eSBzbyBpdFxyXG4gICAgICAvLyBvbmx5IGltcGFjdHMgdGhlIHJvb3QgbWF0Y2hlcyBmb3IgYFJvdXRlclByb3ZpZGVyYCBhbmQgbm8gZGVzY2VuZGFudFxyXG4gICAgICAvLyBgPFJvdXRlcz5gXHJcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlcztcclxuXHJcbiAgLy8gSWYgd2UgaGF2ZSBkYXRhIGVycm9ycywgdHJpbSBtYXRjaGVzIHRvIHRoZSBoaWdoZXN0IGVycm9yIGJvdW5kYXJ5XHJcbiAgbGV0IGVycm9ycyA9IChfZGF0YVJvdXRlclN0YXRlID0gZGF0YVJvdXRlclN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSb3V0ZXJTdGF0ZS5lcnJvcnM7XHJcbiAgaWYgKGVycm9ycyAhPSBudWxsKSB7XHJcbiAgICBsZXQgZXJyb3JJbmRleCA9IHJlbmRlcmVkTWF0Y2hlcy5maW5kSW5kZXgobSA9PiBtLnJvdXRlLmlkICYmIChlcnJvcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yc1ttLnJvdXRlLmlkXSkgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAhKGVycm9ySW5kZXggPj0gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkNvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgcm91dGUgZm9yIGVycm9ycyBvbiByb3V0ZSBJRHM6IFwiICsgT2JqZWN0LmtleXMoZXJyb3JzKS5qb2luKFwiLFwiKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgd2UncmUgaW4gYSBwYXJ0aWFsIGh5ZHJhdGlvbiBtb2RlLCBkZXRlY3QgaWYgd2UgbmVlZCB0byByZW5kZXIgZG93biB0b1xyXG4gIC8vIGEgZ2l2ZW4gSHlkcmF0ZUZhbGxiYWNrIHdoaWxlIHdlIGxvYWQgdGhlIHJlc3Qgb2YgdGhlIGh5ZHJhdGlvbiBkYXRhXHJcbiAgbGV0IHJlbmRlckZhbGxiYWNrID0gZmFsc2U7XHJcbiAgbGV0IGZhbGxiYWNrSW5kZXggPSAtMTtcclxuICBpZiAoZGF0YVJvdXRlclN0YXRlICYmIGZ1dHVyZSAmJiBmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IG1hdGNoID0gcmVuZGVyZWRNYXRjaGVzW2ldO1xyXG4gICAgICAvLyBUcmFjayB0aGUgZGVlcGVzdCBmYWxsYmFjayB1cCB1bnRpbCB0aGUgZmlyc3Qgcm91dGUgd2l0aG91dCBkYXRhXHJcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xyXG4gICAgICAgIGZhbGxiYWNrSW5kZXggPSBpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCkge1xyXG4gICAgICAgIGxldCB7XHJcbiAgICAgICAgICBsb2FkZXJEYXRhLFxyXG4gICAgICAgICAgZXJyb3JzXHJcbiAgICAgICAgfSA9IGRhdGFSb3V0ZXJTdGF0ZTtcclxuICAgICAgICBsZXQgbmVlZHNUb1J1bkxvYWRlciA9IG1hdGNoLnJvdXRlLmxvYWRlciAmJiBsb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkICYmICghZXJyb3JzIHx8IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbmVlZHNUb1J1bkxvYWRlcikge1xyXG4gICAgICAgICAgLy8gV2UgZm91bmQgdGhlIGZpcnN0IHJvdXRlIHRoYXQncyBub3QgcmVhZHkgdG8gcmVuZGVyICh3YWl0aW5nIG9uXHJcbiAgICAgICAgICAvLyBsYXp5LCBvciBoYXMgYSBsb2FkZXIgdGhhdCBoYXNuJ3QgcnVuIHlldCkuICBGbGFnIHRoYXQgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgLy8gcmVuZGVyIGEgZmFsbGJhY2sgYW5kIHJlbmRlciB1cCB1bnRpbCB0aGUgYXBwcm9wcmlhdGUgZmFsbGJhY2tcclxuICAgICAgICAgIHJlbmRlckZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgIGlmIChmYWxsYmFja0luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIGZhbGxiYWNrSW5kZXggKyAxKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVkTWF0Y2hlcyA9IFtyZW5kZXJlZE1hdGNoZXNbMF1dO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XHJcbiAgICAvLyBPbmx5IGRhdGEgcm91dGVycyBoYW5kbGUgZXJyb3JzL2ZhbGxiYWNrc1xyXG4gICAgbGV0IGVycm9yO1xyXG4gICAgbGV0IHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgbGV0IGVycm9yRWxlbWVudCA9IG51bGw7XHJcbiAgICBsZXQgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XHJcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XHJcbiAgICAgIGVycm9yID0gZXJyb3JzICYmIG1hdGNoLnJvdXRlLmlkID8gZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA6IHVuZGVmaW5lZDtcclxuICAgICAgZXJyb3JFbGVtZW50ID0gbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGRlZmF1bHRFcnJvckVsZW1lbnQ7XHJcbiAgICAgIGlmIChyZW5kZXJGYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChmYWxsYmFja0luZGV4IDwgMCAmJiBpbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgd2FybmluZ09uY2UoXCJyb3V0ZS1mYWxsYmFja1wiLCBmYWxzZSwgXCJObyBgSHlkcmF0ZUZhbGxiYWNrYCBlbGVtZW50IHByb3ZpZGVkIHRvIHJlbmRlciBkdXJpbmcgaW5pdGlhbCBoeWRyYXRpb25cIik7XHJcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmYWxsYmFja0luZGV4ID09PSBpbmRleCkge1xyXG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50IHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgbWF0Y2hlcyA9IHBhcmVudE1hdGNoZXMuY29uY2F0KHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKTtcclxuICAgIGxldCBnZXRDaGlsZHJlbiA9ICgpID0+IHtcclxuICAgICAgbGV0IGNoaWxkcmVuO1xyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IGVycm9yRWxlbWVudDtcclxuICAgICAgfSBlbHNlIGlmIChzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2spIHtcclxuICAgICAgICBjaGlsZHJlbiA9IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ7XHJcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuQ29tcG9uZW50KSB7XHJcbiAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBhIGRlLW9wdGltaXplZCBwYXRoIHNpbmNlIFJlYWN0IHdvbid0IHJlLXVzZSB0aGVcclxuICAgICAgICAvLyBSZWFjdEVsZW1lbnQgc2luY2UgaXQncyBpZGVudGl0eSBjaGFuZ2VzIHdpdGggZWFjaCBuZXdcclxuICAgICAgICAvLyBSZWFjdC5jcmVhdGVFbGVtZW50IGNhbGwuICBXZSBrZWVwIHRoaXMgc28gZm9sa3MgY2FuIHVzZVxyXG4gICAgICAgIC8vIGA8Um91dGUgQ29tcG9uZW50PXsuLi59PmAgaW4gYDxSb3V0ZXM+YCBidXQgZ2VuZXJhbGx5IGBDb21wb25lbnRgXHJcbiAgICAgICAgLy8gdXNhZ2UgaXMgb25seSBhZHZpc2VkIGluIGBSb3V0ZXJQcm92aWRlcmAgd2hlbiB3ZSBjYW4gY29udmVydCBpdCB0b1xyXG4gICAgICAgIC8vIGBlbGVtZW50YCBhaGVhZCBvZiB0aW1lLlxyXG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQobWF0Y2gucm91dGUuQ29tcG9uZW50LCBudWxsKTtcclxuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5lbGVtZW50KSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBtYXRjaC5yb3V0ZS5lbGVtZW50O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoaWxkcmVuID0gb3V0bGV0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW5kZXJlZFJvdXRlLCB7XHJcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxyXG4gICAgICAgIHJvdXRlQ29udGV4dDoge1xyXG4gICAgICAgICAgb3V0bGV0LFxyXG4gICAgICAgICAgbWF0Y2hlcyxcclxuICAgICAgICAgIGlzRGF0YVJvdXRlOiBkYXRhUm91dGVyU3RhdGUgIT0gbnVsbFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIE9ubHkgd3JhcCBpbiBhbiBlcnJvciBib3VuZGFyeSB3aXRoaW4gZGF0YSByb3V0ZXIgdXNhZ2VzIHdoZW4gd2UgaGF2ZSBhblxyXG4gICAgLy8gRXJyb3JCb3VuZGFyeS9lcnJvckVsZW1lbnQgb24gdGhpcyByb3V0ZS4gIE90aGVyd2lzZSBsZXQgaXQgYnViYmxlIHVwIHRvXHJcbiAgICAvLyBhbiBhbmNlc3RvciBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudFxyXG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJiAobWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSB8fCBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgaW5kZXggPT09IDApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyRXJyb3JCb3VuZGFyeSwge1xyXG4gICAgICBsb2NhdGlvbjogZGF0YVJvdXRlclN0YXRlLmxvY2F0aW9uLFxyXG4gICAgICByZXZhbGlkYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5yZXZhbGlkYXRpb24sXHJcbiAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxyXG4gICAgICBlcnJvcjogZXJyb3IsXHJcbiAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbigpLFxyXG4gICAgICByb3V0ZUNvbnRleHQ6IHtcclxuICAgICAgICBvdXRsZXQ6IG51bGwsXHJcbiAgICAgICAgbWF0Y2hlcyxcclxuICAgICAgICBpc0RhdGFSb3V0ZTogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9KSA6IGdldENoaWxkcmVuKCk7XHJcbiAgfSwgbnVsbCk7XHJcbn1cclxudmFyIERhdGFSb3V0ZXJIb29rID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChEYXRhUm91dGVySG9vaykge1xyXG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlQmxvY2tlclwiXSA9IFwidXNlQmxvY2tlclwiO1xyXG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XHJcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VOYXZpZ2F0ZVN0YWJsZVwiXSA9IFwidXNlTmF2aWdhdGVcIjtcclxuICByZXR1cm4gRGF0YVJvdXRlckhvb2s7XHJcbn0oRGF0YVJvdXRlckhvb2sgfHwge30pO1xyXG52YXIgRGF0YVJvdXRlclN0YXRlSG9vayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRGF0YVJvdXRlclN0YXRlSG9vaykge1xyXG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XHJcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZUxvYWRlckRhdGFcIl0gPSBcInVzZUxvYWRlckRhdGFcIjtcclxuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlQWN0aW9uRGF0YVwiXSA9IFwidXNlQWN0aW9uRGF0YVwiO1xyXG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUVycm9yXCJdID0gXCJ1c2VSb3V0ZUVycm9yXCI7XHJcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU5hdmlnYXRpb25cIl0gPSBcInVzZU5hdmlnYXRpb25cIjtcclxuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVMb2FkZXJEYXRhXCJdID0gXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIjtcclxuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTWF0Y2hlc1wiXSA9IFwidXNlTWF0Y2hlc1wiO1xyXG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSZXZhbGlkYXRvclwiXSA9IFwidXNlUmV2YWxpZGF0b3JcIjtcclxuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTmF2aWdhdGVTdGFibGVcIl0gPSBcInVzZU5hdmlnYXRlXCI7XHJcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlSWRcIl0gPSBcInVzZVJvdXRlSWRcIjtcclxuICByZXR1cm4gRGF0YVJvdXRlclN0YXRlSG9vaztcclxufShEYXRhUm91dGVyU3RhdGVIb29rIHx8IHt9KTtcclxuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xyXG4gIHJldHVybiBob29rTmFtZSArIFwiIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBkYXRhIHJvdXRlci4gIFNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuXCI7XHJcbn1cclxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcclxuICBsZXQgY3R4ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XHJcbiAgIWN0eCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHJldHVybiBjdHg7XHJcbn1cclxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lKSB7XHJcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcclxuICAhc3RhdGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuZnVuY3Rpb24gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKSB7XHJcbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xyXG4gICFyb3V0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHJldHVybiByb3V0ZTtcclxufVxyXG5cclxuLy8gSW50ZXJuYWwgdmVyc2lvbiB3aXRoIGhvb2tOYW1lLWF3YXJlIGRlYnVnZ2luZ1xyXG5mdW5jdGlvbiB1c2VDdXJyZW50Um91dGVJZChob29rTmFtZSkge1xyXG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XHJcbiAgbGV0IHRoaXNSb3V0ZSA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXTtcclxuICAhdGhpc1JvdXRlLnJvdXRlLmlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgaG9va05hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXFxcImlkXFxcIlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBJRCBmb3IgdGhlIG5lYXJlc3QgY29udGV4dHVhbCByb3V0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdXNlUm91dGVJZCgpIHtcclxuICByZXR1cm4gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUlkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiwgZGVmYXVsdGluZyB0byBhbiBcImlkbGVcIiBuYXZpZ2F0aW9uIHdoZW5cclxuICogbm8gbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzc1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcclxuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0aW9uKTtcclxuICByZXR1cm4gc3RhdGUubmF2aWdhdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZXZhbGlkYXRlIGZ1bmN0aW9uIGZvciBtYW51YWxseSB0cmlnZ2VyaW5nIHJldmFsaWRhdGlvbiwgYXMgd2VsbFxyXG4gKiBhcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhbnkgbWFudWFsIHJldmFsaWRhdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIHVzZVJldmFsaWRhdG9yKCkge1xyXG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVJldmFsaWRhdG9yKTtcclxuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSZXZhbGlkYXRvcik7XHJcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcclxuICAgIHJldmFsaWRhdGU6IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLFxyXG4gICAgc3RhdGU6IHN0YXRlLnJldmFsaWRhdGlvblxyXG4gIH0pLCBbZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsIHN0YXRlLnJldmFsaWRhdGlvbl0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYWN0aXZlIHJvdXRlIG1hdGNoZXMsIHVzZWZ1bCBmb3IgYWNjZXNzaW5nIGxvYWRlckRhdGEgZm9yXHJcbiAqIHBhcmVudC9jaGlsZCByb3V0ZXMgb3IgdGhlIHJvdXRlIFwiaGFuZGxlXCIgcHJvcGVydHlcclxuICovXHJcbmZ1bmN0aW9uIHVzZU1hdGNoZXMoKSB7XHJcbiAgbGV0IHtcclxuICAgIG1hdGNoZXMsXHJcbiAgICBsb2FkZXJEYXRhXHJcbiAgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZU1hdGNoZXMpO1xyXG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoZXMubWFwKG0gPT4gVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIGxvYWRlckRhdGEpKSwgW21hdGNoZXMsIGxvYWRlckRhdGFdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxvYWRlciBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBsb2FkZXJcclxuICovXHJcbmZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKSB7XHJcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XHJcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xyXG4gIGlmIChzdGF0ZS5lcnJvcnMgJiYgc3RhdGUuZXJyb3JzW3JvdXRlSWRdICE9IG51bGwpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhbiBlcnJvckVsZW1lbnQgKHJvdXRlSWQ6IFwiICsgcm91dGVJZCArIFwiKVwiKTtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbG9hZGVyRGF0YSBmb3IgdGhlIGdpdmVuIHJvdXRlSWRcclxuICovXHJcbmZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkKSB7XHJcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVMb2FkZXJEYXRhKTtcclxuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGFjdGlvbiBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBhY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKSB7XHJcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQWN0aW9uRGF0YSk7XHJcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xyXG4gIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhID8gc3RhdGUuYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgZXJyb3IsIHdoaWNoIGNvdWxkIGJlIGEgbG9hZGVyL2FjdGlvblxyXG4gKiBlcnJvciBvciBhIHJlbmRlciBlcnJvci4gIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIGZyb20geW91clxyXG4gKiBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudCB0byBkaXNwbGF5IGEgcHJvcGVyIGVycm9yIG1lc3NhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VSb3V0ZUVycm9yKCkge1xyXG4gIHZhciBfc3RhdGUkZXJyb3JzO1xyXG4gIGxldCBlcnJvciA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVFcnJvckNvbnRleHQpO1xyXG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlRXJyb3IpO1xyXG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcclxuXHJcbiAgLy8gSWYgdGhpcyB3YXMgYSByZW5kZXIgZXJyb3IsIHdlIHB1dCBpdCBpbiBhIFJvdXRlRXJyb3IgY29udGV4dCBpbnNpZGVcclxuICAvLyBvZiBSZW5kZXJFcnJvckJvdW5kYXJ5XHJcbiAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBlcnJvcjtcclxuICB9XHJcblxyXG4gIC8vIE90aGVyd2lzZSBsb29rIGZvciBlcnJvcnMgZnJvbSBvdXIgZGF0YSByb3V0ZXIgc3RhdGVcclxuICByZXR1cm4gKF9zdGF0ZSRlcnJvcnMgPSBzdGF0ZS5lcnJvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZXJyb3JzW3JvdXRlSWRdO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgaGFwcHktcGF0aCBkYXRhIGZyb20gdGhlIG5lYXJlc3QgYW5jZXN0b3IgYDxBd2FpdCAvPmAgdmFsdWVcclxuICovXHJcbmZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKSB7XHJcbiAgbGV0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xyXG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX2RhdGE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBlcnJvciBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VBc3luY0Vycm9yKCkge1xyXG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcclxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9lcnJvcjtcclxufVxyXG5sZXQgYmxvY2tlcklkID0gMDtcclxuXHJcbi8qKlxyXG4gKiBBbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gYmxvY2sgbmF2aWdhdGlvbnMgd2l0aGluIHRoZSBTUEEgYW5kIHByZXNlbnQgdGhlXHJcbiAqIHVzZXIgYSBjb25maXJtYXRpb24gZGlhbG9nIHRvIGNvbmZpcm0gdGhlIG5hdmlnYXRpb24uICBNb3N0bHkgdXNlZCB0byBhdm9pZFxyXG4gKiB1c2luZyBoYWxmLWZpbGxlZCBmb3JtIGRhdGEuICBUaGlzIGRvZXMgbm90IGhhbmRsZSBoYXJkLXJlbG9hZHMgb3JcclxuICogY3Jvc3Mtb3JpZ2luIG5hdmlnYXRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gdXNlQmxvY2tlcihzaG91bGRCbG9jaykge1xyXG4gIGxldCB7XHJcbiAgICByb3V0ZXIsXHJcbiAgICBiYXNlbmFtZVxyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VCbG9ja2VyKTtcclxuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VCbG9ja2VyKTtcclxuICBsZXQgW2Jsb2NrZXJLZXksIHNldEJsb2NrZXJLZXldID0gUmVhY3QudXNlU3RhdGUoXCJcIik7XHJcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGFyZyA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHNob3VsZEJsb2NrICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgcmV0dXJuICEhc2hvdWxkQmxvY2s7XHJcbiAgICB9XHJcbiAgICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSB7XHJcbiAgICAgIHJldHVybiBzaG91bGRCbG9jayhhcmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZXkgcHJvdmlkZWQgdXMgYSBmdW5jdGlvbiBhbmQgd2UndmUgZ290IGFuIGFjdGl2ZSBiYXNlbmFtZSwgc3RyaXBcclxuICAgIC8vIGl0IGZyb20gdGhlIGxvY2F0aW9ucyB3ZSBleHBvc2UgdG8gdGhlIHVzZXIgdG8gbWF0Y2ggdGhlIGJlaGF2aW9yIG9mXHJcbiAgICAvLyB1c2VMb2NhdGlvblxyXG4gICAgbGV0IHtcclxuICAgICAgY3VycmVudExvY2F0aW9uLFxyXG4gICAgICBuZXh0TG9jYXRpb24sXHJcbiAgICAgIGhpc3RvcnlBY3Rpb25cclxuICAgIH0gPSBhcmc7XHJcbiAgICByZXR1cm4gc2hvdWxkQmxvY2soe1xyXG4gICAgICBjdXJyZW50TG9jYXRpb246IF9leHRlbmRzKHt9LCBjdXJyZW50TG9jYXRpb24sIHtcclxuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWVcclxuICAgICAgfSksXHJcbiAgICAgIG5leHRMb2NhdGlvbjogX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwge1xyXG4gICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxyXG4gICAgICB9KSxcclxuICAgICAgaGlzdG9yeUFjdGlvblxyXG4gICAgfSk7XHJcbiAgfSwgW2Jhc2VuYW1lLCBzaG91bGRCbG9ja10pO1xyXG5cclxuICAvLyBUaGlzIGVmZmVjdCBpcyBpbiBjaGFyZ2Ugb2YgYmxvY2tlciBrZXkgYXNzaWdubWVudCBhbmQgZGVsZXRpb24gKHdoaWNoIGlzXHJcbiAgLy8gdGlnaHRseSBjb3VwbGVkIHRvIHRoZSBrZXkpXHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xyXG4gICAgc2V0QmxvY2tlcktleShrZXkpO1xyXG4gICAgcmV0dXJuICgpID0+IHJvdXRlci5kZWxldGVCbG9ja2VyKGtleSk7XHJcbiAgfSwgW3JvdXRlcl0pO1xyXG5cclxuICAvLyBUaGlzIGVmZmVjdCBoYW5kbGVzIGFzc2lnbmluZyB0aGUgYmxvY2tlckZ1bmN0aW9uLiAgVGhpcyBpcyB0byBoYW5kbGVcclxuICAvLyB1bnN0YWJsZSBibG9ja2VyIGZ1bmN0aW9uIGlkZW50aXRpZXMsIGFuZCBoYXBwZW5zIG9ubHkgYWZ0ZXIgdGhlIHByaW9yXHJcbiAgLy8gZWZmZWN0IHNvIHdlIGRvbid0IGdldCBhbiBvcnBoYW5lZCBibG9ja2VyRnVuY3Rpb24gaW4gdGhlIHJvdXRlciB3aXRoIGFcclxuICAvLyBrZXkgb2YgXCJcIi4gIFVudGlsIHRoZW4gd2UganVzdCBoYXZlIHRoZSBJRExFX0JMT0NLRVIuXHJcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChibG9ja2VyS2V5ICE9PSBcIlwiKSB7XHJcbiAgICAgIHJvdXRlci5nZXRCbG9ja2VyKGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbik7XHJcbiAgICB9XHJcbiAgfSwgW3JvdXRlciwgYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSk7XHJcblxyXG4gIC8vIFByZWZlciB0aGUgYmxvY2tlciBmcm9tIGBzdGF0ZWAgbm90IGByb3V0ZXIuc3RhdGVgIHNpbmNlIERhdGFSb3V0ZXJDb250ZXh0XHJcbiAgLy8gaXMgbWVtb2l6ZWQgc28gdGhpcyBlbnN1cmVzIHdlIHVwZGF0ZSBvbiBibG9ja2VyIHN0YXRlIHVwZGF0ZXNcclxuICByZXR1cm4gYmxvY2tlcktleSAmJiBzdGF0ZS5ibG9ja2Vycy5oYXMoYmxvY2tlcktleSkgPyBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSkgOiBJRExFX0JMT0NLRVI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdGFibGUgdmVyc2lvbiBvZiB1c2VOYXZpZ2F0ZSB0aGF0IGlzIHVzZWQgd2hlbiB3ZSBhcmUgaW4gdGhlIGNvbnRleHQgb2ZcclxuICogYSBSb3V0ZXJQcm92aWRlci5cclxuICovXHJcbmZ1bmN0aW9uIHVzZU5hdmlnYXRlU3RhYmxlKCkge1xyXG4gIGxldCB7XHJcbiAgICByb3V0ZXJcclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xyXG4gIGxldCBpZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xyXG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xyXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gIH0pO1xyXG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKSA6IHZvaWQgMDtcclxuXHJcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGhlcmUgc2luY2UgaWYgdGhpcyBoYXBwZW5zIG9uIGZpcnN0IHJlbmRlciB0aGUgbmF2aWdhdGVcclxuICAgIC8vIGlzIHVzZWxlc3MgYmVjYXVzZSB3ZSBoYXZlbid0IHdpcmVkIHVwIG91ciByb3V0ZXIgc3Vic2NyaWJlciB5ZXRcclxuICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgcm91dGVyLm5hdmlnYXRlKHRvKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0bywgX2V4dGVuZHMoe1xyXG4gICAgICAgIGZyb21Sb3V0ZUlkOiBpZFxyXG4gICAgICB9LCBvcHRpb25zKSk7XHJcbiAgICB9XHJcbiAgfSwgW3JvdXRlciwgaWRdKTtcclxuICByZXR1cm4gbmF2aWdhdGU7XHJcbn1cclxuY29uc3QgYWxyZWFkeVdhcm5lZCA9IHt9O1xyXG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXksIGNvbmQsIG1lc3NhZ2UpIHtcclxuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xyXG4gICAgYWxyZWFkeVdhcm5lZFtrZXldID0gdHJ1ZTtcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gIFdlYnBhY2sgKyBSZWFjdCAxNyBmYWlscyB0byBjb21waWxlIG9uIGFueSBvZiB0aGUgZm9sbG93aW5nIGJlY2F1c2Ugd2VicGFja1xyXG4gIGNvbXBsYWlucyB0aGF0IGBzdGFydFRyYW5zaXRpb25gIGRvZXNuJ3QgZXhpc3QgaW4gYFJlYWN0YDpcclxuICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXHJcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xyXG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcclxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XHJcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3RbXCJzdGFydFRyYW5zaXRpb25cIl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXHJcblxyXG4gIE1vdmluZyBpdCB0byBhIGNvbnN0YW50IHN1Y2ggYXMgdGhlIGZvbGxvd2luZyBzb2x2ZXMgdGhlIFdlYnBhY2svUmVhY3QgMTcgaXNzdWU6XHJcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xyXG4gICAgY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XHJcbiAgICBTVEFSVF9UUkFOU0lUSU9OIGluIFJlYWN0ID8gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXHJcblxyXG4gIEhvd2V2ZXIsIHRoYXQgaW50cm9kdWNlcyB3ZWJwYWNrL3RlcnNlciBtaW5pZmljYXRpb24gaXNzdWVzIGluIHByb2R1Y3Rpb24gYnVpbGRzXHJcbiAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcclxuICBSZWFjdC5zdGFydFRyYW5zaXRpb24gZW50aXJlbHkgZnJvbSB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgdGVybmFyeS4gIEdyYWJiaW5nXHJcbiAgdGhpcyBleHBvcnRlZCByZWZlcmVuY2Ugb25jZSB1cCBmcm9udCByZXNvbHZlcyB0aGF0IGlzc3VlLlxyXG5cclxuICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzEwNTc5XHJcbiovXHJcbmNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xyXG5jb25zdCBzdGFydFRyYW5zaXRpb25JbXBsID0gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl07XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBSZW1peCBSb3V0ZXIgaW5zdGFuY2UsIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgVUlcclxuICovXHJcbmZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKF9yZWYpIHtcclxuICBsZXQge1xyXG4gICAgZmFsbGJhY2tFbGVtZW50LFxyXG4gICAgcm91dGVyLFxyXG4gICAgZnV0dXJlXHJcbiAgfSA9IF9yZWY7XHJcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XHJcbiAgbGV0IHtcclxuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxyXG4gIH0gPSBmdXR1cmUgfHwge307XHJcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2sobmV3U3RhdGUgPT4ge1xyXG4gICAgaWYgKHY3X3N0YXJ0VHJhbnNpdGlvbiAmJiBzdGFydFRyYW5zaXRpb25JbXBsKSB7XHJcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xyXG4gICAgfVxyXG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xyXG5cclxuICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cclxuICAvLyBwaWNrIHVwIG9uIGFueSByZW5kZXItZHJpdmVuIHJlZGlyZWN0cy9uYXZpZ2F0aW9ucyAodXNlRWZmZWN0LzxOYXZpZ2F0ZT4pXHJcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHJvdXRlci5zdWJzY3JpYmUoc2V0U3RhdGUpLCBbcm91dGVyLCBzZXRTdGF0ZV0pO1xyXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxsYmFja0VsZW1lbnQgPT0gbnVsbCB8fCAhcm91dGVyLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uLCBcImA8Um91dGVyUHJvdmlkZXIgZmFsbGJhY2tFbGVtZW50PmAgaXMgZGVwcmVjYXRlZCB3aGVuIHVzaW5nIFwiICsgXCJgdjdfcGFydGlhbEh5ZHJhdGlvbmAsIHVzZSBhIGBIeWRyYXRlRmFsbGJhY2tgIGNvbXBvbmVudCBpbnN0ZWFkXCIpIDogdm9pZCAwO1xyXG4gICAgLy8gT25seSBsb2cgdGhpcyBvbmNlIG9uIGluaXRpYWwgbW91bnRcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICB9LCBbXSk7XHJcbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY3JlYXRlSHJlZjogcm91dGVyLmNyZWF0ZUhyZWYsXHJcbiAgICAgIGVuY29kZUxvY2F0aW9uOiByb3V0ZXIuZW5jb2RlTG9jYXRpb24sXHJcbiAgICAgIGdvOiBuID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcclxuICAgICAgcHVzaDogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XHJcbiAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxyXG4gICAgICB9KSxcclxuICAgICAgcmVwbGFjZTogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XHJcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XHJcbiAgICAgIH0pXHJcbiAgICB9O1xyXG4gIH0sIFtyb3V0ZXJdKTtcclxuICBsZXQgYmFzZW5hbWUgPSByb3V0ZXIuYmFzZW5hbWUgfHwgXCIvXCI7XHJcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xyXG4gICAgcm91dGVyLFxyXG4gICAgbmF2aWdhdG9yLFxyXG4gICAgc3RhdGljOiBmYWxzZSxcclxuICAgIGJhc2VuYW1lXHJcbiAgfSksIFtyb3V0ZXIsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcclxuXHJcbiAgLy8gVGhlIGZyYWdtZW50IGFuZCB7bnVsbH0gaGVyZSBhcmUgaW1wb3J0YW50ISAgV2UgbmVlZCB0aGVtIHRvIGtlZXAgUmVhY3QgMTgnc1xyXG4gIC8vIHVzZUlkIGhhcHB5IHdoZW4gd2UgYXJlIHNlcnZlci1yZW5kZXJpbmcgc2luY2Ugd2UgbWF5IGhhdmUgYSA8c2NyaXB0PiBoZXJlXHJcbiAgLy8gY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgc2VydmVyLXNpZGUgc3RhdGljQ29udGV4dCAoZnJvbSBTdGF0aWNSb3V0ZXJQcm92aWRlcikuXHJcbiAgLy8gdXNlSWQgcmVsaWVzIG9uIHRoZSBjb21wb25lbnQgdHJlZSBzdHJ1Y3R1cmUgdG8gZ2VuZXJhdGUgZGV0ZXJtaW5pc3RpYyBpZCdzXHJcbiAgLy8gc28gd2UgbmVlZCB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBvbiB0aGUgY2xpZW50IGV2ZW4gdGhvdWdoXHJcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgPHNjcmlwdD4gdGFnXHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgdmFsdWU6IGRhdGFSb3V0ZXJDb250ZXh0XHJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgdmFsdWU6IHN0YXRlXHJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XHJcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXHJcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXHJcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcclxuICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yLFxyXG4gICAgZnV0dXJlOiB7XHJcbiAgICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiByb3V0ZXIuZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoXHJcbiAgICB9XHJcbiAgfSwgc3RhdGUuaW5pdGlhbGl6ZWQgfHwgcm91dGVyLmZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xyXG4gICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxyXG4gICAgZnV0dXJlOiByb3V0ZXIuZnV0dXJlLFxyXG4gICAgc3RhdGU6IHN0YXRlXHJcbiAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSksIG51bGwpO1xyXG59XHJcbmZ1bmN0aW9uIERhdGFSb3V0ZXMoX3JlZjIpIHtcclxuICBsZXQge1xyXG4gICAgcm91dGVzLFxyXG4gICAgZnV0dXJlLFxyXG4gICAgc3RhdGVcclxuICB9ID0gX3JlZjI7XHJcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCB1bmRlZmluZWQsIHN0YXRlLCBmdXR1cmUpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL21lbW9yeS1yb3V0ZXJcclxuICovXHJcbmZ1bmN0aW9uIE1lbW9yeVJvdXRlcihfcmVmMykge1xyXG4gIGxldCB7XHJcbiAgICBiYXNlbmFtZSxcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgaW5pdGlhbEVudHJpZXMsXHJcbiAgICBpbml0aWFsSW5kZXgsXHJcbiAgICBmdXR1cmVcclxuICB9ID0gX3JlZjM7XHJcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcclxuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcclxuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xyXG4gICAgICBpbml0aWFsRW50cmllcyxcclxuICAgICAgaW5pdGlhbEluZGV4LFxyXG4gICAgICB2NUNvbXBhdDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xyXG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZSh7XHJcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxyXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cclxuICB9KTtcclxuICBsZXQge1xyXG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXHJcbiAgfSA9IGZ1dHVyZSB8fCB7fTtcclxuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XHJcbiAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xyXG4gIH0sIFtzZXRTdGF0ZUltcGwsIHY3X3N0YXJ0VHJhbnNpdGlvbl0pO1xyXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xyXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcclxuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcclxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcclxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXHJcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnksXHJcbiAgICBmdXR1cmU6IGZ1dHVyZVxyXG4gIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIEFQSSBpcyBtb3N0bHkgdXNlZnVsIGluIFJlYWN0LkNvbXBvbmVudCBzdWJjbGFzc2VzIHRoYXQgYXJlIG5vdFxyXG4gKiBhYmxlIHRvIHVzZSBob29rcy4gSW4gZnVuY3Rpb25hbCBjb21wb25lbnRzLCB3ZSByZWNvbW1lbmQgeW91IHVzZSB0aGVcclxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9uYXZpZ2F0ZVxyXG4gKi9cclxuZnVuY3Rpb24gTmF2aWdhdGUoX3JlZjQpIHtcclxuICBsZXQge1xyXG4gICAgdG8sXHJcbiAgICByZXBsYWNlLFxyXG4gICAgc3RhdGUsXHJcbiAgICByZWxhdGl2ZVxyXG4gIH0gPSBfcmVmNDtcclxuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxyXG4gIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXHJcbiAgXCI8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcbiAgbGV0IHtcclxuICAgIGZ1dHVyZSxcclxuICAgIHN0YXRpYzogaXNTdGF0aWNcclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XHJcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoIWlzU3RhdGljLCBcIjxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gXCIgKyBcIlRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBcIiArIFwib25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuXCIpIDogdm9pZCAwO1xyXG4gIGxldCB7XHJcbiAgICBtYXRjaGVzXHJcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcclxuICBsZXQge1xyXG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcclxuICB9ID0gdXNlTG9jYXRpb24oKTtcclxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xyXG5cclxuICAvLyBSZXNvbHZlIHRoZSBwYXRoIG91dHNpZGUgb2YgdGhlIGVmZmVjdCBzbyB0aGF0IHdoZW4gZWZmZWN0cyBydW4gdHdpY2UgaW5cclxuICAvLyBTdHJpY3RNb2RlIHRoZXkgbmF2aWdhdGUgdG8gdGhlIHNhbWUgcGxhY2VcclxuICBsZXQgcGF0aCA9IHJlc29sdmVUbyh0bywgVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMobWF0Y2hlcywgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKSwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKTtcclxuICBsZXQganNvblBhdGggPSBKU09OLnN0cmluZ2lmeShwYXRoKTtcclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gbmF2aWdhdGUoSlNPTi5wYXJzZShqc29uUGF0aCksIHtcclxuICAgIHJlcGxhY2UsXHJcbiAgICBzdGF0ZSxcclxuICAgIHJlbGF0aXZlXHJcbiAgfSksIFtuYXZpZ2F0ZSwganNvblBhdGgsIHJlbGF0aXZlLCByZXBsYWNlLCBzdGF0ZV0pO1xyXG4gIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSBjaGlsZCByb3V0ZSdzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cclxuICpcclxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL291dGxldFxyXG4gKi9cclxuZnVuY3Rpb24gT3V0bGV0KHByb3BzKSB7XHJcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcclxufVxyXG4vKipcclxuICogRGVjbGFyZXMgYW4gZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBhdCBhIGNlcnRhaW4gVVJMIHBhdGguXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZVxyXG4gKi9cclxuZnVuY3Rpb24gUm91dGUoX3Byb3BzKSB7XHJcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIFwiICsgXCJuZXZlciByZW5kZXJlZCBkaXJlY3RseS4gUGxlYXNlIHdyYXAgeW91ciA8Um91dGU+IGluIGEgPFJvdXRlcz4uXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgO1xyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxyXG4gKlxyXG4gKiBOb3RlOiBZb3UgdXN1YWxseSB3b24ndCByZW5kZXIgYSBgPFJvdXRlcj5gIGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcclxuICogcm91dGVyIHRoYXQgaXMgbW9yZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50IHN1Y2ggYXMgYSBgPEJyb3dzZXJSb3V0ZXI+YFxyXG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSBgPFN0YXRpY1JvdXRlcj5gIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL3JvdXRlclxyXG4gKi9cclxuZnVuY3Rpb24gUm91dGVyKF9yZWY1KSB7XHJcbiAgbGV0IHtcclxuICAgIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcclxuICAgIGNoaWxkcmVuID0gbnVsbCxcclxuICAgIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXHJcbiAgICBuYXZpZ2F0aW9uVHlwZSA9IEFjdGlvbi5Qb3AsXHJcbiAgICBuYXZpZ2F0b3IsXHJcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZSxcclxuICAgIGZ1dHVyZVxyXG4gIH0gPSBfcmVmNTtcclxuICAhIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LlwiICsgXCIgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XHJcblxyXG4gIC8vIFByZXNlcnZlIHRyYWlsaW5nIHNsYXNoZXMgb24gYmFzZW5hbWUsIHNvIHdlIGNhbiBsZXQgdGhlIHVzZXIgY29udHJvbFxyXG4gIC8vIHRoZSBlbmZvcmNlbWVudCBvZiB0cmFpbGluZyBzbGFzaGVzIHRocm91Z2hvdXQgdGhlIGFwcFxyXG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcclxuICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XHJcbiAgICBiYXNlbmFtZSxcclxuICAgIG5hdmlnYXRvcixcclxuICAgIHN0YXRpYzogc3RhdGljUHJvcCxcclxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe1xyXG4gICAgICB2N19yZWxhdGl2ZVNwbGF0UGF0aDogZmFsc2VcclxuICAgIH0sIGZ1dHVyZSlcclxuICB9KSwgW2Jhc2VuYW1lLCBmdXR1cmUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF0pO1xyXG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcclxuICB9XHJcbiAgbGV0IHtcclxuICAgIHBhdGhuYW1lID0gXCIvXCIsXHJcbiAgICBzZWFyY2ggPSBcIlwiLFxyXG4gICAgaGFzaCA9IFwiXCIsXHJcbiAgICBzdGF0ZSA9IG51bGwsXHJcbiAgICBrZXkgPSBcImRlZmF1bHRcIlxyXG4gIH0gPSBsb2NhdGlvblByb3A7XHJcbiAgbGV0IGxvY2F0aW9uQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XHJcbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbG9jYXRpb246IHtcclxuICAgICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcclxuICAgICAgICBzZWFyY2gsXHJcbiAgICAgICAgaGFzaCxcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgICBrZXlcclxuICAgICAgfSxcclxuICAgICAgbmF2aWdhdGlvblR5cGVcclxuICAgIH07XHJcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5LCBuYXZpZ2F0aW9uVHlwZV0pO1xyXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGxvY2F0aW9uQ29udGV4dCAhPSBudWxsLCBcIjxSb3V0ZXIgYmFzZW5hbWU9XFxcIlwiICsgYmFzZW5hbWUgKyBcIlxcXCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgXCIgKyAoXCJcXFwiXCIgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggKyBcIlxcXCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBcIikgKyBcImJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLlwiKSA6IHZvaWQgMDtcclxuICBpZiAobG9jYXRpb25Db250ZXh0ID09IG51bGwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcclxuICAgIHZhbHVlOiBuYXZpZ2F0aW9uQ29udGV4dFxyXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgdmFsdWU6IGxvY2F0aW9uQ29udGV4dFxyXG4gIH0pKTtcclxufVxyXG4vKipcclxuICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgYDxSb3V0ZT5gIGVsZW1lbnRzIHRoYXQgcmVuZGVycyB0aGUgYnJhbmNoXHJcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBSb3V0ZXMoX3JlZjYpIHtcclxuICBsZXQge1xyXG4gICAgY2hpbGRyZW4sXHJcbiAgICBsb2NhdGlvblxyXG4gIH0gPSBfcmVmNjtcclxuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcclxufVxyXG4vKipcclxuICogQ29tcG9uZW50IHRvIHVzZSBmb3IgcmVuZGVyaW5nIGxhemlseSBsb2FkZWQgZGF0YSBmcm9tIHJldHVybmluZyBkZWZlcigpXHJcbiAqIGluIGEgbG9hZGVyIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBBd2FpdChfcmVmNykge1xyXG4gIGxldCB7XHJcbiAgICBjaGlsZHJlbixcclxuICAgIGVycm9yRWxlbWVudCxcclxuICAgIHJlc29sdmVcclxuICB9ID0gX3JlZjc7XHJcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0RXJyb3JCb3VuZGFyeSwge1xyXG4gICAgcmVzb2x2ZTogcmVzb2x2ZSxcclxuICAgIGVycm9yRWxlbWVudDogZXJyb3JFbGVtZW50XHJcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzb2x2ZUF3YWl0LCBudWxsLCBjaGlsZHJlbikpO1xyXG59XHJcbnZhciBBd2FpdFJlbmRlclN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoQXdhaXRSZW5kZXJTdGF0dXMpIHtcclxuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcInBlbmRpbmdcIl0gPSAwXSA9IFwicGVuZGluZ1wiO1xyXG4gIEF3YWl0UmVuZGVyU3RhdHVzW0F3YWl0UmVuZGVyU3RhdHVzW1wic3VjY2Vzc1wiXSA9IDFdID0gXCJzdWNjZXNzXCI7XHJcbiAgQXdhaXRSZW5kZXJTdGF0dXNbQXdhaXRSZW5kZXJTdGF0dXNbXCJlcnJvclwiXSA9IDJdID0gXCJlcnJvclwiO1xyXG4gIHJldHVybiBBd2FpdFJlbmRlclN0YXR1cztcclxufShBd2FpdFJlbmRlclN0YXR1cyB8fCB7fSk7XHJcbmNvbnN0IG5ldmVyU2V0dGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XHJcbmNsYXNzIEF3YWl0RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgIGVycm9yOiBudWxsXHJcbiAgICB9O1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlcnJvclxyXG4gICAgfTtcclxuICB9XHJcbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xyXG4gICAgY29uc29sZS5lcnJvcihcIjxBd2FpdD4gY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLCBlcnJvciwgZXJyb3JJbmZvKTtcclxuICB9XHJcbiAgcmVuZGVyKCkge1xyXG4gICAgbGV0IHtcclxuICAgICAgY2hpbGRyZW4sXHJcbiAgICAgIGVycm9yRWxlbWVudCxcclxuICAgICAgcmVzb2x2ZVxyXG4gICAgfSA9IHRoaXMucHJvcHM7XHJcbiAgICBsZXQgcHJvbWlzZSA9IG51bGw7XHJcbiAgICBsZXQgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcclxuICAgIGlmICghKHJlc29sdmUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xyXG4gICAgICAvLyBEaWRuJ3QgZ2V0IGEgcHJvbWlzZSAtIHByb3ZpZGUgYXMgYSByZXNvbHZlZCBwcm9taXNlXHJcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3M7XHJcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xyXG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwge1xyXG4gICAgICAgIGdldDogKCkgPT4gcmVzb2x2ZVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xyXG4gICAgICAvLyBDYXVnaHQgYSByZW5kZXIgZXJyb3IsIHByb3ZpZGUgaXQgYXMgYSByZWplY3RlZCBwcm9taXNlXHJcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yO1xyXG4gICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xyXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoKS5jYXRjaCgoKSA9PiB7fSk7IC8vIEF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb24gd2FybmluZ3NcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xyXG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcclxuICAgICAgICBnZXQ6ICgpID0+IHJlbmRlckVycm9yXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChyZXNvbHZlLl90cmFja2VkKSB7XHJcbiAgICAgIC8vIEFscmVhZHkgdHJhY2tlZCBwcm9taXNlIC0gY2hlY2sgY29udGVudHNcclxuICAgICAgcHJvbWlzZSA9IHJlc29sdmU7XHJcbiAgICAgIHN0YXR1cyA9IFwiX2Vycm9yXCIgaW4gcHJvbWlzZSA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yIDogXCJfZGF0YVwiIGluIHByb21pc2UgPyBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzIDogQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJhdyAodW50cmFja2VkKSBwcm9taXNlIC0gdHJhY2sgaXRcclxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX3RyYWNrZWRcIiwge1xyXG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxyXG4gICAgICB9KTtcclxuICAgICAgcHJvbWlzZSA9IHJlc29sdmUudGhlbihkYXRhID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9kYXRhXCIsIHtcclxuICAgICAgICBnZXQ6ICgpID0+IGRhdGFcclxuICAgICAgfSksIGVycm9yID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9lcnJvclwiLCB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBlcnJvclxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiBwcm9taXNlLl9lcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yKSB7XHJcbiAgICAgIC8vIEZyZWV6ZSB0aGUgVUkgYnkgdGhyb3dpbmcgYSBuZXZlciByZXNvbHZlZCBwcm9taXNlXHJcbiAgICAgIHRocm93IG5ldmVyU2V0dGxlZFByb21pc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiAhZXJyb3JFbGVtZW50KSB7XHJcbiAgICAgIC8vIE5vIGVycm9yRWxlbWVudCwgdGhyb3cgdG8gdGhlIG5lYXJlc3Qgcm91dGUtbGV2ZWwgZXJyb3IgYm91bmRhcnlcclxuICAgICAgdGhyb3cgcHJvbWlzZS5fZXJyb3I7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcikge1xyXG4gICAgICAvLyBSZW5kZXIgdmlhIG91ciBlcnJvckVsZW1lbnRcclxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwge1xyXG4gICAgICAgIHZhbHVlOiBwcm9taXNlLFxyXG4gICAgICAgIGNoaWxkcmVuOiBlcnJvckVsZW1lbnRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzKSB7XHJcbiAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiB3aXRoIHJlc29sdmVkIHZhbHVlXHJcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHtcclxuICAgICAgICB2YWx1ZTogcHJvbWlzZSxcclxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhyb3cgdG8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5XHJcbiAgICB0aHJvdyBwcm9taXNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEluZGlyZWN0aW9uIHRvIGxldmVyYWdlIHVzZUFzeW5jVmFsdWUgZm9yIGEgcmVuZGVyLXByb3AgQVBJIG9uIGA8QXdhaXQ+YFxyXG4gKi9cclxuZnVuY3Rpb24gUmVzb2x2ZUF3YWl0KF9yZWY4KSB7XHJcbiAgbGV0IHtcclxuICAgIGNoaWxkcmVuXHJcbiAgfSA9IF9yZWY4O1xyXG4gIGxldCBkYXRhID0gdXNlQXN5bmNWYWx1ZSgpO1xyXG4gIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YSkgOiBjaGlsZHJlbjtcclxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHRvUmVuZGVyKTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4vLyBVVElMU1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxyXG4gKiBlaXRoZXIgYSBgPFJvdXRlPmAgZWxlbWVudCBvciBhbiBhcnJheSBvZiB0aGVtLiBVc2VkIGludGVybmFsbHkgYnlcclxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvY3JlYXRlLXJvdXRlcy1mcm9tLWNoaWxkcmVuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFBhdGgpIHtcclxuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XHJcbiAgICBwYXJlbnRQYXRoID0gW107XHJcbiAgfVxyXG4gIGxldCByb3V0ZXMgPSBbXTtcclxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCwgaW5kZXgpID0+IHtcclxuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xyXG4gICAgICAvLyBJZ25vcmUgbm9uLWVsZW1lbnRzLiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gbW9yZSBlYXNpbHkgaW5saW5lXHJcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XHJcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xyXG4gICAgICAvLyBUcmFuc3BhcmVudGx5IHN1cHBvcnQgUmVhY3QuRnJhZ21lbnQgYW5kIGl0cyBjaGlsZHJlbi5cclxuICAgICAgcm91dGVzLnB1c2guYXBwbHkocm91dGVzLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgIShlbGVtZW50LnR5cGUgPT09IFJvdXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiW1wiICsgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZSkgKyBcIl0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xyXG4gICAgISghZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcclxuICAgIGxldCByb3V0ZSA9IHtcclxuICAgICAgaWQ6IGVsZW1lbnQucHJvcHMuaWQgfHwgdHJlZVBhdGguam9pbihcIi1cIiksXHJcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcclxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxyXG4gICAgICBDb21wb25lbnQ6IGVsZW1lbnQucHJvcHMuQ29tcG9uZW50LFxyXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcclxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoLFxyXG4gICAgICBsb2FkZXI6IGVsZW1lbnQucHJvcHMubG9hZGVyLFxyXG4gICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxyXG4gICAgICBlcnJvckVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50LFxyXG4gICAgICBFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnksXHJcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXHJcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IGVsZW1lbnQucHJvcHMuc2hvdWxkUmV2YWxpZGF0ZSxcclxuICAgICAgaGFuZGxlOiBlbGVtZW50LnByb3BzLmhhbmRsZSxcclxuICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5XHJcbiAgICB9O1xyXG4gICAgaWYgKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcclxuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpO1xyXG4gICAgfVxyXG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xyXG4gIH0pO1xyXG4gIHJldHVybiByb3V0ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoZSByZXN1bHQgb2YgYG1hdGNoUm91dGVzKClgIGludG8gYSBSZWFjdCBlbGVtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKSB7XHJcbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGUpIHtcclxuICBsZXQgdXBkYXRlcyA9IHtcclxuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxyXG4gICAgLy8gdGhlcmUgaWYgeW91IGNoYW5nZSB0aGlzIC0tIHBsZWFzZSBhbmQgdGhhbmsgeW91IVxyXG4gICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IHJvdXRlLmVycm9yRWxlbWVudCAhPSBudWxsXHJcbiAgfTtcclxuICBpZiAocm91dGUuQ29tcG9uZW50KSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgIGlmIChyb3V0ZS5lbGVtZW50KSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBDb21wb25lbnRgIGFuZCBgZWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgQ29tcG9uZW50YCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcclxuICAgICAgZWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuQ29tcG9uZW50KSxcclxuICAgICAgQ29tcG9uZW50OiB1bmRlZmluZWRcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgIGlmIChyb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBIeWRyYXRlRmFsbGJhY2tgIGFuZCBgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgSHlkcmF0ZUZhbGxiYWNrYCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcclxuICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSxcclxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiB1bmRlZmluZWRcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAocm91dGUuRXJyb3JCb3VuZGFyeSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICBpZiAocm91dGUuZXJyb3JFbGVtZW50KSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBFcnJvckJvdW5kYXJ5YCBhbmQgYGVycm9yRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgRXJyb3JCb3VuZGFyeWAgd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XHJcbiAgICAgIGVycm9yRWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXHJcbiAgICAgIEVycm9yQm91bmRhcnk6IHVuZGVmaW5lZFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiB1cGRhdGVzO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcclxuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcclxuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxyXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcclxuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlXHJcbiAgICB9KSxcclxuICAgIGhpc3Rvcnk6IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xyXG4gICAgICBpbml0aWFsRW50cmllczogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5pbml0aWFsRW50cmllcyxcclxuICAgICAgaW5pdGlhbEluZGV4OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmluaXRpYWxJbmRleFxyXG4gICAgfSksXHJcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmh5ZHJhdGlvbkRhdGEsXHJcbiAgICByb3V0ZXMsXHJcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXHJcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZGF0YVN0cmF0ZWd5LFxyXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25cclxuICB9KS5pbml0aWFsaXplKCk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IEF3YWl0LCBNZW1vcnlSb3V0ZXIsIE5hdmlnYXRlLCBPdXRsZXQsIFJvdXRlLCBSb3V0ZXIsIFJvdXRlclByb3ZpZGVyLCBSb3V0ZXMsIERhdGFSb3V0ZXJDb250ZXh0IGFzIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCwgRGF0YVJvdXRlclN0YXRlQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCwgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCwgUm91dGVDb250ZXh0IGFzIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIG1hcFJvdXRlUHJvcGVydGllcyBhcyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLCB1c2VSb3V0ZUlkIGFzIFVOU0FGRV91c2VSb3V0ZUlkLCB1c2VSb3V0ZXNJbXBsIGFzIFVOU0FGRV91c2VSb3V0ZXNJbXBsLCBjcmVhdGVNZW1vcnlSb3V0ZXIsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiwgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIGFzIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cywgcmVuZGVyTWF0Y2hlcywgdXNlQWN0aW9uRGF0YSwgdXNlQXN5bmNFcnJvciwgdXNlQXN5bmNWYWx1ZSwgdXNlQmxvY2tlciwgdXNlSHJlZiwgdXNlSW5Sb3V0ZXJDb250ZXh0LCB1c2VMb2FkZXJEYXRhLCB1c2VMb2NhdGlvbiwgdXNlTWF0Y2gsIHVzZU1hdGNoZXMsIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlUmV2YWxpZGF0b3IsIHVzZVJvdXRlRXJyb3IsIHVzZVJvdXRlTG9hZGVyRGF0YSwgdXNlUm91dGVzIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-router/dist/index.js\n"));

/***/ })

}]);