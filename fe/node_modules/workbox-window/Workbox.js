/*
  Copyright 2019 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
import { Deferred } from 'workbox-core/_private/Deferred.js';
import { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';
import { logger } from 'workbox-core/_private/logger.js';
import { messageSW } from './messageSW.js';
import { WorkboxEventTarget } from './utils/WorkboxEventTarget.js';
import { urlsMatch } from './utils/urlsMatch.js';
import { WorkboxEvent } from './utils/WorkboxEvent.js';
import './_version.js';
// The time a SW must be in the waiting phase before we can conclude
// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically
// chosen, but it seems to avoid false positives in my testing.
const WAITING_TIMEOUT_DURATION = 200;
// The amount of time after a registration that we can reasonably conclude
// that the registration didn't trigger an update.
const REGISTRATION_TIMEOUT_DURATION = 60000;
// The de facto standard message that a service worker should be listening for
// to trigger a call to skipWaiting().
const SKIP_WAITING_MESSAGE = { type: 'SKIP_WAITING' };
/**
 * A class to aid in handling service worker registration, updates, and
 * reacting to service worker lifecycle events.
 *
 * @fires {@link workbox-window.Workbox#message}
 * @fires {@link workbox-window.Workbox#installed}
 * @fires {@link workbox-window.Workbox#waiting}
 * @fires {@link workbox-window.Workbox#controlling}
 * @fires {@link workbox-window.Workbox#activated}
 * @fires {@link workbox-window.Workbox#redundant}
 * @memberof workbox-window
 */
class Workbox extends WorkboxEventTarget {
    /**
     * Creates a new Workbox instance with a script URL and service worker
     * options. The script URL and options are the same as those used when
     * calling [navigator.serviceWorker.register(scriptURL, options)](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).
     *
     * @param {string|TrustedScriptURL} scriptURL The service worker script
     *     associated with this instance. Using a
     *     [`TrustedScriptURL`](https://web.dev/trusted-types/) is supported.
     * @param {Object} [registerOptions] The service worker options associated
     *     with this instance.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    constructor(scriptURL, registerOptions = {}) {
        super();
        this._registerOptions = {};
        this._updateFoundCount = 0;
        // Deferreds we can resolve later.
        this._swDeferred = new Deferred();
        this._activeDeferred = new Deferred();
        this._controllingDeferred = new Deferred();
        this._registrationTime = 0;
        this._ownSWs = new Set();
        /**
         * @private
         */
        this._onUpdateFound = () => {
            // `this._registration` will never be `undefined` after an update is found.
            const registration = this._registration;
            const installingSW = registration.installing;
            // If the script URL passed to `navigator.serviceWorker.register()` is
            // different from the current controlling SW's script URL, we know any
            // successful registration calls will trigger an `updatefound` event.
            // But if the registered script URL is the same as the current controlling
            // SW's script URL, we'll only get an `updatefound` event if the file
            // changed since it was last registered. This can be a problem if the user
            // opens up the same page in a different tab, and that page registers
            // a SW that triggers an update. It's a problem because this page has no
            // good way of knowing whether the `updatefound` event came from the SW
            // script it registered or from a registration attempt made by a newer
            // version of the page running in another tab.
            // To minimize the possibility of a false positive, we use the logic here:
            const updateLikelyTriggeredExternally = 
            // Since we enforce only calling `register()` once, and since we don't
            // add the `updatefound` event listener until the `register()` call, if
            // `_updateFoundCount` is > 0 then it means this method has already
            // been called, thus this SW must be external
            this._updateFoundCount > 0 ||
                // If the script URL of the installing SW is different from this
                // instance's script URL, we know it's definitely not from our
                // registration.
                !urlsMatch(installingSW.scriptURL, this._scriptURL.toString()) ||
                // If all of the above are false, then we use a time-based heuristic:
                // Any `updatefound` event that occurs long after our registration is
                // assumed to be external.
                performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION
                ? // If any of the above are not true, we assume the upda