{"version":3,"names":["_helperReplaceSupers","require","_core","_traverse","_helperAnnotateAsPure","_inlineCallSuperHelpers","buildConstructor","classRef","constructorBody","node","func","t","functionDeclaration","cloneNode","inherits","transformClass","path","file","builtinClasses","isLoose","assumptions","supportUnicodeId","classState","parent","undefined","scope","classId","superName","superReturns","isDerived","extendsNative","construct","userConstructor","userConstructorPath","hasConstructor","body","superThises","pushedInherits","pushedCreateClass","protoAlias","dynamicKeys","Map","methods","instance","hasComputed","list","map","static","setState","newState","Object","assign","findThisesVisitor","visitors","environmentVisitor","ThisExpression","push","createClassHelper","args","callExpression","addHelper","maybeCreateConstructor","classBodyPath","get","isClassMethod","kind","params","constructor","template","expression","ast","blockStatement","unshiftContainer","classMethod","identifier","buildBody","pushBody","verifyConstructor","pushDescriptors","classBodyPaths","isClassProperty","isClassPrivateProperty","buildCodeFrameError","decorators","isConstructor","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","constantSuper","refToPreserve","replace","traverse","ReturnStatement","getFunctionParent","isArrowFunctionExpression","pushConstructor","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype","wrapped","replaceWith","pushMethod","pushInheritsToBody","props","placement","length","desc","obj","objectExpression","objectProperty","key","properties","arrayExpression","nullLiteral","lastNonNullIndex","i","isNullLiteral","slice","returnStatement","wrapSuperCall","bareSuper","thisRef","bareSuperNode","call","superIsCallableConstructor","arguments","unshift","thisExpression","isSpreadElement","isIdentifier","argument","name","callee","memberExpression","logicalExpression","_bareSuperNode$argume","bareSuperNodeArguments","addCallSuperHelper","parentPath","isExpressionStatement","container","assignmentExpression","maxGuaranteedSuperBeforeIndex","ref","generateDeclaredUidIdentifier","buildAssertThisInitialized","bareSupers","Super","isCallExpression","lastParentPath","find","Math","min","type","left","isConditional","test","object","guaranteedCalls","Set","thisPath","isMemberExpression","thisIndex","exprPath","isSequenceExpression","listKey","isOptionalCallExpression","has","add","wrapReturn","returnArg","thisExpr","returnParams","bodyPaths","guaranteedSuperBeforeFinish","pop","isReturnStatement","pushContainer","returnPath","processMethod","descKey","isNumericLiteral","isBigIntLiteral","stringLiteral","String","value","toComputedKey","isStringLiteral","fn","toExpression","descriptor","set","setClassMethods","insertProtoAliasOnce","methodName","computed","isLiteral","functionExpression","id","generator","async","expr","expressionStatement","inheritsComments","generateUidIdentifier","classProto","protoDeclaration","variableDeclaration","variableDeclarator","method","directives","hasInstanceDescriptors","hasStaticDescriptors","extractDynamicKeys","elem","isPure","generateUidIdentifierBasedOnNode","setupClosureParamsArgs","closureParams","closureArgs","arg","annotateAsPure","param","classTransformer","superClass","hasBinding","noClassCalls","isStrict","isInStrictMode","constructorOnly","directive","directiveLiteral","arrowFunctionExpression"],"sources":["../src/transformClass.ts"],"sourcesContent":["import type { NodePath, Scope, File } from \"@babel/core\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport { template, types as t } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport addCallSuperHelper from \"./inline-callSuper-helpers.ts\";\n\ntype ClassAssumptions = {\n  setClassMethods: boolean;\n  constantSuper: boolean;\n  superIsCallableConstructor: boolean;\n  noClassCalls: boolean;\n};\n\ntype ClassConstructor = t.ClassMethod & { kind: \"constructor\" };\n\nfunction buildConstructor(\n  classRef: t.Identifier,\n  constructorBody: t.BlockStatement,\n  node: t.Class,\n) {\n  const func = t.functionDeclaration(\n    t.cloneNode(classRef),\n    [],\n    constructorBody,\n  );\n  t.inherits(func, node);\n  return func;\n}\n\ntype Descriptor = {\n  key: t.Expression;\n  get?: t.Expression | null;\n  set?: t.Expression | null;\n  value?: t.Expression | null;\n  constructor?: t.Expression | null;\n};\n\ntype State = {\n  parent: t.Node;\n  scope: Scope;\n  node: t.Class;\n  path: NodePath<t.Class>;\n  file: File;\n\n  classId: t.Identifier | void;\n  classRef: t.Identifier;\n  superName: t.Expression | null;\n  superReturns: NodePath<t.ReturnStatement>[];\n  isDerived: boolean;\n  extendsNative: boolean;\n\n  construct: t.FunctionDeclaration;\n  constructorBody: t.BlockStatement;\n  userConstructor: ClassConstructor;\n  userConstructorPath: NodePath<ClassConstructor>;\n  hasConstructor: boolean;\n\n  body: t.Statement[];\n  superThises: NodePath<t.ThisExpression>[];\n  pushedInherits: boolean;\n  pushedCreateClass: boolean;\n  protoAlias: t.Identifier | null;\n  isLoose: boolean;\n\n  dynamicKeys: Map<string, t.Expression>;\n\n  methods: {\n    // 'list' is in the same order as the elements appear in the class body.\n    // if there aren't computed keys, we can safely reorder class elements\n    // and use 'map' to merge duplicates.\n    instance: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n    static: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n  };\n};\n\ntype PropertyInfo = {\n  instance: t.ObjectExpression[] | null;\n  static: t.ObjectExpression[] | null;\n};\n\nexport default function transformClass(\n  path: NodePath<t.Class>,\n  file: File,\n  builtinClasses: ReadonlySet<string>,\n  isLoose: boolean,\n  assumptions: ClassAssumptions,\n  supportUnicodeId: boolean,\n) {\n  const classState: State = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n\n    classId: undefined,\n    classRef: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n\n    body: [],\n    superThises: [],\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n\n    dynamicKeys: new Map(),\n\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n    },\n  };\n\n  const setState = (newState: Partial<State>) => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = visitors.environmentVisitor({\n    ThisExpression(path) {\n      classState.superThises.push(path);\n    },\n  });\n\n  function createClassHelper(args: t.Expression[]) {\n    return t.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n\n  /**\n   * Creates a class constructor or bail out if there is one\n   */\n  function maybeCreateConstructor() {\n    const classBodyPath = classState.path.get(\"body\");\n    for (const path of classBodyPath.get(\"body\")) {\n      if (path.isClassMethod({ kind: \"constructor\" })) return;\n    }\n\n    let params: t.FunctionExpression[\"params\"], body;\n\n    if (classState.isDerived) {\n      const constructor = template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      ` as t.FunctionExpression;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = t.blockStatement([]);\n    }\n\n    classBodyPath.unshiftContainer(\n      \"body\",\n      t.classMethod(\"constructor\", t.identifier(\"constructor\"), params, body),\n    );\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const { constructorBody, userConstructor, construct } = classState;\n\n      constructorBody.body.push(...userConstructor.body.body);\n      t.inherits(construct, userConstructor);\n      t.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths: Array<any> = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty() || path.isClassPrivateProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\n          \"Method has decorators, put the decorator plugin before the classes one.\",\n        );\n      }\n\n      if (t.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n\n        const replaceSupers = new ReplaceSupers({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef,\n        });\n\n        replaceSupers.replace();\n\n        const superReturns: NodePath<t.ReturnStatement>[] = [];\n        path.traverse(\n          visitors.environmentVisitor({\n            ReturnStatement(path) {\n              if (!path.getFunctionParent().isArrowFunctionExpression()) {\n                superReturns.push(path);\n              }\n            },\n          }),\n        );\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node as ClassConstructor, path);\n        } else {\n          if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n            // polyfill when being run by an older Babel version\n            path.ensureFunctionName ??=\n              // eslint-disable-next-line no-restricted-globals\n              require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n          }\n          path.ensureFunctionName(supportUnicodeId);\n          let wrapped;\n          if (node !== path.node) {\n            wrapped = path.node;\n            // The node has been wrapped. Reset it to the original once, but store the wrapper.\n            path.replaceWith(node);\n          }\n\n          pushMethod(node, wrapped);\n        }\n      }\n    }\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n\n    const { body } = classState;\n\n    const props: PropertyInfo = {\n      instance: null,\n      static: null,\n    };\n\n    for (const placement of [\"static\", \"instance\"] as const) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = t.objectExpression([\n            t.objectProperty(t.identifier(\"key\"), desc.key),\n          ]);\n\n          for (const kind of [\"get\", \"set\", \"value\"] as const) {\n            if (desc[kind] != null) {\n              obj.properties.push(\n                t.objectProperty(t.identifier(kind), desc[kind]),\n              );\n            }\n          }\n\n          return obj;\n        });\n      }\n    }\n\n    if (props.instance || props.static) {\n      let args = [\n        t.cloneNode(classState.classRef), // Constructor\n        props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors\n        props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors\n      ];\n\n      let lastNonNullIndex = 0;\n      for (let i = 0; i < args.length; i++) {\n        if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n\n      body.push(t.returnStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n\n  function wrapSuperCall(\n    bareSuper: NodePath<t.CallExpression>,\n    superRef: t.Expression,\n    thisRef: () => t.Identifier,\n    body: NodePath<t.BlockStatement>,\n  ) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(t.thisExpression());\n      if (\n        bareSuperNode.arguments.length === 2 &&\n        t.isSpreadElement(bareSuperNode.arguments[1]) &&\n        t.isIdentifier(bareSuperNode.arguments[1].argument, {\n          name: \"arguments\",\n        })\n      ) {\n        // special case single arguments spread\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"apply\"),\n        );\n      } else {\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"call\"),\n        );\n      }\n\n      call = t.logicalExpression(\"||\", bareSuperNode, t.thisExpression());\n    } else {\n      const args: t.Expression[] = [\n        t.thisExpression(),\n        t.cloneNode(classState.classRef),\n      ];\n      if (bareSuperNode.arguments?.length) {\n        const bareSuperNodeArguments = bareSuperNode.arguments as (\n          | t.Expression\n          | t.SpreadElement\n        )[];\n\n        /**\n         * test262/test/language/expressions/super/call-spread-err-sngl-err-itr-get-get.js\n         *\n         * var iter = {};\n         * Object.defineProperty(iter, Symbol.iterator, {\n         *   get: function() {\n         *     throw new Test262Error();\n         *   }\n         * })\n         * super(...iter);\n         */\n\n        if (\n          bareSuperNodeArguments.length === 1 &&\n          t.isSpreadElement(bareSuperNodeArguments[0]) &&\n          t.isIdentifier(bareSuperNodeArguments[0].argument, {\n            name: \"arguments\",\n          })\n        ) {\n          args.push(bareSuperNodeArguments[0].argument);\n        } else {\n          args.push(t.arrayExpression(bareSuperNodeArguments));\n        }\n      }\n      call = t.callExpression(addCallSuperHelper(classState.file), args);\n    }\n\n    if (\n      bareSuper.parentPath.isExpressionStatement() &&\n      bareSuper.parentPath.container === body.node.body &&\n      body.node.body.length - 1 === bareSuper.parentPath.key\n    ) {\n      // this super call is the last statement in the body so we can just straight up\n      // turn it into a return\n\n      if (classState.superThises.length) {\n        call = t.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(t.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(t.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n\n    const constructorBody = path.get(\"body\");\n\n    let maxGuaranteedSuperBeforeIndex = constructorBody.node.body.length;\n\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n      maxGuaranteedSuperBeforeIndex++;\n      thisRef = () => t.cloneNode(ref);\n      return ref;\n    };\n\n    const buildAssertThisInitialized = function () {\n      return t.callExpression(\n        classState.file.addHelper(\"assertThisInitialized\"),\n        [thisRef()],\n      );\n    };\n\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    path.traverse(\n      visitors.environmentVisitor({\n        Super(path) {\n          const { node, parentPath } = path;\n          if (parentPath.isCallExpression({ callee: node })) {\n            bareSupers.unshift(parentPath);\n          }\n        },\n      }),\n    );\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (maxGuaranteedSuperBeforeIndex >= 0) {\n        let lastParentPath: NodePath;\n        bareSuper.find(function (parentPath) {\n          // hit top so short circuit\n          if (parentPath === constructorBody) {\n            maxGuaranteedSuperBeforeIndex = Math.min(\n              maxGuaranteedSuperBeforeIndex,\n              lastParentPath.key as number,\n            );\n            return true;\n          }\n\n          const { type } = parentPath;\n          switch (type) {\n            case \"ExpressionStatement\":\n            case \"SequenceExpression\":\n            case \"AssignmentExpression\":\n            case \"BinaryExpression\":\n            case \"MemberExpression\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"VariableDeclarator\":\n            case \"VariableDeclaration\":\n            case \"BlockStatement\":\n            case \"ArrayExpression\":\n            case \"ObjectExpression\":\n            case \"ObjectProperty\":\n            case \"TemplateLiteral\":\n              lastParentPath = parentPath;\n              return false;\n            default:\n              if (\n                (type === \"LogicalExpression\" &&\n                  parentPath.node.left === lastParentPath.node) ||\n                (parentPath.isConditional() &&\n                  parentPath.node.test === lastParentPath.node) ||\n                (type === \"OptionalCallExpression\" &&\n                  parentPath.node.callee === lastParentPath.node) ||\n                (type === \"OptionalMemberExpression\" &&\n                  parentPath.node.object === lastParentPath.node)\n              ) {\n                lastParentPath = parentPath;\n                return false;\n              }\n          }\n\n          maxGuaranteedSuperBeforeIndex = -1;\n          return true;\n        });\n      }\n    }\n\n    const guaranteedCalls = new Set<NodePath>();\n\n    for (const thisPath of classState.superThises) {\n      const { node, parentPath } = thisPath;\n      if (parentPath.isMemberExpression({ object: node })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n\n      let thisIndex: number;\n      thisPath.find(function (parentPath) {\n        if (parentPath.parentPath === constructorBody) {\n          thisIndex = parentPath.key as number;\n          return true;\n        }\n      });\n\n      let exprPath: NodePath = thisPath.parentPath.isSequenceExpression()\n        ? thisPath.parentPath\n        : thisPath;\n      if (\n        exprPath.listKey === \"arguments\" &&\n        (exprPath.parentPath.isCallExpression() ||\n          exprPath.parentPath.isOptionalCallExpression())\n      ) {\n        exprPath = exprPath.parentPath;\n      } else {\n        exprPath = null;\n      }\n\n      if (\n        (maxGuaranteedSuperBeforeIndex !== -1 &&\n          thisIndex > maxGuaranteedSuperBeforeIndex) ||\n        guaranteedCalls.has(exprPath)\n      ) {\n        thisPath.replaceWith(thisRef());\n      } else {\n        if (exprPath) {\n          guaranteedCalls.add(exprPath);\n        }\n        thisPath.replaceWith(buildAssertThisInitialized());\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = (returnArg: t.Expression | void) => {\n        const thisExpr = buildAssertThisInitialized();\n        return returnArg\n          ? t.logicalExpression(\"||\", returnArg, thisExpr)\n          : thisExpr;\n      };\n    } else {\n      wrapReturn = (returnArg: t.Expression | undefined) => {\n        const returnParams: t.Expression[] = [thisRef()];\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n        return t.callExpression(\n          classState.file.addHelper(\"possibleConstructorReturn\"),\n          returnParams,\n        );\n      };\n    }\n\n    // if we have a return as the last node in the body then we've already caught that\n    // return\n    const bodyPaths = body.get(\"body\");\n    const guaranteedSuperBeforeFinish =\n      maxGuaranteedSuperBeforeIndex !== -1 &&\n      maxGuaranteedSuperBeforeIndex < bodyPaths.length;\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n 