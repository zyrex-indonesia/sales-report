{"version":3,"sources":["../../../src/server/app-render/app-render.tsx"],"sourcesContent":["import type {\n  ActionResult,\n  DynamicParamTypesShort,\n  FlightRouterState,\n  FlightSegmentPath,\n  RenderOpts,\n  Segment,\n  CacheNodeSeedData,\n  PreloadCallbacks,\n  RSCPayload,\n  FlightData,\n  InitialRSCPayload,\n} from './types'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { NextParsedUrlQuery } from '../request-meta'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { IncomingHttpHeaders } from 'http'\n\nimport React, { type ErrorInfo, type JSX } from 'react'\n\nimport RenderResult, {\n  type AppPageRenderResultMetadata,\n  type RenderResultOptions,\n} from '../render-result'\nimport {\n  chainStreams,\n  renderToInitialFizzStream,\n  createDocumentClosingStream,\n  continueFizzStream,\n  continueDynamicPrerender,\n  continueStaticPrerender,\n  continueDynamicHTMLResume,\n  streamToBuffer,\n  streamToString,\n} from '../stream-utils/node-web-streams-helper'\nimport { stripInternalQueries } from '../internal-utils'\nimport {\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_URL,\n  RSC_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  createTrackedMetadataContext,\n  createMetadataContext,\n} from '../../lib/metadata/metadata-context'\nimport { createRequestStoreForRender } from '../async-storage/request-store'\nimport { withWorkStore } from '../async-storage/with-work-store'\nimport { isNotFoundError } from '../../client/components/not-found'\nimport {\n  getURLFromRedirectError,\n  isRedirectError,\n  getRedirectStatusCodeFromError,\n} from '../../client/components/redirect'\nimport { getImplicitTags } from '../lib/implicit-tags'\nimport { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\nimport { getTracer } from '../lib/trace/tracer'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  createFlightReactServerErrorHandler,\n  createHTMLReactServerErrorHandler,\n  createHTMLErrorHandler,\n  type DigestedError,\n  isUserLandError,\n} from './create-error-handler'\nimport {\n  getShortDynamicParamType,\n  dynamicParamTypes,\n} from './get-short-dynamic-param-type'\nimport { getSegmentParam } from './get-segment-param'\nimport { getScriptNonceFromHeader } from './get-script-nonce-from-header'\nimport { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\nimport { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\nimport { handleAction } from './action-handler'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { warn, error } from '../../build/output/log'\nimport { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'\nimport { createServerInsertedHTML } from './server-inserted-html'\nimport { getRequiredScripts } from './required-scripts'\nimport { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'\nimport { makeGetServerInsertedHTML } from './make-get-server-inserted-html'\nimport { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'\nimport { createComponentTree } from './create-component-tree'\nimport { getAssetQueryString } from './get-asset-query-string'\nimport { setReferenceManifestsSingleton } from './encryption-utils'\nimport {\n  DynamicState,\n  type PostponedState,\n  parsePostponedState,\n} from './postponed-state'\nimport {\n  getDynamicDataPostponedState,\n  getDynamicHTMLPostponedState,\n  getPostponedFromState,\n} from './postponed-state'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  useFlightStream,\n  createInlinedDataReadableStream,\n} from './use-flight-response'\nimport {\n  StaticGenBailoutError,\n  isStaticGenBailoutError,\n} from '../../client/components/static-generation-bailout'\nimport { getStackWithoutErrorMessage } from '../../lib/format-server-error'\nimport {\n  accessedDynamicData,\n  createPostponedAbortSignal,\n  formatDynamicAPIAccesses,\n  isPrerenderInterruptedError,\n  createDynamicTrackingState,\n  createDynamicValidationState,\n  getFirstDynamicReason,\n  trackAllowedDynamicAccess,\n  throwIfDisallowedDynamic,\n  consumeDynamicAccess,\n  type DynamicAccess,\n} from './dynamic-rendering'\nimport {\n  getClientComponentLoaderMetrics,\n  wrapClientComponentLoader,\n} from '../client-component-renderer-logger'\nimport { createServerModuleMap } from './action-utils'\nimport { isNodeNextRequest } from '../base-http/helpers'\nimport { parseParameter } from '../../shared/lib/router/utils/route-regex'\nimport { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\nimport AppRouter from '../../client/components/app-router'\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type { RequestErrorContext } from '../instrumentation/types'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'\nimport { createMutableActionQueue } from '../../shared/lib/router/action-queue'\nimport { getRevalidateReason } from '../instrumentation/utils'\nimport { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport {\n  type ReactServerPrerenderResolveToType,\n  type ReactServerPrerenderResult,\n  ReactServerResult,\n  createReactServerPrerenderResult,\n  createReactServerPrerenderResultFromRender,\n  prerenderAndAbortInSequentialTasks,\n} from './app-render-prerender-utils'\nimport { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\nimport { scheduleInSequentialTasks } from './app-render-render-utils'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStore,\n} from './work-unit-async-storage.external'\nimport { CacheSignal } from './cache-signal'\nimport { getTracedMetadata } from '../lib/trace/utils'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport './clean-async-snapshot.external'\nimport { INFINITE_CACHE } from '../../lib/constants'\n\nexport type GetDynamicParamFromSegment = (\n  // [slug] / [[slug]] / [...slug]\n  segment: string\n) => {\n  param: string\n  value: string | string[] | null\n  treeSegment: Segment\n  type: DynamicParamTypesShort\n} | null\n\nexport type GenerateFlight = typeof generateDynamicFlightRenderResult\n\nexport type AppRenderContext = {\n  workStore: WorkStore\n  requestStore: RequestStore\n  componentMod: AppPageModule\n  renderOpts: RenderOpts\n  parsedRequestHeaders: ParsedRequestHeaders\n  getDynamicParamFromSegment: GetDynamicParamFromSegment\n  query: NextParsedUrlQuery\n  isPrefetch: boolean\n  isAction: boolean\n  requestTimestamp: number\n  appUsingSizeAdjustment: boolean\n  flightRouterState?: FlightRouterState\n  requestId: string\n  pagePath: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  assetPrefix: string\n  isNotFoundPath: boolean\n  nonce: string | undefined\n  res: BaseNextResponse\n}\n\ninterface ParseRequestHeadersOptions {\n  readonly isDevWarmup: undefined | boolean\n  readonly isRoutePPREnabled: boolean\n}\n\nconst flightDataPathHeadKey = 'h'\n\ninterface ParsedRequestHeaders {\n  /**\n   * Router state provided from the client-side router. Used to handle rendering\n   * from the common layout down. This value will be undefined if the request is\n   * not a client-side navigation request, or if the request is a prefetch\n   * request.\n   */\n  readonly flightRouterState: FlightRouterState | undefined\n  readonly isPrefetchRequest: boolean\n  readonly isDevWarmupRequest: boolean\n  readonly isHmrRefresh: boolean\n  readonly isRSCRequest: boolean\n  readonly nonce: string | undefined\n}\n\nfunction parseRequestHeaders(\n  headers: IncomingHttpHeaders,\n  options: ParseRequestHeadersOptions\n): ParsedRequestHeaders {\n  const isDevWarmupRequest = options.isDevWarmup === true\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isPrefetchRequest =\n    isDevWarmupRequest ||\n    headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined\n\n  const isHmrRefresh =\n    headers[NEXT_HMR_REFRESH_HEADER.toLowerCase()] !== undefined\n\n  // dev warmup requests are treated as prefetch RSC requests\n  const isRSCRequest =\n    isDevWarmupRequest || headers[RSC_HEADER.toLowerCase()] !== undefined\n\n  const shouldProvideFlightRouterState =\n    isRSCRequest && (!isPrefetchRequest || !options.isRoutePPREnabled)\n\n  const flightRouterState = shouldProvideFlightRouterState\n    ? parseAndValidateFlightRouterState(\n        headers[NEXT_ROUTER_STATE_TREE_HEADER.toLowerCase()]\n      )\n    : undefined\n\n  const csp =\n    headers['content-security-policy'] ||\n    headers['content-security-policy-report-only']\n\n  const nonce =\n    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n\n  return {\n    flightRouterState,\n    isPrefetchRequest,\n    isHmrRefresh,\n    isRSCRequest,\n    isDevWarmupRequest,\n    nonce,\n  }\n}\n\nfunction createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n  // Align the segment with parallel-route-default in next-app-loader\n  const components = loaderTree[2]\n  return [\n    '',\n    {\n      children: [\n        PAGE_SEGMENT_KEY,\n        {},\n        {\n          page: components['not-found'],\n        },\n      ],\n    },\n    components,\n  ]\n}\n\nexport type CreateSegmentPath = (child: FlightSegmentPath) => FlightSegmentPath\n\n/**\n * Returns a function that parses the dynamic segment and return the associated value.\n */\nfunction makeGetDynamicParamFromSegment(\n  params: { [key: string]: any },\n  pagePath: string,\n  fallbackRouteParams: FallbackRouteParams | null\n): GetDynamicParamFromSegment {\n  return function getDynamicParamFromSegment(\n    // [slug] / [[slug]] / [...slug]\n    segment: string\n  ) {\n    const segmentParam = getSegmentParam(segment)\n    if (!segmentParam) {\n      return null\n    }\n\n    const key = segmentParam.param\n\n    let value = params[key]\n\n    if (fallbackRouteParams && fallbackRouteParams.has(segmentParam.param)) {\n      value = fallbackRouteParams.get(segmentParam.param)\n    } else if (Array.isArray(value)) {\n      value = value.map((i) => encodeURIComponent(i))\n    } else if (typeof value === 'string') {\n      value = encodeURIComponent(value)\n    }\n\n    if (!value) {\n      const isCatchall = segmentParam.type === 'catchall'\n      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n\n      if (isCatchall || isOptionalCatchall) {\n        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n        // handle the case where an optional catchall does not have a value,\n        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n        if (isOptionalCatchall) {\n          return {\n            param: key,\n            value: null,\n            type: dynamicParamType,\n            treeSegment: [key, '', dynamicParamType],\n          }\n        }\n\n        // handle the case where a catchall or optional catchall does not have a value,\n        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n        value = pagePath\n          .split('/')\n          // remove the first empty string\n          .slice(1)\n          // replace any dynamic params with the actual values\n          .flatMap((pathSegment) => {\n            const param = parseParameter(pathSegment)\n            // if the segment matches a param, return the param value\n            // otherwise, it's a static segment, so just return that\n            return params[param.key] ?? param.key\n          })\n\n        return {\n          param: key,\n          value,\n          type: dynamicParamType,\n          // This value always has to be a string.\n          treeSegment: [key, value.join('/'), dynamicParamType],\n        }\n      }\n    }\n\n    const type = getShortDynamicParamType(segmentParam.type)\n\n    return {\n      param: key,\n      // The value that is passed to user code.\n      value: value,\n      // The value that is rendered in the router tree.\n      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n      type: type,\n    }\n  }\n}\n\nfunction NonIndex({ ctx }: { ctx: AppRenderContext }) {\n  const is404Page = ctx.pagePath === '/404'\n  const isInvalidStatusCode =\n    typeof ctx.res.statusCode === 'number' && ctx.res.statusCode > 400\n\n  if (is404Page || isInvalidStatusCode) {\n    return <meta name=\"robots\" content=\"noindex\" />\n  }\n  return null\n}\n\n/**\n * This is used by server actions & client-side navigations to generate RSC data from a client-side request.\n * This function is only called on \"dynamic\" requests (ie, there wasn't already a static response).\n * It uses request headers (namely `Next-Router-State-Tree`) to determine where to start rendering.\n */\nasync function generateDynamicRSCPayload(\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n  }\n): Promise<RSCPayload> {\n  ctx.requestStore.phase = 'render'\n  // Flight data that is going to be passed to the browser.\n  // Currently a single item array but in the future multiple patches might be combined in a single request.\n\n  // We initialize `flightData` to an empty string because the client router knows how to tolerate\n  // it (treating it as an MPA navigation). The only time this function wouldn't generate flight data\n  // is for server actions, if the server action handler instructs this function to skip it. When the server\n  // action reducer sees a falsy value, it'll simply resolve the action with no data.\n  let flightData: FlightData = ''\n\n  const {\n    componentMod: {\n      tree: loaderTree,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    requestStore: { url },\n    query,\n    requestId,\n    flightRouterState,\n    workStore,\n  } = ctx\n\n  if (!options?.skipFlight) {\n    const preloadCallbacks: PreloadCallbacks = []\n\n    const searchParams = createServerSearchParamsForMetadata(query, workStore)\n    const [MetadataTree, getMetadataReady] = createMetadataComponents({\n      tree: loaderTree,\n      searchParams,\n      metadataContext: createTrackedMetadataContext(\n        url.pathname,\n        ctx.renderOpts,\n        workStore\n      ),\n      getDynamicParamFromSegment,\n      appUsingSizeAdjustment,\n      createServerParamsForMetadata,\n      workStore,\n      MetadataBoundary,\n      ViewportBoundary,\n    })\n    flightData = (\n      await walkTreeWithFlightRouterState({\n        ctx,\n        createSegmentPath: (child) => child,\n        loaderTreeToFilter: loaderTree,\n        parentParams: {},\n        flightRouterState,\n        isFirst: true,\n        // For flight, render metadata inside leaf page\n        rscPayloadHead: (\n          <React.Fragment key={flightDataPathHeadKey}>\n            <NonIndex ctx={ctx} />\n            {/* Adding requestId as react key to make metadata remount for each render */}\n            <MetadataTree key={requestId} />\n          </React.Fragment>\n        ),\n        injectedCSS: new Set(),\n        injectedJS: new Set(),\n        injectedFontPreloadTags: new Set(),\n        rootLayoutIncluded: false,\n        getMetadataReady,\n        preloadCallbacks,\n      })\n    ).map((path) => path.slice(1)) // remove the '' (root) segment\n  }\n\n  // If we have an action result, then this is a server action response.\n  // We can rely on this because `ActionResult` will always be a promise, even if\n  // the result is falsey.\n  if (options?.actionResult) {\n    return {\n      a: options.actionResult,\n      f: flightData,\n      b: ctx.renderOpts.buildId,\n    }\n  }\n\n  // Otherwise, it's a regular RSC response.\n  return {\n    b: ctx.renderOpts.buildId,\n    f: flightData,\n    S: workStore.isStaticGeneration,\n  }\n}\n\nfunction createErrorContext(\n  ctx: AppRenderContext,\n  renderSource: RequestErrorContext['renderSource']\n): RequestErrorContext {\n  return {\n    routerKind: 'App Router',\n    routePath: ctx.pagePath,\n    routeType: ctx.isAction ? 'action' : 'render',\n    renderSource,\n    revalidateReason: getRevalidateReason(ctx.workStore),\n  }\n}\n/**\n * Produces a RenderResult containing the Flight data for the given request. See\n * `generateDynamicRSCPayload` for information on the contents of the render result.\n */\nasync function generateDynamicFlightRenderResult(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n    temporaryReferences?: WeakMap<any, string>\n  }\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    !!renderOpts.dev,\n    onFlightDataRenderError\n  )\n\n  const RSCPayload: RSCPayload & {\n    /** Only available during dynamicIO development builds. Used for logging errors. */\n    _validation?: Promise<React.ReactNode>\n  } = await generateDynamicRSCPayload(ctx, options)\n\n  if (\n    // We only want this behavior when running `next dev`\n    renderOpts.dev &&\n    // We only want this behavior when we have React's dev builds available\n    process.env.NODE_ENV === 'development' &&\n    // We only have a Prerender environment for projects opted into dynamicIO\n    renderOpts.experimental.dynamicIO\n  ) {\n    const [resolveValidation, validationOutlet] = createValidationOutlet()\n    RSCPayload._validation = validationOutlet\n\n    spawnDynamicValidationInDev(\n      resolveValidation,\n      ctx.componentMod.tree,\n      ctx,\n      false,\n      ctx.clientReferenceManifest,\n      ctx.workStore.route\n    )\n  }\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = ctx.componentMod.renderToReadableStream(\n    RSCPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n      temporaryReferences: options?.temporaryReferences,\n    }\n  )\n\n  return new FlightRenderResult(flightReadableStream, {\n    fetchMetrics: ctx.workStore.fetchMetrics,\n  })\n}\n\n/**\n * Performs a \"warmup\" render of the RSC payload for a given route. This function is called by the server\n * prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render\n * can accurately log activity in the right render context (Prerender vs Render).\n *\n * At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult\n */\nasync function warmupDevRender(\n  req: BaseNextRequest,\n  ctx: AppRenderContext,\n  options?: {\n    actionResult: ActionResult\n    skipFlight: boolean\n    componentTree?: CacheNodeSeedData\n    preloadCallbacks?: PreloadCallbacks\n  }\n): Promise<RenderResult> {\n  const renderOpts = ctx.renderOpts\n  if (!renderOpts.dev) {\n    throw new InvariantError(\n      'generateDynamicFlightRenderResult should never be called in `next start` mode.'\n    )\n  }\n\n  function onFlightDataRenderError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components-payload')\n    )\n  }\n  const onError = createFlightReactServerErrorHandler(\n    true,\n    onFlightDataRenderError\n  )\n\n  const rscPayload = await generateDynamicRSCPayload(ctx, options)\n\n  // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)\n  // which contains the subset React.\n  const flightReadableStream = ctx.componentMod.renderToReadableStream(\n    rscPayload,\n    ctx.clientReferenceManifest.clientModules,\n    {\n      onError,\n    }\n  )\n\n  const reader = flightReadableStream.getReader()\n  while (true) {\n    if ((await reader.read()).done) {\n      break\n    }\n  }\n\n  // We don't really want to return a result here but the stack of functions\n  // that calls into renderToHTML... expects a result. We should refactor this to\n  // lift the warmup pathway outside of renderToHTML... but for now this suffices\n  return new FlightRenderResult('', {\n    fetchMetrics: ctx.workStore.fetchMetrics,\n  })\n}\n\n/**\n * Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled\n * when our intention is to just seed the router state with the current URL.\n * This function splits up the pathname so that we can later join it on\n * when we're ready to consume the path.\n */\nfunction prepareInitialCanonicalUrl(url: RequestStore['url']) {\n  return (url.pathname + url.search).split('/')\n}\n\n// This is the data necessary to render <AppRouter /> when no SSR errors are encountered\nasync function getRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  is404: boolean\n): Promise<InitialRSCPayload & { P: React.ReactNode }> {\n  const injectedCSS = new Set<string>()\n  const injectedJS = new Set<string>()\n  const injectedFontPreloadTags = new Set<string>()\n  let missingSlots: Set<string> | undefined\n\n  // We only track missing parallel slots in development\n  if (process.env.NODE_ENV === 'development') {\n    missingSlots = new Set<string>()\n  }\n\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    requestStore: { url },\n    workStore,\n  } = ctx\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  const searchParams = createServerSearchParamsForMetadata(query, workStore)\n  const [MetadataTree, getMetadataReady] = createMetadataComponents({\n    tree,\n    errorType: is404 ? 'not-found' : undefined,\n    searchParams,\n    metadataContext: createTrackedMetadataContext(\n      url.pathname,\n      ctx.renderOpts,\n      workStore\n    ),\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createServerParamsForMetadata,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n  })\n\n  const preloadCallbacks: PreloadCallbacks = []\n\n  const seedData = await createComponentTree({\n    ctx,\n    createSegmentPath: (child) => child,\n    loaderTree: tree,\n    parentParams: {},\n    firstItem: true,\n    injectedCSS,\n    injectedJS,\n    injectedFontPreloadTags,\n    rootLayoutIncluded: false,\n    getMetadataReady,\n    missingSlots,\n    preloadCallbacks,\n  })\n\n  // When the `vary` response header is present with `Next-URL`, that means there's a chance\n  // it could respond differently if there's an interception route. We provide this information\n  // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.\n  const varyHeader = ctx.res.getHeader('vary')\n  const couldBeIntercepted =\n    typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex ctx={ctx} />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <MetadataTree key={ctx.requestId} />\n    </React.Fragment>\n  )\n\n  return {\n    // See the comment above the `Preloads` component (below) for why this is part of the payload\n    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n    b: ctx.renderOpts.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    i: !!couldBeIntercepted,\n    f: [[initialTree, seedData, initialHead]],\n    m: missingSlots,\n    G: GlobalError,\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  }\n}\n\n/**\n * Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering\n * in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke\n * renderToReadableStream with a function that returns component props rather than a component itself, we use\n * this component to \"render  \" the preload calls.\n */\nfunction Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {\n  preloadCallbacks.forEach((preloadFn) => preloadFn())\n  return null\n}\n\n// This is the data necessary to render <AppRouter /> when an error state is triggered\nasync function getErrorRSCPayload(\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  errorType: 'not-found' | 'redirect' | undefined\n) {\n  const {\n    getDynamicParamFromSegment,\n    query,\n    appUsingSizeAdjustment,\n    componentMod: {\n      GlobalError,\n      createServerSearchParamsForMetadata,\n      createServerParamsForMetadata,\n      createMetadataComponents,\n      MetadataBoundary,\n      ViewportBoundary,\n    },\n    requestStore: { url },\n    requestId,\n    workStore,\n  } = ctx\n\n  const searchParams = createServerSearchParamsForMetadata(query, workStore)\n  const [MetadataTree] = createMetadataComponents({\n    tree,\n    searchParams,\n    // We create an untracked metadata context here because we can't postpone\n    // again during the error render.\n    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n    errorType,\n    getDynamicParamFromSegment,\n    appUsingSizeAdjustment,\n    createServerParamsForMetadata,\n    workStore,\n    MetadataBoundary,\n    ViewportBoundary,\n  })\n\n  const initialHead = (\n    <React.Fragment key={flightDataPathHeadKey}>\n      <NonIndex ctx={ctx} />\n      {/* Adding requestId as react key to make metadata remount for each render */}\n      <MetadataTree key={requestId} />\n      {process.env.NODE_ENV === 'development' && (\n        <meta name=\"next-error\" content=\"not-found\" />\n      )}\n    </React.Fragment>\n  )\n\n  const initialTree = createFlightRouterStateFromLoaderTree(\n    tree,\n    getDynamicParamFromSegment,\n    query\n  )\n\n  // For metadata notFound error there's no global not found boundary on top\n  // so we create a not found page with AppRouter\n  const initialSeedData: CacheNodeSeedData = [\n    initialTree[0],\n    <html id=\"__next_error__\">\n      <head></head>\n      <body></body>\n    </html>,\n    {},\n    null,\n  ]\n\n  return {\n    b: ctx.renderOpts.buildId,\n    p: ctx.assetPrefix,\n    c: prepareInitialCanonicalUrl(url),\n    m: undefined,\n    i: false,\n    f: [[initialTree, initialSeedData, initialHead]],\n    G: GlobalError,\n    s: typeof ctx.renderOpts.postponed === 'string',\n    S: workStore.isStaticGeneration,\n  } satisfies InitialRSCPayload\n}\n\n// This component must run in an SSR context. It will render the RSC root component\nfunction App<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n  ServerInsertedHTMLProvider,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    buildId: response.b,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    // location and initialParallelRoutes are not initialized in the SSR render\n    // they are set to an empty map and window.location, respectively during hydration\n    initialParallelRoutes: null!,\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  const { HeadManagerContext } =\n    require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')\n\n  return (\n    <HeadManagerContext.Provider\n      value={{\n        appDir: true,\n        nonce,\n      }}\n    >\n      <ServerInsertedHTMLProvider>\n        <AppRouter\n          actionQueue={actionQueue}\n          globalErrorComponent={response.G}\n          assetPrefix={response.p}\n        />\n      </ServerInsertedHTMLProvider>\n    </HeadManagerContext.Provider>\n  )\n}\n\n// @TODO our error stream should be probably just use the same root component. But it was previously\n// different I don't want to figure out if that is meaningful at this time so just keeping the behavior\n// consistent for now.\nfunction AppWithoutContext<T>({\n  reactServerStream,\n  preinitScripts,\n  clientReferenceManifest,\n  nonce,\n}: {\n  reactServerStream: BinaryStreamOf<T>\n  preinitScripts: () => void\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n  nonce?: string\n}): JSX.Element {\n  preinitScripts()\n  const response = React.use(\n    useFlightStream<InitialRSCPayload>(\n      reactServerStream,\n      clientReferenceManifest,\n      nonce\n    )\n  )\n\n  const initialState = createInitialRouterState({\n    buildId: response.b,\n    initialFlightData: response.f,\n    initialCanonicalUrlParts: response.c,\n    // location and initialParallelRoutes are not initialized in the SSR render\n    // they are set to an empty map and window.location, respectively during hydration\n    initialParallelRoutes: null!,\n    location: null,\n    couldBeIntercepted: response.i,\n    postponed: response.s,\n    prerendered: response.S,\n  })\n\n  const actionQueue = createMutableActionQueue(initialState)\n\n  return (\n    <AppRouter\n      actionQueue={actionQueue}\n      globalErrorComponent={response.G}\n      assetPrefix={response.p}\n    />\n  )\n}\n\n// We use a trick with TS Generics to branch streams with a type so we can\n// consume the parsed value of a Readable Stream if it was constructed with a\n// certain object shape. The generic type is not used directly in the type so it\n// requires a disabling of the eslint rule disallowing unused vars\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type BinaryStreamOf<T> = ReadableStream<Uint8Array>\n\nasync function renderToHTMLOrFlightImpl(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  renderOpts: RenderOpts,\n  requestStore: RequestStore,\n  workStore: WorkStore,\n  parsedRequestHeaders: ParsedRequestHeaders,\n  requestEndedState: { ended?: boolean },\n  postponedState: PostponedState | null\n) {\n  const isNotFoundPath = pagePath === '/404'\n  if (isNotFoundPath) {\n    res.statusCode = 404\n  }\n\n  // A unique request timestamp used by development to ensure that it's\n  // consistent and won't change during this request. This is important to\n  // avoid that resources can be deduped by React Float if the same resource is\n  // rendered or preloaded multiple times: `<link href=\"a.css?v={Date.now()}\"/>`.\n  const requestTimestamp = Date.now()\n\n  const {\n    serverActionsManifest,\n    ComponentMod,\n    nextFontManifest,\n    serverActions,\n    assetPrefix = '',\n    enableTainting,\n  } = renderOpts\n\n  // We need to expose the bundled `require` API globally for\n  // react-server-dom-webpack. This is a hack until we find a better way.\n  if (ComponentMod.__next_app__) {\n    const instrumented = wrapClientComponentLoader(ComponentMod)\n    // @ts-ignore\n    globalThis.__next_require__ = instrumented.require\n    // When we are prerendering if there is a cacheSignal for tracking\n    // cache reads we wrap the loadChunk in this tracking. This allows us\n    // to treat chunk loading with similar semantics as cache reads to avoid\n    // async loading chunks from causing a prerender to abort too early.\n    // @ts-ignore\n    globalThis.__next_chunk_load__ = (...args: Array<any>) => {\n      const loadingChunk = instrumented.loadChunk(...args)\n      trackChunkLoading(loadingChunk)\n      return loadingChunk\n    }\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // reset isr status at start of request\n    const { pathname } = new URL(req.url || '/', 'http://n')\n    renderOpts.setAppIsrStatus?.(pathname, null)\n  }\n\n  if (\n    // The type check here ensures that `req` is correctly typed, and the\n    // environment variable check provides dead code elimination.\n    process.env.NEXT_RUNTIME !== 'edge' &&\n    isNodeNextRequest(req)\n  ) {\n    req.originalRequest.on('end', () => {\n      const prerenderStore = workUnitAsyncStorage.getStore()\n      const isPPR =\n        prerenderStore &&\n        (prerenderStore.type === 'prerender' ||\n          prerenderStore.type === 'prerender-ppr')\n          ? !!prerenderStore.dynamicTracking?.dynamicAccesses?.length\n          : false\n\n      if (\n        process.env.NODE_ENV === 'development' &&\n        renderOpts.setAppIsrStatus &&\n        !isPPR &&\n        !requestStore.usedDynamic &&\n        !workStore.forceDynamic\n      ) {\n        // only node can be ISR so we only need to update the status here\n        const { pathname } = new URL(req.url || '/', 'http://n')\n        renderOpts.setAppIsrStatus(pathname, true)\n      }\n\n      requestEndedState.ended = true\n\n      if ('performance' in globalThis) {\n        const metrics = getClientComponentLoaderMetrics({ reset: true })\n        if (metrics) {\n          getTracer()\n            .startSpan(NextNodeServerSpan.clientComponentLoading, {\n              startTime: metrics.clientComponentLoadStart,\n              attributes: {\n                'next.clientComponentLoadCount':\n                  metrics.clientComponentLoadCount,\n                'next.span_type': NextNodeServerSpan.clientComponentLoading,\n              },\n            })\n            .end(\n              metrics.clientComponentLoadStart +\n                metrics.clientComponentLoadTimes\n            )\n        }\n      }\n    })\n  }\n\n  const metadata: AppPageRenderResultMetadata = {}\n\n  const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust\n\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const serverModuleMap = createServerModuleMap({\n    serverActionsManifest,\n    pageName: renderOpts.page,\n  })\n\n  setReferenceManifestsSingleton({\n    clientReferenceManifest,\n    serverActionsManifest,\n    serverModuleMap,\n  })\n\n  ComponentMod.patchFetch()\n\n  // Pull out the hooks/references from the component.\n  const { tree: loaderTree, taintObjectReference } = ComponentMod\n\n  if (enableTainting) {\n    taintObjectReference(\n      'Do not pass process.env to client components since it will leak sensitive data',\n      process.env\n    )\n  }\n\n  workStore.fetchMetrics = []\n  metadata.fetchMetrics = workStore.fetchMetrics\n\n  // don't modify original query object\n  query = { ...query }\n  stripInternalQueries(query)\n\n  const {\n    flightRouterState,\n    isPrefetchRequest,\n    isRSCRequest,\n    isDevWarmupRequest,\n    nonce,\n  } = parsedRequestHeaders\n\n  /**\n   * The metadata items array created in next-app-loader with all relevant information\n   * that we need to resolve the final metadata.\n   */\n  let requestId: string\n\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    requestId = crypto.randomUUID()\n  } else {\n    requestId = require('next/dist/compiled/nanoid').nanoid()\n  }\n\n  /**\n   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {\"slug\": \"vercel\"}.\n   */\n  const params = renderOpts.params ?? {}\n\n  const { isStaticGeneration, fallbackRouteParams } = workStore\n\n  const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(\n    params,\n    pagePath,\n    fallbackRouteParams\n  )\n\n  const isActionRequest = getServerActionRequestMetadata(req).isServerAction\n\n  const ctx: AppRenderContext = {\n    componentMod: ComponentMod,\n    renderOpts,\n    requestStore,\n    workStore,\n    parsedRequestHeaders,\n    getDynamicParamFromSegment,\n    query,\n    isPrefetch: isPrefetchRequest,\n    isAction: isActionRequest,\n    requestTimestamp,\n    appUsingSizeAdjustment,\n    flightRouterState,\n    requestId,\n    pagePath,\n    clientReferenceManifest,\n    assetPrefix,\n    isNotFoundPath,\n    nonce,\n    res,\n  }\n\n  getTracer().setRootSpanAttribute('next.route', pagePath)\n\n  if (isStaticGeneration) {\n    // We're either building or revalidating. In either case we need to\n    // prerender our page rather than render it.\n    const prerenderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `prerender route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      prerenderToStream\n    )\n\n    let response = await prerenderToStreamWithTracing(\n      req,\n      res,\n      ctx,\n      metadata,\n      workStore,\n      loaderTree\n    )\n\n    // If we're debugging partial prerendering, print all the dynamic API accesses\n    // that occurred during the render.\n    // @TODO move into renderToStream function\n    if (\n      response.dynamicAccess &&\n      accessedDynamicData(response.dynamicAccess) &&\n      renderOpts.isDebugDynamicAccesses\n    ) {\n      warn('The following dynamic usage was detected:')\n      for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {\n        warn(access)\n      }\n    }\n\n    // If we encountered any unexpected errors during build we fail the\n    // prerendering phase and the build.\n    if (response.digestErrorsMap.size) {\n      const buildFailingError = response.digestErrorsMap.values().next().value\n      if (buildFailingError) throw buildFailingError\n    }\n    // Pick first userland SSR error, which is also not a RSC error.\n    if (response.ssrErrors.length) {\n      const buildFailingError = response.ssrErrors.find((err) =>\n        isUserLandError(err)\n      )\n      if (buildFailingError) throw buildFailingError\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.revalidatedTags\n    ) {\n      options.waitUntil = Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ])\n    }\n\n    if (response.collectedTags) {\n      metadata.fetchTags = response.collectedTags.join(',')\n    }\n\n    // Let the client router know how long to keep the cached entry around.\n    const staleHeader = String(response.collectedStale)\n    res.setHeader(NEXT_ROUTER_STALE_TIME_HEADER, staleHeader)\n    metadata.headers ??= {}\n    metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader\n\n    // If force static is specifically set to false, we should not revalidate\n    // the page.\n    if (workStore.forceStatic === false || response.collectedRevalidate === 0) {\n      metadata.revalidate = 0\n    } else {\n      // Copy the revalidation value onto the render result metadata.\n      metadata.revalidate =\n        response.collectedRevalidate >= INFINITE_CACHE\n          ? false\n          : response.collectedRevalidate\n    }\n\n    // provide bailout info for debugging\n    if (metadata.revalidate === 0) {\n      metadata.staticBailoutInfo = {\n        description: workStore.dynamicUsageDescription,\n        stack: workStore.dynamicUsageStack,\n      }\n    }\n\n    // Per-segment prefetch data\n    //\n    // All of the segments for a page are generated simultaneously, including\n    // during revalidations. This is to ensure consistency, because it's\n    // possible for a mismatch between a layout and page segment can cause the\n    // client to error during rendering. We want to preserve the ability of the\n    // client to recover from such a mismatch by re-requesting all the segments\n    // to get a consistent view of the page.\n    //\n    // TODO (Per Segment Prefetching): This is placeholder data. Populate with\n    // the actual data generated during prerender.\n    if (renderOpts.experimental.isRoutePPREnabled === true) {\n      const placeholder = Buffer.from(\n        'TODO (Per Segment Prefetching): Not yet implemented\\n'\n      )\n      metadata.segmentFlightData = new Map([\n        // Root segment\n        ['/', placeholder],\n        ['/blog', placeholder],\n        // TODO: Update the client to use the same encoding for segment paths that\n        // we use here, so we don't have to convert between them. Needs to be\n        // filesystem safe.\n        ['/blog/[post]-1-d', placeholder],\n      ])\n    }\n\n    return new RenderResult(await streamToString(response.stream), options)\n  } else {\n    // We're rendering dynamically\n    if (isDevWarmupRequest) {\n      return warmupDevRender(req, ctx)\n    } else if (isRSCRequest) {\n      return generateDynamicFlightRenderResult(req, ctx)\n    }\n\n    const renderToStreamWithTracing = getTracer().wrap(\n      AppRenderSpan.getBodyResult,\n      {\n        spanName: `render route (app) ${pagePath}`,\n        attributes: {\n          'next.route': pagePath,\n        },\n      },\n      renderToStream\n    )\n\n    let formState: null | any = null\n    if (isActionRequest) {\n      // For action requests, we handle them differently with a special render result.\n      const actionRequestResult = await handleAction({\n        req,\n        res,\n        ComponentMod,\n        serverModuleMap,\n        generateFlight: generateDynamicFlightRenderResult,\n        workStore,\n        requestStore,\n        serverActions,\n        ctx,\n      })\n\n      if (actionRequestResult) {\n        if (actionRequestResult.type === 'not-found') {\n          const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n          res.statusCode = 404\n          const stream = await renderToStreamWithTracing(\n            requestStore,\n            req,\n            res,\n            ctx,\n            workStore,\n            notFoundLoaderTree,\n            formState,\n            postponedState\n          )\n\n          return new RenderResult(stream, { metadata })\n        } else if (actionRequestResult.type === 'done') {\n          if (actionRequestResult.result) {\n            actionRequestResult.result.assignMetadata(metadata)\n            return actionRequestResult.result\n          } else if (actionRequestResult.formState) {\n            formState = actionRequestResult.formState\n          }\n        }\n      }\n    }\n\n    const options: RenderResultOptions = {\n      metadata,\n    }\n\n    const stream = await renderToStreamWithTracing(\n      requestStore,\n      req,\n      res,\n      ctx,\n      workStore,\n      loaderTree,\n      formState,\n      postponedState\n    )\n\n    // If we have pending revalidates, wait until they are all resolved.\n    if (\n      workStore.pendingRevalidates ||\n      workStore.pendingRevalidateWrites ||\n      workStore.revalidatedTags\n    ) {\n      options.waitUntil = Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ])\n    }\n\n    // Create the new render result for the response.\n    return new RenderResult(stream, options)\n  }\n}\n\nexport type AppPageRender = (\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  pagePath: string,\n  query: NextParsedUrlQuery,\n  fallbackRouteParams: FallbackRouteParams | null,\n  renderOpts: RenderOpts,\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n) => Promise<RenderResult<AppPageRenderResultMetadata>>\n\nexport const renderToHTMLOrFlight: AppPageRender = (\n  req,\n  res,\n  pagePath,\n  query,\n  fallbackRouteParams,\n  renderOpts,\n  serverComponentsHmrCache\n) => {\n  if (!req.url) {\n    throw new Error('Invalid URL')\n  }\n\n  const url = parseRelativeUrl(req.url, undefined, false)\n\n  // We read these values from the request object as, in certain cases,\n  // base-server will strip them to opt into different rendering behavior.\n  const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n    isDevWarmup: renderOpts.isDevWarmup,\n    isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n  })\n\n  const { isHmrRefresh, isPrefetchRequest } = parsedRequestHeaders\n\n  const requestEndedState = { ended: false }\n  let postponedState: PostponedState | null = null\n\n  // If provided, the postpone state should be parsed so it can be provided to\n  // React.\n  if (typeof renderOpts.postponed === 'string') {\n    if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n      throw new Error(\n        'Invariant: postponed state should not be provided when fallback params are provided'\n      )\n    }\n\n    postponedState = parsePostponedState(\n      renderOpts.postponed,\n      renderOpts.params\n    )\n  }\n\n  const implicitTags = getImplicitTags(\n    renderOpts.routeModule.definition.page,\n    url,\n    fallbackRouteParams\n  )\n  // TODO: We need to refactor this so that prerenders do not rely upon the\n  // existence of an outer scoped request store. Then we should move this\n  // store generation inside the appropriate scope like `renderToStream` where\n  // we know we're handling a Request and not a Prerender\n  const requestStore = createRequestStoreForRender(\n    req,\n    res,\n    url,\n    implicitTags,\n    renderOpts.onUpdateCookies,\n    renderOpts.previewProps,\n    isHmrRefresh,\n    serverComponentsHmrCache\n  )\n  return workUnitAsyncStorage.run(requestStore, () => {\n    return withWorkStore(\n      renderOpts.ComponentMod.workAsyncStorage,\n      {\n        page: renderOpts.routeModule.definition.page,\n        fallbackRouteParams,\n        renderOpts,\n        requestEndedState,\n        // @TODO move to workUnitStore of type Request\n        isPrefetchRequest,\n      },\n      (workStore) =>\n        renderToHTMLOrFlightImpl(\n          req,\n          res,\n          pagePath,\n          query,\n          renderOpts,\n          requestStore,\n          workStore,\n          parsedRequestHeaders,\n          requestEndedState,\n          postponedState\n        )\n    )\n  })\n}\n\nasync function renderToStream(\n  requestStore: RequestStore,\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  workStore: WorkStore,\n  tree: LoaderTree,\n  formState: any,\n  postponedState: PostponedState | null\n): Promise<ReadableStream<Uint8Array>> {\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  const silenceLogger = false\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerResult: null | ReactServerResult = null\n\n  const setHeader = res.setHeader.bind(res)\n\n  try {\n    if (\n      // We only want this behavior when running `next dev`\n      renderOpts.dev &&\n      // We only want this behavior when we have React's dev builds available\n      process.env.NODE_ENV === 'development' &&\n      // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      // We only have a Prerender environment for projects opted into dynamicIO\n      renderOpts.experimental.dynamicIO\n    ) {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload: InitialRSCPayload & {\n        /** Only available during dynamicIO development builds. Used for logging errors. */\n        _validation?: Promise<React.ReactNode>\n      } = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const [resolveValidation, validationOutlet] = createValidationOutlet()\n      RSCPayload._validation = validationOutlet\n\n      const reactServerStream = await workUnitAsyncStorage.run(\n        requestStore,\n        scheduleInSequentialTasks,\n        () => {\n          requestStore.prerenderPhase = true\n          return ComponentMod.renderToReadableStream(\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n              environmentName: () =>\n                requestStore.prerenderPhase === true ? 'Prerender' : 'Server',\n            }\n          )\n        },\n        () => {\n          requestStore.prerenderPhase = false\n        }\n      )\n\n      spawnDynamicValidationInDev(\n        resolveValidation,\n        tree,\n        ctx,\n        res.statusCode === 404,\n        clientReferenceManifest,\n        workStore.route\n      )\n\n      reactServerResult = new ReactServerResult(reactServerStream)\n    } else {\n      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n      const RSCPayload = await workUnitAsyncStorage.run(\n        requestStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n\n      reactServerResult = new ReactServerResult(\n        workUnitAsyncStorage.run(\n          requestStore,\n          ComponentMod.renderToReadableStream,\n          RSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            onError: serverComponentsErrorHandler,\n          }\n        )\n      )\n    }\n\n    // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n    // before we begin SSR rendering because we want to capture any available preload headers so we tick\n    // one task before continuing\n    await waitAtLeastOneReactRenderTask()\n\n    // If provided, the postpone state should be parsed as JSON so it can be\n    // provided to React.\n    if (typeof renderOpts.postponed === 'string') {\n      if (postponedState?.type === DynamicState.DATA) {\n        // We have a complete HTML Document in the prerender but we need to\n        // still include the new server component render because it was not included\n        // in the static prelude.\n        const inlinedReactServerDataStream = createInlinedDataReadableStream(\n          reactServerResult.tee(),\n          ctx.nonce,\n          formState\n        )\n\n        return chainStreams(\n          inlinedReactServerDataStream,\n          createDocumentClosingStream()\n        )\n      } else if (postponedState) {\n        // We assume we have dynamic HTML requiring a resume render to complete\n        const postponed = getPostponedFromState(postponedState)\n\n        const resume = require('react-dom/server.edge')\n          .resume as (typeof import('react-dom/server.edge'))['resume']\n\n        const htmlStream = await workUnitAsyncStorage.run(\n          requestStore,\n          resume,\n          <App\n            reactServerStream={reactServerResult.tee()}\n            preinitScripts={preinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n            nonce={ctx.nonce}\n          />,\n          postponed,\n          {\n            onError: htmlRendererErrorHandler,\n            nonce: ctx.nonce,\n          }\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        return await continueDynamicHTMLResume(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consume(),\n            ctx.nonce,\n            formState\n          ),\n          getServerInsertedHTML,\n        })\n      }\n    }\n\n    // This is a regular dynamic render\n    const renderToReadableStream = require('react-dom/server.edge')\n      .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n    const htmlStream = await workUnitAsyncStorage.run(\n      requestStore,\n      renderToReadableStream,\n      <App\n        reactServerStream={reactServerResult.tee()}\n        preinitScripts={preinitScripts}\n        clientReferenceManifest={clientReferenceManifest}\n        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n        nonce={ctx.nonce}\n      />,\n      {\n        onError: htmlRendererErrorHandler,\n        nonce: ctx.nonce,\n        onHeaders: (headers: Headers) => {\n          headers.forEach((value, key) => {\n            setHeader(key, value)\n          })\n        },\n        maxHeadersLength: renderOpts.reactMaxHeadersLength,\n        // When debugging the static shell, client-side rendering should be\n        // disabled to prevent blanking out the page.\n        bootstrapScripts: renderOpts.isDebugStaticShell\n          ? []\n          : [bootstrapScript],\n        formState,\n      }\n    )\n\n    const getServerInsertedHTML = makeGetServerInsertedHTML({\n      polyfills,\n      renderServerInsertedHTML,\n      serverCapturedErrors: allCapturedErrors,\n      basePath: renderOpts.basePath,\n      tracingMetadata: tracingMetadata,\n    })\n    /**\n     * Rules of Static & Dynamic HTML:\n     *\n     *    1.) We must generate static HTML unless the caller explicitly opts\n     *        in to dynamic HTML support.\n     *\n     *    2.) If dynamic HTML support is requested, we must honor that request\n     *        or throw an error. It is the sole responsibility of the caller to\n     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n     *\n     * These rules help ensure that other existing features like request caching,\n     * coalescing, and ISR continue working as intended.\n     */\n    const generateStaticHTML = renderOpts.supportsDynamicResponse !== true\n    const validateRootLayout = renderOpts.dev\n    return await continueFizzStream(htmlStream, {\n      inlinedDataStream: createInlinedDataReadableStream(\n        reactServerResult.consume(),\n        ctx.nonce,\n        formState\n      ),\n      isStaticGeneration: generateStaticHTML,\n      getServerInsertedHTML,\n      serverInsertedHTMLToHead: true,\n      validateRootLayout,\n    })\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    let errorType: 'not-found' | 'redirect' | undefined\n\n    if (isNotFoundError(err)) {\n      errorType = 'not-found'\n      res.statusCode = 404\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      // If there were mutable cookies set, we need to set them on the\n      // response.\n      const headers = new Headers()\n      if (appendMutableCookies(headers, ctx.requestStore.mutableCookies)) {\n        setHeader('set-cookie', Array.from(headers.values()))\n      }\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      requestStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      requestStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    if (reactServerResult === null) {\n      // We errored when we did not have an RSC stream to read from. This is not just a render\n      // error, we need to throw early\n      throw err\n    }\n\n    try {\n      const fizzStream = await workUnitAsyncStorage.run(\n        requestStore,\n        renderToInitialFizzStream,\n        {\n          ReactDOMServer: require('react-dom/server.edge'),\n          element: (\n            <AppWithoutContext\n              reactServerStream={errorServerStream}\n              preinitScripts={errorPreinitScripts}\n              clientReferenceManifest={clientReferenceManifest}\n              nonce={ctx.nonce}\n            />\n          ),\n          streamOptions: {\n            nonce: ctx.nonce,\n            // Include hydration scripts in the HTML\n            bootstrapScripts: [errorBootstrapScript],\n            formState,\n          },\n        }\n      )\n\n      /**\n       * Rules of Static & Dynamic HTML:\n       *\n       *    1.) We must generate static HTML unless the caller explicitly opts\n       *        in to dynamic HTML support.\n       *\n       *    2.) If dynamic HTML support is requested, we must honor that request\n       *        or throw an error. It is the sole responsibility of the caller to\n       *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n       *\n       * These rules help ensure that other existing features like request caching,\n       * coalescing, and ISR continue working as intended.\n       */\n      const generateStaticHTML = renderOpts.supportsDynamicResponse !== true\n      const validateRootLayout = renderOpts.dev\n      return await continueFizzStream(fizzStream, {\n        inlinedDataStream: createInlinedDataReadableStream(\n          // This is intentionally using the readable datastream from the\n          // main render rather than the flight data from the error page\n          // render\n          reactServerResult.consume(),\n          ctx.nonce,\n          formState\n        ),\n        isStaticGeneration: generateStaticHTML,\n        getServerInsertedHTML: makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: [],\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        }),\n        serverInsertedHTMLToHead: true,\n        validateRootLayout,\n      })\n    } catch (finalErr: any) {\n      if (process.env.NODE_ENV === 'development' && isNotFoundError(finalErr)) {\n        const bailOnNotFound: typeof import('../../client/components/dev-root-not-found-boundary').bailOnNotFound =\n          require('../../client/components/dev-root-not-found-boundary').bailOnNotFound\n        bailOnNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nfunction createValidationOutlet() {\n  let resolveValidation: (value: React.ReactNode) => void\n  let outlet = new Promise<React.ReactNode>((resolve) => {\n    resolveValidation = resolve\n  })\n  return [resolveValidation!, outlet] as const\n}\n\nasync function spawnDynamicValidationInDev(\n  resolveValidation: (validatingElement: React.ReactNode) => void,\n  tree: LoaderTree,\n  ctx: AppRenderContext,\n  isNotFound: boolean,\n  clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n  route: string\n): Promise<void> {\n  const { componentMod: ComponentMod } = ctx\n\n  const firstAttemptServerController = new AbortController()\n  let serverDynamicTracking = createDynamicTrackingState(false)\n\n  const firstAttemptServerPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    implicitTags: [],\n    renderSignal: firstAttemptServerController.signal,\n    cacheSignal: null,\n    // During the prospective render we don't want to synchronously abort on dynamic access\n    // because it could prevent us from discovering all caches in siblings. So we omit the controller\n    // from the prerender store this time.\n    controller: firstAttemptServerController,\n    // With PPR during Prerender we don't need to track individual dynamic reasons\n    // because we will always do a final render after caches have filled and we\n    // will track it again there\n    dynamicTracking: serverDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    // Dev only property that allows certain logs to be supressed\n    validating: true,\n  }\n\n  const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n    firstAttemptServerPrerenderStore,\n    getRSCPayload,\n    tree,\n    ctx,\n    isNotFound\n  )\n\n  let reactServerStream = await workUnitAsyncStorage.run(\n    firstAttemptServerPrerenderStore,\n    scheduleInSequentialTasks,\n    () => {\n      const stream = ComponentMod.renderToReadableStream(\n        firstAttemptRSCPayload,\n        clientReferenceManifest.clientModules,\n        {\n          signal: firstAttemptServerController.signal,\n          onError: () => {},\n        }\n      )\n      return asHaltedStream(stream, firstAttemptServerController.signal)\n    },\n    () => {\n      firstAttemptServerController.abort()\n    }\n  )\n\n  if (serverDynamicTracking.syncDynamicErrorWithStack) {\n    // If we had a sync dynamic error then we need to retry without\n    reactServerStream.cancel()\n\n    const secondAttemptServerController = new AbortController()\n    serverDynamicTracking = createDynamicTrackingState(false)\n\n    const secondAttemptServerPrerenderStore: PrerenderStore = {\n      type: 'prerender',\n      phase: 'render',\n      implicitTags: [],\n      renderSignal: secondAttemptServerController.signal,\n      cacheSignal: null,\n      // During the prospective render we don't want to synchronously abort on dynamic access\n      // because it could prevent us from discovering all caches in siblings. So we omit the controller\n      // from the prerender store this time.\n      controller: secondAttemptServerController,\n      // With PPR during Prerender we don't need to track individual dynamic reasons\n      // because we will always do a final render after caches have filled and we\n      // will track it again there\n      dynamicTracking: serverDynamicTracking,\n      revalidate: INFINITE_CACHE,\n      expire: INFINITE_CACHE,\n      stale: INFINITE_CACHE,\n      tags: [],\n      // Dev only property that allows certain logs to be supressed\n      validating: true,\n    }\n\n    const secondAttemptRSCPayload = await workUnitAsyncStorage.run(\n      secondAttemptServerPrerenderStore,\n      getRSCPayload,\n      tree,\n      ctx,\n      isNotFound\n    )\n\n    reactServerStream = await workUnitAsyncStorage.run(\n      secondAttemptServerPrerenderStore,\n      scheduleInSequentialTasks,\n      () => {\n        const stream = ComponentMod.renderToReadableStream(\n          secondAttemptRSCPayload,\n          clientReferenceManifest.clientModules,\n          {\n            signal: secondAttemptServerController.signal,\n            onError: () => {},\n          }\n        )\n        return asHaltedStream(stream, secondAttemptServerController.signal)\n      },\n      () => {\n        secondAttemptServerController.abort()\n      }\n    )\n  }\n\n  const [warmupStream, renderStream] = reactServerStream.tee()\n\n  await warmFlightResponse(warmupStream, clientReferenceManifest)\n\n  const { ServerInsertedHTMLProvider } = createServerInsertedHTML()\n  const nonce = '1'\n\n  const prerender = require('react-dom/static.edge')\n    .prerender as (typeof import('react-dom/static.edge'))['prerender']\n\n  let clientDynamicTracking = createDynamicTrackingState(false)\n  let dynamicValidation = createDynamicValidationState()\n\n  function SSROnError(err: unknown, errorInfo?: ErrorInfo) {\n    if (\n      isPrerenderInterruptedError(err) ||\n      firstAttemptServerController.signal.aborted\n    ) {\n      const componentStack: string | undefined = (errorInfo as any)\n        .componentStack\n      if (typeof componentStack === 'string' && err instanceof Error) {\n        trackAllowedDynamicAccess(\n          route,\n          componentStack,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n      }\n      return undefined\n    }\n    return undefined\n  }\n\n  const firstAttemptClientController = new AbortController()\n  const firstAttemptClientPrerenderStore: PrerenderStore = {\n    type: 'prerender',\n    phase: 'render',\n    implicitTags: [],\n    renderSignal: firstAttemptClientController.signal,\n    // For HTML Generation we don't need to track cache reads (RSC only)\n    cacheSignal: null,\n    // We expect the SSR render to complete in a single Task and need to be able to synchronously abort\n    // When you use APIs that are considered dynamic or synchronous IO.\n    controller: firstAttemptClientController,\n    // We do track dynamic access because searchParams and certain hooks can still be\n    // dynamic during SSR\n    dynamicTracking: clientDynamicTracking,\n    revalidate: INFINITE_CACHE,\n    expire: INFINITE_CACHE,\n    stale: INFINITE_CACHE,\n    tags: [],\n    validating: true,\n  }\n\n  const [firstAttemptReactServerStream, secondAttemptReactServerStream] =\n    renderStream.tee()\n  let hadException = false\n  try {\n    await prerenderAndAbortInSequentialTasks(\n      async () => {\n        workUnitAsyncStorage\n          .run(\n            firstAttemptClientPrerenderStore,\n            prerender,\n            <App\n              reactServerStream={firstAttemptReactServerStream}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={nonce}\n            />,\n            {\n              signal: firstAttemptClientController.signal,\n              onError: SSROnError,\n            }\n          )\n          .catch(() => {})\n        return null\n      },\n      () => {\n        firstAttemptClientController.abort()\n      }\n    ).catch(() => {})\n  } catch (err: unknown) {\n    if (firstAttemptClientController.signal.aborted) {\n      // We aborted the render normally and can ignore this error\n    } else {\n      hadException = true\n      // We're going to retry to so we normally would suppress this error but\n      // when verbose logging is on we print it\n      if (process.env.__NEXT_VERBOSE_LOGGING) {\n        printDebugThrownValueForProspectiveRender(err, route)\n      }\n    }\n  }\n\n  if (hadException || clientDynamicTracking.syncDynamicErrorWithStack) {\n    // We threw something unexpected in the initial render prior to aborting or\n    // we observed a sync abort. In either case we attempt a final render to see if\n    // the error was caused by module loading scope or some other transient cause\n\n    // Reset tracking objects\n    clientDynamicTracking = createDynamicTrackingState(false)\n    dynamicValidation = createDynamicValidationState()\n\n    const secondAttemptClientController = new AbortController()\n    const secondAttemptClientPrerenderStore: PrerenderStore = {\n      type: 'prerender',\n      phase: 'render',\n      implicitTags: [],\n      renderSignal: secondAttemptClientController.signal,\n      // For HTML Generation we don't need to track cache reads (RSC only)\n      cacheSignal: null,\n      // We expect the SSR render to complete in a single Task and need to be able to synchronously abort\n      // When you use APIs that are considered dynamic or synchronous IO.\n      controller: secondAttemptClientController,\n      // We do track dynamic access because searchParams and certain hooks can still be\n      // dynamic during SSR\n      dynamicTracking: clientDynamicTracking,\n      revalidate: INFINITE_CACHE,\n      expire: INFINITE_CACHE,\n      stale: INFINITE_CACHE,\n      tags: [],\n      validating: true,\n    }\n\n    try {\n      await prerenderAndAbortInSequentialTasks(\n        async () => {\n          workUnitAsyncStorage\n            .run(\n              secondAttemptClientPrerenderStore,\n              prerender,\n              <App\n                reactServerStream={secondAttemptReactServerStream}\n                preinitScripts={() => {}}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                nonce={nonce}\n              />,\n              {\n                signal: secondAttemptClientController.signal,\n                onError: SSROnError,\n              }\n            )\n            .catch(() => {})\n          return null\n        },\n        () => {\n          secondAttemptClientController.abort()\n        }\n      )\n    } catch (err) {\n      if (secondAttemptClientController.signal.aborted) {\n        // We aborted the render normally and can ignore this error\n      } else {\n        // We errored in the shell. This should also mean the normal render errored\n        // in the same place so we omit this log except when verbose mode is on.\n        if (process.env.__NEXT_VERBOSE_LOGGING) {\n          printDebugThrownValueForProspectiveRender(err, route)\n        }\n      }\n    }\n  }\n\n  function LogDynamicValidation() {\n    try {\n      throwIfDisallowedDynamic(\n        route,\n        dynamicValidation,\n        serverDynamicTracking,\n        clientDynamicTracking\n      )\n    } catch {}\n    return null\n  }\n\n  resolveValidation(<LogDynamicValidation />)\n}\n\nfunction asHaltedStream(\n  stream: ReadableStream<Uint8Array>,\n  signal: AbortSignal\n) {\n  return new ReadableStream({\n    start(controller: ReadableStreamDefaultController<Uint8Array>) {\n      const reader = stream.getReader()\n      function errorStream(err: unknown) {\n        controller.error(err)\n        reader.cancel(err)\n      }\n      function progressStream({\n        done,\n        value,\n      }: ReadableStreamReadResult<Uint8Array>) {\n        if (done) {\n          // We don't actually close the outer stream because\n          // we might have aborted the inner one but we are simulating a halt\n          return\n        } else {\n          if (!signal.aborted) {\n            controller.enqueue(value)\n            reader.read().then(progressStream, errorStream)\n          } else {\n            // If the signal aborted we leave the stream open but no longer pull from the upstream\n            reader.cancel()\n          }\n        }\n      }\n      reader.read().then(progressStream, errorStream)\n    },\n  })\n}\n\ntype PrerenderToStreamResult = {\n  stream: ReadableStream<Uint8Array>\n  digestErrorsMap: Map<string, DigestedError>\n  ssrErrors: Array<unknown>\n  dynamicAccess?: null | Array<DynamicAccess>\n  collectedRevalidate: number\n  collectedExpire: number\n  collectedStale: number\n  collectedTags: null | string[]\n}\n\n/**\n * Determines whether we should generate static flight data.\n */\nfunction shouldGenerateStaticFlightData(workStore: WorkStore): boolean {\n  const { fallbackRouteParams, isStaticGeneration } = workStore\n  if (!isStaticGeneration) return false\n\n  if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n    return false\n  }\n\n  return true\n}\n\nasync function prerenderToStream(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  ctx: AppRenderContext,\n  metadata: AppPageRenderResultMetadata,\n  workStore: WorkStore,\n  tree: LoaderTree\n): Promise<PrerenderToStreamResult> {\n  ctx.requestStore.phase = 'render'\n\n  // When prerendering formState is always null. We still include it\n  // because some shared APIs expect a formState value and this is slightly\n  // more explicit than making it an optional function argument\n  const formState = null\n\n  const renderOpts = ctx.renderOpts\n  const ComponentMod = renderOpts.ComponentMod\n  // TODO: fix this typescript\n  const clientReferenceManifest = renderOpts.clientReferenceManifest!\n  const fallbackRouteParams = workStore.fallbackRouteParams\n\n  const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =\n    createServerInsertedHTML()\n\n  const tracingMetadata = getTracedMetadata(\n    getTracer().getTracePropagationData(),\n    renderOpts.experimental.clientTraceMetadata\n  )\n\n  const polyfills: JSX.IntrinsicElements['script'][] =\n    renderOpts.buildManifest.polyfillFiles\n      .filter(\n        (polyfill) =>\n          polyfill.endsWith('.js') && !polyfill.endsWith('.module.js')\n      )\n      .map((polyfill) => ({\n        src: `${ctx.assetPrefix}/_next/${polyfill}${getAssetQueryString(\n          ctx,\n          false\n        )}`,\n        integrity: renderOpts.subresourceIntegrityManifest?.[polyfill],\n        crossOrigin: renderOpts.crossOrigin,\n        noModule: true,\n        nonce: ctx.nonce,\n      }))\n\n  const [preinitScripts, bootstrapScript] = getRequiredScripts(\n    renderOpts.buildManifest,\n    // Why is assetPrefix optional on renderOpts?\n    // @TODO make it default empty string on renderOpts and get rid of it from ctx\n    ctx.assetPrefix,\n    renderOpts.crossOrigin,\n    renderOpts.subresourceIntegrityManifest,\n    getAssetQueryString(ctx, true),\n    ctx.nonce,\n    renderOpts.page\n  )\n\n  const reactServerErrorsByDigest: Map<string, DigestedError> = new Map()\n  // We don't report errors during prerendering through our instrumentation hooks\n  const silenceLogger = !!renderOpts.experimental.isRoutePPREnabled\n  function onHTMLRenderRSCError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'react-server-components')\n    )\n  }\n  const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    silenceLogger,\n    onHTMLRenderRSCError\n  )\n\n  function onHTMLRenderSSRError(err: DigestedError) {\n    return renderOpts.onInstrumentationRequestError?.(\n      err,\n      req,\n      createErrorContext(ctx, 'server-rendering')\n    )\n  }\n  const allCapturedErrors: Array<unknown> = []\n  const htmlRendererErrorHandler = createHTMLErrorHandler(\n    !!renderOpts.dev,\n    !!renderOpts.nextExport,\n    reactServerErrorsByDigest,\n    allCapturedErrors,\n    silenceLogger,\n    onHTMLRenderSSRError\n  )\n\n  let reactServerPrerenderResult: null | ReactServerPrerenderResult = null\n  const setHeader = (name: string, value: string | string[]) => {\n    res.setHeader(name, value)\n\n    metadata.headers ??= {}\n    metadata.headers[name] = res.getHeader(name)\n\n    return res\n  }\n\n  let prerenderStore: PrerenderStore | null = null\n\n  try {\n    if (renderOpts.experimental.dynamicIO) {\n      if (renderOpts.experimental.isRoutePPREnabled) {\n        /**\n         * dynamicIO with PPR\n         *\n         * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n         * Once we have settled all cache reads we restart the render and abort after a single Task.\n         *\n         * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n         * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n         * and a synchronous abort might prevent us from filling all caches.\n         *\n         * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n         * and the reactServerIsDynamic value to determine how to treat the resulting render\n         */\n\n        const PRERENDER_COMPLETE = 'NEXT_PRERENDER_COMPLETE'\n        const abortReason = new Error(PRERENDER_COMPLETE)\n\n        const prospectiveRenderFlightController = new AbortController()\n        const prospectiveRenderFlightSignal =\n          prospectiveRenderFlightController.signal\n        const cacheSignal = new CacheSignal()\n\n        const prospectiveRenderPrerenderStore: PrerenderStore =\n          (prerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            implicitTags: ctx.requestStore.implicitTags,\n            renderSignal: prospectiveRenderFlightSignal,\n            cacheSignal,\n            // During the prospective render we don't want to synchronously abort on dynamic access\n            // because it could prevent us from discovering all caches in siblings. So we omit the controller\n            // from the prerender store this time.\n            controller: null,\n            // With PPR during Prerender we don't need to track individual dynamic reasons\n            // because we will always do a final render after caches have filled and we\n            // will track it again there\n            dynamicTracking: null,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...ctx.requestStore.implicitTags],\n          })\n\n        let reactServerIsDynamic = false\n        function prospectiveRenderOnError(err: unknown) {\n          if (isPrerenderInterruptedError(err)) {\n            reactServerIsDynamic = true\n            return err.digest\n          } else if (prospectiveRenderFlightSignal.aborted) {\n            reactServerIsDynamic = true\n            return PRERENDER_COMPLETE\n          } else if (\n            process.env.NEXT_DEBUG_BUILD ||\n            process.env.__NEXT_VERBOSE_LOGGING\n          ) {\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n          // We don't track errors during the prospective render because we will\n          // always do a final render and we cannot infer the errors from this render\n          // are relevant to the final result\n        }\n\n        // We're not going to use the result of this render because the only time it could be used\n        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n        const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n          prospectiveRenderPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        ;(\n          workUnitAsyncStorage.run(\n            // The store to scope\n            prospectiveRenderPrerenderStore,\n            // The function to run\n            ComponentMod.prerender,\n            // ... the arguments for the function to run\n            firstAttemptRSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: prospectiveRenderOnError,\n              // we don't care to track postpones during the prospective render because we need\n              // to always do a final render anyway\n              onPostpone: undefined,\n              signal: prospectiveRenderFlightSignal,\n            }\n          ) as Promise<ReactServerPrerenderResolveToType>\n        ).catch((err) => {\n          if (\n            (process.env.NEXT_DEBUG_BUILD ||\n              process.env.__NEXT_VERBOSE_LOGGING) &&\n            !prospectiveRenderFlightController.signal.aborted &&\n            !isPrerenderInterruptedError(err) &&\n            !isDynamicServerError(err)\n          ) {\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        })\n\n        // When this resolves the cache has no inflight reads and we can ascertain the dynamic outcome\n        await cacheSignal.cacheReady()\n        prospectiveRenderFlightController.abort(abortReason)\n\n        // When PPR is enabled we don't synchronously abort the render when performing a prospective render\n        // because it might prevent us from discovering all caches during the render which is essential\n        // when we perform the second single-task render.\n\n        // Reset the dynamic IO state for the final render\n        reactServerIsDynamic = false\n        const finalRenderFlightController = new AbortController()\n        const finalRenderFlightSignal = finalRenderFlightController.signal\n        const serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n\n        const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          implicitTags: ctx.requestStore.implicitTags,\n          renderSignal: finalRenderFlightSignal,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          // During the final render we do want to abort synchronously on dynamic access so we\n          // include the flight controller in the store.\n          controller: finalRenderFlightController,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...ctx.requestStore.implicitTags],\n        })\n\n        function finalRenderOnError(err: unknown) {\n          if (isPrerenderInterruptedError(err)) {\n            reactServerIsDynamic = true\n            return err.digest\n          } else if (finalRenderFlightSignal.aborted) {\n            reactServerIsDynamic = true\n            return PRERENDER_COMPLETE\n          }\n\n          return serverComponentsErrorHandler(err)\n        }\n\n        const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n          finalRenderPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n        const reactServerResult = (reactServerPrerenderResult =\n          await createReactServerPrerenderResult(\n            prerenderAndAbortInSequentialTasks(\n              () =>\n                workUnitAsyncStorage.run(\n                  // The store to scope\n                  finalRenderPrerenderStore,\n                  // The function to run\n                  ComponentMod.prerender,\n                  // ... the arguments for the function to run\n                  finalAttemptRSCPayload,\n                  clientReferenceManifest.clientModules,\n                  {\n                    onError: finalRenderOnError,\n                    signal: finalRenderFlightSignal,\n                  }\n                ),\n              () => {\n                finalRenderFlightController.abort(abortReason)\n              }\n            )\n          ))\n\n        await warmFlightResponse(\n          reactServerResult.asStream(),\n          clientReferenceManifest\n        )\n\n        let clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const SSRController = new AbortController()\n        const ssrPrerenderStore: PrerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          implicitTags: ctx.requestStore.implicitTags,\n          renderSignal: SSRController.signal,\n          // For HTML Generation we don't need to track cache reads (RSC only)\n          cacheSignal: null,\n          // We don't want to abort synchronously because if there is a sync bailout we\n          // want to discover all that we can within the prerender task.\n          controller: null,\n          // We do track dynamic access because searchParams and certain hooks can still be\n          // dynamic during SSR\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...ctx.requestStore.implicitTags],\n        }\n        let SSRIsDynamic = false\n        let dynamicValidation = createDynamicValidationState()\n        function SSROnError(err: unknown, errorInfo: ErrorInfo) {\n          if (\n            isPrerenderInterruptedError(err) ||\n            SSRController.signal.aborted\n          ) {\n            SSRIsDynamic = true\n\n            const componentStack: string | undefined = (errorInfo as any)\n              .componentStack\n            if (typeof componentStack === 'string') {\n              trackAllowedDynamicAccess(\n                workStore.route,\n                componentStack,\n                dynamicValidation,\n                serverDynamicTracking,\n                clientDynamicTracking\n              )\n            }\n            return\n          }\n\n          return htmlRendererErrorHandler(err, errorInfo)\n        }\n\n        const prerender = require('react-dom/static.edge')\n          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n        let { prelude, postponed } = await prerenderAndAbortInSequentialTasks(\n          () =>\n            workUnitAsyncStorage.run(\n              ssrPrerenderStore,\n              prerender,\n              <App\n                reactServerStream={reactServerResult.asUnclosingStream()}\n                preinitScripts={preinitScripts}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                nonce={ctx.nonce}\n              />,\n              {\n                signal: SSRController.signal,\n                onError: SSROnError,\n                onHeaders: (headers: Headers) => {\n                  headers.forEach((value, key) => {\n                    setHeader(key, value)\n                  })\n                },\n                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                // When debugging the static shell, client-side rendering should be\n                // disabled to prevent blanking out the page.\n                bootstrapScripts: renderOpts.isDebugStaticShell\n                  ? []\n                  : [bootstrapScript],\n              }\n            ),\n          () => {\n            SSRController.abort(abortReason)\n          }\n        )\n\n        if (clientDynamicTracking.syncDynamicErrorWithStack) {\n          // If our SSR render produced it's own sync bailout we need to try again.\n          // It's possible that we loaded a module while performed a sync bailout\n          // however module scope should really be excluded from the prerender scope.\n          // To simulate this we simply render a second time. If the sync API was in module\n          // scope it won't be accessed again but if it was in a component scope it will be\n\n          // Reset tracking objects\n          clientDynamicTracking = createDynamicTrackingState(\n            renderOpts.isDebugDynamicAccesses\n          )\n          dynamicValidation = createDynamicValidationState()\n          SSRIsDynamic = false\n\n          const finalSSRController = new AbortController()\n          const finalSSRPrerenderStore: PrerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            implicitTags: ctx.requestStore.implicitTags,\n            renderSignal: finalSSRController.signal,\n            // For HTML Generation we don't need to track cache reads (RSC only)\n            cacheSignal: null,\n            controller: finalSSRController,\n            // We do track dynamic access because searchParams and certain hooks can still be\n            // dynamic during SSR\n            dynamicTracking: clientDynamicTracking,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...ctx.requestStore.implicitTags],\n          }\n\n          ;({ prelude, postponed } = await prerenderAndAbortInSequentialTasks(\n            () =>\n              workUnitAsyncStorage.run(\n                finalSSRPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={reactServerResult.asUnclosingStream()}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  nonce={ctx.nonce}\n                />,\n                {\n                  signal: finalSSRController.signal,\n                  onError: SSROnError,\n                  onHeaders: (headers: Headers) => {\n                    headers.forEach((value, key) => {\n                      setHeader(key, value)\n                    })\n                  },\n                  maxHeadersLength: renderOpts.reactMaxHeadersLength,\n                  // When debugging the static shell, client-side rendering should be\n                  // disabled to prevent blanking out the page.\n                  bootstrapScripts: renderOpts.isDebugStaticShell\n                    ? []\n                    : [bootstrapScript],\n                }\n              ),\n            () => {\n              finalSSRController.abort(abortReason)\n            }\n          ))\n        }\n\n        throwIfDisallowedDynamic(\n          workStore.route,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n\n        metadata.flightData = await streamToBuffer(reactServerResult.asStream())\n\n        if (SSRIsDynamic || reactServerIsDynamic) {\n          if (postponed != null) {\n            // Dynamic HTML case\n            metadata.postponed = getDynamicHTMLPostponedState(\n              postponed,\n              fallbackRouteParams\n            )\n          } else {\n            // Dynamic Data case\n            metadata.postponed = getDynamicDataPostponedState()\n          }\n          reactServerResult.consume()\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueDynamicPrerender(prelude, {\n              getServerInsertedHTML,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: finalRenderPrerenderStore.stale,\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        } else {\n          // Static case\n          if (workStore.forceDynamic) {\n            throw new StaticGenBailoutError(\n              'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n            )\n          }\n\n          let htmlStream = prelude\n          if (postponed != null) {\n            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n            // so we can set all the postponed boundaries to client render mode before we store the HTML response\n            const resume = require('react-dom/server.edge')\n              .resume as (typeof import('react-dom/server.edge'))['resume']\n\n            // We don't actually want to render anything so we just pass a stream\n            // that never resolves. The resume call is going to abort immediately anyway\n            const foreverStream = new ReadableStream<Uint8Array>()\n\n            const resumeStream = await resume(\n              <App\n                reactServerStream={foreverStream}\n                preinitScripts={() => {}}\n                clientReferenceManifest={clientReferenceManifest}\n                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                nonce={ctx.nonce}\n              />,\n              JSON.parse(JSON.stringify(postponed)),\n              {\n                signal: createPostponedAbortSignal('static prerender resume'),\n                onError: htmlRendererErrorHandler,\n                nonce: ctx.nonce,\n              }\n            )\n\n            // First we write everything from the prerender, then we write everything from the aborted resume render\n            htmlStream = chainStreams(prelude, resumeStream)\n          }\n\n          return {\n            digestErrorsMap: reactServerErrorsByDigest,\n            ssrErrors: allCapturedErrors,\n            stream: await continueStaticPrerender(htmlStream, {\n              inlinedDataStream: createInlinedDataReadableStream(\n                reactServerResult.consumeAsStream(),\n                ctx.nonce,\n                formState\n              ),\n              getServerInsertedHTML,\n            }),\n            dynamicAccess: consumeDynamicAccess(\n              serverDynamicTracking,\n              clientDynamicTracking\n            ),\n            // TODO: Should this include the SSR pass?\n            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n            collectedExpire: finalRenderPrerenderStore.expire,\n            collectedStale: finalRenderPrerenderStore.stale,\n            collectedTags: finalRenderPrerenderStore.tags,\n          }\n        }\n      } else {\n        /**\n         * dynamicIO without PPR\n         *\n         * The general approach is to render the RSC tree first allowing for any inflight\n         * caches to resolve. Once we have settled inflight caches we can check and see if any\n         * synchronous dynamic APIs were used. If so we don't need to bother doing anything more\n         * because the page will be dynamic on re-render anyway\n         *\n         * If no sync dynamic APIs were used we then re-render and abort after a single Task.\n         * If the render errors we know that the page has some dynamic IO. This assumes and relies\n         * upon caches reading from a in process memory cache and resolving in a microtask. While this\n         * is true from our own default cache implementation and if you don't exceed our LRU size it\n         * might not be true for custom cache implementations.\n         *\n         * Future implementations can do some different strategies during build like using IPC to\n         * synchronously fill caches during this special rendering mode. For now this heuristic should work\n         */\n\n        const cache = workStore.incrementalCache\n        if (!cache) {\n          throw new Error(\n            'Expected incremental cache to exist. This is a bug in Next.js'\n          )\n        }\n\n        const PRERENDER_COMPLETE = 'NEXT_PRERENDER_COMPLETE'\n        const abortReason = new Error(PRERENDER_COMPLETE)\n\n        // We need to scope the dynamic IO state per render because we don't want to leak\n        // details between the prospective render and the final render\n        const prospectiveRenderFlightController = new AbortController()\n        const prospectiveRenderFlightSignal =\n          prospectiveRenderFlightController.signal\n\n        const cacheSignal = new CacheSignal()\n        const prospectiveRenderPrerenderStore: PrerenderStore =\n          (prerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            implicitTags: ctx.requestStore.implicitTags,\n            renderSignal: prospectiveRenderFlightSignal,\n            cacheSignal,\n            controller: null,\n            dynamicTracking: null,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...ctx.requestStore.implicitTags],\n          })\n\n        const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n          prospectiveRenderPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        let reactServerIsDynamic = false\n\n        function prospectiveRenderOnError(err: unknown) {\n          if (isPrerenderInterruptedError(err)) {\n            reactServerIsDynamic = true\n            return err.digest\n          } else if (prospectiveRenderFlightSignal.aborted) {\n            reactServerIsDynamic = true\n            return PRERENDER_COMPLETE\n          } else if (process.env.NEXT_DEBUG_BUILD) {\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n          // We don't track errors during the prospective render because we will\n          // always do a final render and we cannot infer the errors from this render\n          // are relevant to the final result\n        }\n\n        try {\n          const prospectiveStream = workUnitAsyncStorage.run(\n            // The store to scope\n            prospectiveRenderPrerenderStore,\n            // The function to run\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            firstAttemptRSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: prospectiveRenderOnError,\n              signal: prospectiveRenderFlightSignal,\n            }\n          ) as ReadableStream<Uint8Array>\n\n          // When this resolves the cache has no inflight reads and we can ascertain the dynamic outcome\n          await cacheSignal.cacheReady()\n          // Even though we could detect whether a sync dynamic API was used we still need to render SSR to\n          // do error validation so we just abort and re-render.\n          prospectiveRenderFlightController.abort(abortReason)\n\n          await warmFlightResponse(prospectiveStream, clientReferenceManifest)\n        } catch (err) {\n          if (\n            process.env.NEXT_DEBUG_BUILD &&\n            err !== abortReason &&\n            !isPrerenderInterruptedError(err) &&\n            !isDynamicServerError(err)\n          ) {\n            printDebugThrownValueForProspectiveRender(err, workStore.route)\n          }\n        }\n\n        // Reset the prerenderState because we are going to retry the render\n        const finalRenderFlightController = new AbortController()\n        const finalRenderFlightSignal = finalRenderFlightController.signal\n        let serverDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        reactServerIsDynamic = false\n        let SSRIsDynamic = false\n\n        const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          implicitTags: ctx.requestStore.implicitTags,\n          renderSignal: finalRenderFlightSignal,\n          // During the final prerender we don't need to track cache access so we omit the signal\n          cacheSignal: null,\n          controller: finalRenderFlightController,\n          dynamicTracking: serverDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...ctx.requestStore.implicitTags],\n        })\n\n        let clientDynamicTracking = createDynamicTrackingState(\n          renderOpts.isDebugDynamicAccesses\n        )\n        const SSRController = new AbortController()\n        const ssrPrerenderStore: PrerenderStore = {\n          type: 'prerender',\n          phase: 'render',\n          implicitTags: ctx.requestStore.implicitTags,\n          renderSignal: SSRController.signal,\n          // For HTML Generation we don't need to track cache reads (RSC only)\n          cacheSignal: null,\n          // During the initial SSR render we won't abort for sync dynamic access becuase\n          // we want to let all modules load (this is like filling a cache). If there was\n          // something sync dynamic we'll do another render to abort it.\n          controller: null,\n          // We do track dynamic access because searchParams and certain hooks can still be\n          // dynamic during SSR\n          dynamicTracking: clientDynamicTracking,\n          revalidate: INFINITE_CACHE,\n          expire: INFINITE_CACHE,\n          stale: INFINITE_CACHE,\n          tags: [...ctx.requestStore.implicitTags],\n        }\n\n        const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n          finalRenderPrerenderStore,\n          getRSCPayload,\n          tree,\n          ctx,\n          res.statusCode === 404\n        )\n\n        function finalRenderOnError(err: unknown) {\n          if (isPrerenderInterruptedError(err)) {\n            reactServerIsDynamic = true\n            return err.digest\n          } else if (finalRenderFlightSignal.aborted) {\n            reactServerIsDynamic = true\n            return PRERENDER_COMPLETE\n          }\n\n          return serverComponentsErrorHandler(err)\n        }\n\n        let dynamicValidation = createDynamicValidationState()\n        function SSROnError(err: unknown, errorInfo?: ErrorInfo) {\n          if (\n            isPrerenderInterruptedError(err) ||\n            SSRController.signal.aborted\n          ) {\n            SSRIsDynamic = true\n\n            const componentStack: string | undefined = (errorInfo as any)\n              .componentStack\n            if (typeof componentStack === 'string') {\n              trackAllowedDynamicAccess(\n                workStore.route,\n                componentStack,\n                dynamicValidation,\n                serverDynamicTracking,\n                clientDynamicTracking\n              )\n            }\n            return\n          }\n\n          return htmlRendererErrorHandler(err, errorInfo)\n        }\n\n        let reactServerStream: ReadableStream<Uint8Array>\n        let htmlStream\n        try {\n          htmlStream = await prerenderAndAbortInSequentialTasks(\n            async () => {\n              const teedStream = (\n                workUnitAsyncStorage.run(\n                  // The store to scope\n                  finalRenderPrerenderStore,\n                  // The function to run\n                  ComponentMod.renderToReadableStream,\n                  // ... the arguments for the function to run\n                  finalAttemptRSCPayload,\n                  clientReferenceManifest.clientModules,\n                  {\n                    onError: finalRenderOnError,\n                    signal: finalRenderFlightSignal,\n                  }\n                ) as ReadableStream<Uint8Array>\n              ).tee()\n\n              reactServerStream = teedStream[0]\n              const rscForSSRStream = teedStream[1]\n\n              const prerender = require('react-dom/static.edge')\n                .prerender as (typeof import('react-dom/static.edge'))['prerender']\n              const { prelude } = await workUnitAsyncStorage.run(\n                ssrPrerenderStore,\n                prerender,\n                <App\n                  reactServerStream={rscForSSRStream}\n                  preinitScripts={preinitScripts}\n                  clientReferenceManifest={clientReferenceManifest}\n                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                  nonce={ctx.nonce}\n                />,\n                {\n                  signal: SSRController.signal,\n                  onError: SSROnError,\n                  // When debugging the static shell, client-side rendering should be\n                  // disabled to prevent blanking out the page.\n                  bootstrapScripts: renderOpts.isDebugStaticShell\n                    ? []\n                    : [bootstrapScript],\n                }\n              )\n              return prelude\n            },\n            () => {\n              SSRController.abort(abortReason)\n              finalRenderFlightController.abort(abortReason)\n            }\n          )\n        } catch (err) {\n          if (finalRenderFlightSignal.aborted || SSRController.signal.aborted) {\n            // We aborted with an incomplete shell. We'll handle this below with the handling\n            // for dynamic.\n          } else {\n            // We have some other kind of shell error, we want to bubble this up to be handled\n            throw err\n          }\n        }\n\n        if (clientDynamicTracking.syncDynamicErrorWithStack) {\n          // If our SSR render produced it's own sync bailout we need to try again.\n          // It's possible that we loaded a module while performed a sync bailout\n          // however module scope should really be excluded from the prerender scope.\n          // To simulate this we simply render a second time. If the sync API was in module\n          // scope it won't be accessed again but if it was in a component scope it will be\n\n          // Reset tracking objects\n          clientDynamicTracking = createDynamicTrackingState(\n            renderOpts.isDebugDynamicAccesses\n          )\n          dynamicValidation = createDynamicValidationState()\n          SSRIsDynamic = false\n          reactServerIsDynamic = false\n\n          serverDynamicTracking = createDynamicTrackingState(\n            renderOpts.isDebugDynamicAccesses\n          )\n          const thirdRenderFlightController = new AbortController()\n          const thirdRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            implicitTags: ctx.requestStore.implicitTags,\n            renderSignal: thirdRenderFlightController.signal,\n            // During the final prerender we don't need to track cache access so we omit the signal\n            cacheSignal: null,\n            controller: thirdRenderFlightController,\n            dynamicTracking: serverDynamicTracking,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...ctx.requestStore.implicitTags],\n          })\n\n          const thirdRenderRSCPayload = await workUnitAsyncStorage.run(\n            finalRenderPrerenderStore,\n            getRSCPayload,\n            tree,\n            ctx,\n            res.statusCode === 404\n          )\n\n          const finalSSRController = new AbortController()\n          const finalSSRPrerenderStore: PrerenderStore = {\n            type: 'prerender',\n            phase: 'render',\n            implicitTags: ctx.requestStore.implicitTags,\n            renderSignal: finalSSRController.signal,\n            // For HTML Generation we don't need to track cache reads (RSC only)\n            cacheSignal: null,\n            controller: finalSSRController,\n            // We do track dynamic access because searchParams and certain hooks can still be\n            // dynamic during SSR\n            dynamicTracking: clientDynamicTracking,\n            revalidate: INFINITE_CACHE,\n            expire: INFINITE_CACHE,\n            stale: INFINITE_CACHE,\n            tags: [...ctx.requestStore.implicitTags],\n          }\n\n          try {\n            htmlStream = await prerenderAndAbortInSequentialTasks(\n              () => {\n                const teedStream = (\n                  workUnitAsyncStorage.run(\n                    // The store to scope\n                    thirdRenderPrerenderStore,\n                    // The function to run\n                    ComponentMod.renderToReadableStream,\n                    // ... the arguments for the function to run\n                    thirdRenderRSCPayload,\n                    clientReferenceManifest.clientModules,\n                    {\n                      onError: finalRenderOnError,\n                      signal: thirdRenderFlightController.signal,\n                    }\n                  ) as ReadableStream<Uint8Array>\n                ).tee()\n\n                reactServerStream = teedStream[0]\n                const rscForSSRStream = teedStream[1]\n\n                const renderToReadableStream = require('react-dom/server.edge')\n                  .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n                const pendingHTMLStream = workUnitAsyncStorage.run(\n                  finalSSRPrerenderStore,\n                  renderToReadableStream,\n                  <App\n                    reactServerStream={rscForSSRStream}\n                    preinitScripts={preinitScripts}\n                    clientReferenceManifest={clientReferenceManifest}\n                    ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                    nonce={ctx.nonce}\n                  />,\n                  {\n                    signal: finalSSRController.signal,\n                    onError: SSROnError,\n                    // When debugging the static shell, client-side rendering should be\n                    // disabled to prevent blanking out the page.\n                    bootstrapScripts: renderOpts.isDebugStaticShell\n                      ? []\n                      : [bootstrapScript],\n                  }\n                )\n                pendingHTMLStream.catch(() => {})\n                return pendingHTMLStream\n              },\n              () => {\n                finalSSRController.abort(abortReason)\n                thirdRenderFlightController.abort(abortReason)\n              }\n            )\n          } catch (err) {\n            if (\n              thirdRenderFlightController.signal.aborted ||\n              finalSSRController.signal.aborted\n            ) {\n              // We aborted with an incomplete shell. We'll handle this below with the handling\n              // for dynamic.\n            } else {\n              // We have some other kind of shell error, we want to bubble this up to be handled\n              throw err\n            }\n          }\n        }\n\n        throwIfDisallowedDynamic(\n          workStore.route,\n          dynamicValidation,\n          serverDynamicTracking,\n          clientDynamicTracking\n        )\n\n        if (SSRIsDynamic) {\n          const dynamicReason = getFirstDynamicReason(clientDynamicTracking)\n          if (dynamicReason) {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n            )\n          } else {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically it accessed data without explicitly caching it. See more info here: https://nextjs.org/docs/messages/dynamic-io`\n            )\n          }\n        } else if (reactServerIsDynamic) {\n          const dynamicReason = getFirstDynamicReason(serverDynamicTracking)\n          if (dynamicReason) {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n            )\n          } else {\n            throw new DynamicServerError(\n              `Route \"${workStore.route}\" couldn't be rendered statically it accessed data without explicitly caching it. See more info here: https://nextjs.org/docs/messages/dynamic-io`\n            )\n          }\n        }\n\n        const reactServerResult =\n          await createReactServerPrerenderResultFromRender(reactServerStream!)\n\n        metadata.flightData = await streamToBuffer(reactServerResult.asStream())\n\n        const getServerInsertedHTML = makeGetServerInsertedHTML({\n          polyfills,\n          renderServerInsertedHTML,\n          serverCapturedErrors: allCapturedErrors,\n          basePath: renderOpts.basePath,\n          tracingMetadata: tracingMetadata,\n        })\n        const validateRootLayout = renderOpts.dev\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueFizzStream(htmlStream!, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              ctx.nonce,\n              formState\n            ),\n            isStaticGeneration: true,\n            getServerInsertedHTML,\n            serverInsertedHTMLToHead: true,\n            validateRootLayout,\n          }),\n          dynamicAccess: consumeDynamicAccess(\n            serverDynamicTracking,\n            clientDynamicTracking\n          ),\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: finalRenderPrerenderStore.revalidate,\n          collectedExpire: finalRenderPrerenderStore.expire,\n          collectedStale: finalRenderPrerenderStore.stale,\n          collectedTags: finalRenderPrerenderStore.tags,\n        }\n      }\n    } else if (renderOpts.experimental.isRoutePPREnabled) {\n      // We're statically generating with PPR and need to do dynamic tracking\n      let dynamicTracking = createDynamicTrackingState(\n        renderOpts.isDebugDynamicAccesses\n      )\n      const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        implicitTags: ctx.requestStore.implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...ctx.requestStore.implicitTags],\n      })\n      const RSCPayload = await workUnitAsyncStorage.run(\n        reactServerPrerenderStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            reactServerPrerenderStore,\n            ComponentMod.renderToReadableStream,\n            // ... the arguments for the function to run\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const ssrPrerenderStore: PrerenderStore = {\n        type: 'prerender-ppr',\n        phase: 'render',\n        implicitTags: ctx.requestStore.implicitTags,\n        dynamicTracking,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...ctx.requestStore.implicitTags],\n      }\n      const prerender = require('react-dom/static.edge')\n        .prerender as (typeof import('react-dom/static.edge'))['prerender']\n      const { prelude, postponed } = await workUnitAsyncStorage.run(\n        ssrPrerenderStore,\n        prerender,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={ctx.nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          onHeaders: (headers: Headers) => {\n            headers.forEach((value, key) => {\n              setHeader(key, value)\n            })\n          },\n          maxHeadersLength: renderOpts.reactMaxHeadersLength,\n          // When debugging the static shell, client-side rendering should be\n          // disabled to prevent blanking out the page.\n          bootstrapScripts: renderOpts.isDebugStaticShell\n            ? []\n            : [bootstrapScript],\n        }\n      )\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n\n      // After awaiting here we've waited for the entire RSC render to complete. Crucially this means\n      // that when we detect whether we've used dynamic APIs below we know we'll have picked up even\n      // parts of the React Server render that might not be used in the SSR render.\n      const flightData = await streamToBuffer(reactServerResult.asStream())\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = flightData\n      }\n\n      /**\n       * When prerendering there are three outcomes to consider\n       *\n       *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)\n       *                      We will need to resume this result when requests are handled and we don't include\n       *                      any server inserted HTML or inlined flight data in the static HTML\n       *\n       *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not\n       *                      resume this render when requests are handled but we will generate new inlined\n       *                      flight data since it is dynamic and differences may end up reconciling on the client\n       *\n       *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode\n       *                      all server inserted HTML and flight data\n       */\n      // First we check if we have any dynamic holes in our HTML prerender\n      if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {\n        if (postponed != null) {\n          // Dynamic HTML case.\n          metadata.postponed = getDynamicHTMLPostponedState(\n            postponed,\n            fallbackRouteParams\n          )\n        } else {\n          // Dynamic Data case.\n          metadata.postponed = getDynamicDataPostponedState()\n        }\n        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include\n        // server inserted html in the static response because the html that is part of the prerender may depend on it\n        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states\n        // require the same set so we unify the code path here\n        reactServerResult.consume()\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else if (fallbackRouteParams && fallbackRouteParams.size > 0) {\n        // Rendering the fallback case.\n        metadata.postponed = getDynamicDataPostponedState()\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueDynamicPrerender(prelude, {\n            getServerInsertedHTML,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      } else {\n        // Static case\n        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response\n        if (workStore.forceDynamic) {\n          throw new StaticGenBailoutError(\n            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n          )\n        }\n\n        let htmlStream = prelude\n        if (postponed != null) {\n          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n          const resume = require('react-dom/server.edge')\n            .resume as (typeof import('react-dom/server.edge'))['resume']\n\n          // We don't actually want to render anything so we just pass a stream\n          // that never resolves. The resume call is going to abort immediately anyway\n          const foreverStream = new ReadableStream<Uint8Array>()\n\n          const resumeStream = await resume(\n            <App\n              reactServerStream={foreverStream}\n              preinitScripts={() => {}}\n              clientReferenceManifest={clientReferenceManifest}\n              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n              nonce={ctx.nonce}\n            />,\n            JSON.parse(JSON.stringify(postponed)),\n            {\n              signal: createPostponedAbortSignal('static prerender resume'),\n              onError: htmlRendererErrorHandler,\n              nonce: ctx.nonce,\n            }\n          )\n\n          // First we write everything from the prerender, then we write everything from the aborted resume render\n          htmlStream = chainStreams(prelude, resumeStream)\n        }\n\n        return {\n          digestErrorsMap: reactServerErrorsByDigest,\n          ssrErrors: allCapturedErrors,\n          stream: await continueStaticPrerender(htmlStream, {\n            inlinedDataStream: createInlinedDataReadableStream(\n              reactServerResult.consumeAsStream(),\n              ctx.nonce,\n              formState\n            ),\n            getServerInsertedHTML,\n          }),\n          dynamicAccess: dynamicTracking.dynamicAccesses,\n          // TODO: Should this include the SSR pass?\n          collectedRevalidate: reactServerPrerenderStore.revalidate,\n          collectedExpire: reactServerPrerenderStore.expire,\n          collectedStale: reactServerPrerenderStore.stale,\n          collectedTags: reactServerPrerenderStore.tags,\n        }\n      }\n    } else {\n      const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n        type: 'prerender-legacy',\n        phase: 'render',\n        implicitTags: ctx.requestStore.implicitTags,\n        revalidate: INFINITE_CACHE,\n        expire: INFINITE_CACHE,\n        stale: INFINITE_CACHE,\n        tags: [...ctx.requestStore.implicitTags],\n      })\n      // This is a regular static generation. We don't do dynamic tracking because we rely on\n      // the old-school dynamic error handling to bail out of static generation\n      const RSCPayload = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        getRSCPayload,\n        tree,\n        ctx,\n        res.statusCode === 404\n      )\n      const reactServerResult = (reactServerPrerenderResult =\n        await createReactServerPrerenderResultFromRender(\n          workUnitAsyncStorage.run(\n            prerenderLegacyStore,\n            ComponentMod.renderToReadableStream,\n            RSCPayload,\n            clientReferenceManifest.clientModules,\n            {\n              onError: serverComponentsErrorHandler,\n            }\n          )\n        ))\n\n      const renderToReadableStream = require('react-dom/server.edge')\n        .renderToReadableStream as (typeof import('react-dom/server.edge'))['renderToReadableStream']\n\n      const htmlStream = await workUnitAsyncStorage.run(\n        prerenderLegacyStore,\n        renderToReadableStream,\n        <App\n          reactServerStream={reactServerResult.asUnclosingStream()}\n          preinitScripts={preinitScripts}\n          clientReferenceManifest={clientReferenceManifest}\n          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n          nonce={ctx.nonce}\n        />,\n        {\n          onError: htmlRendererErrorHandler,\n          nonce: ctx.nonce,\n          // When debugging the static shell, client-side rendering should be\n          // disabled to prevent blanking out the page.\n          bootstrapScripts: renderOpts.isDebugStaticShell\n            ? []\n            : [bootstrapScript],\n        }\n      )\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = await streamToBuffer(reactServerResult.asStream())\n      }\n\n      const getServerInsertedHTML = makeGetServerInsertedHTML({\n        polyfills,\n        renderServerInsertedHTML,\n        serverCapturedErrors: allCapturedErrors,\n        basePath: renderOpts.basePath,\n        tracingMetadata: tracingMetadata,\n      })\n      return {\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(htmlStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            reactServerResult.consumeAsStream(),\n            ctx.nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML,\n          serverInsertedHTMLToHead: true,\n        }),\n        // TODO: Should this include the SSR pass?\n        collectedRevalidate: prerenderLegacyStore.revalidate,\n        collectedExpire: prerenderLegacyStore.expire,\n        collectedStale: prerenderLegacyStore.stale,\n        collectedTags: prerenderLegacyStore.tags,\n      }\n    }\n  } catch (err) {\n    if (\n      isStaticGenBailoutError(err) ||\n      (typeof err === 'object' &&\n        err !== null &&\n        'message' in err &&\n        typeof err.message === 'string' &&\n        err.message.includes(\n          'https://nextjs.org/docs/advanced-features/static-html-export'\n        ))\n    ) {\n      // Ensure that \"next dev\" prints the red error overlay\n      throw err\n    }\n\n    // If this is a static generation error, we need to throw it so that it\n    // can be handled by the caller if we're in static generation mode.\n    if (isDynamicServerError(err)) {\n      throw err\n    }\n\n    // If a bailout made it to this point, it means it wasn't wrapped inside\n    // a suspense boundary.\n    const shouldBailoutToCSR = isBailoutToCSRError(err)\n    if (shouldBailoutToCSR) {\n      const stack = getStackWithoutErrorMessage(err)\n      error(\n        `${err.reason} should be wrapped in a suspense boundary at page \"${ctx.pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n      )\n\n      throw err\n    }\n\n    // If we errored when we did not have an RSC stream to read from. This is\n    // not just a render error, we need to throw early.\n    if (reactServerPrerenderResult === null) {\n      throw err\n    }\n\n    let errorType: 'not-found' | 'redirect' | undefined\n\n    if (isNotFoundError(err)) {\n      errorType = 'not-found'\n      res.statusCode = 404\n    } else if (isRedirectError(err)) {\n      errorType = 'redirect'\n      res.statusCode = getRedirectStatusCodeFromError(err)\n\n      const redirectUrl = addPathPrefix(\n        getURLFromRedirectError(err),\n        renderOpts.basePath\n      )\n\n      // If there were mutable cookies set, we need to set them on the\n      // response.\n      const headers = new Headers()\n      if (appendMutableCookies(headers, ctx.requestStore.mutableCookies)) {\n        setHeader('set-cookie', Array.from(headers.values()))\n      }\n\n      setHeader('location', redirectUrl)\n    } else if (!shouldBailoutToCSR) {\n      res.statusCode = 500\n    }\n\n    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n      renderOpts.buildManifest,\n      ctx.assetPrefix,\n      renderOpts.crossOrigin,\n      renderOpts.subresourceIntegrityManifest,\n      getAssetQueryString(ctx, false),\n      ctx.nonce,\n      '/_not-found/page'\n    )\n\n    const prerenderLegacyStore: PrerenderStore = (prerenderStore = {\n      type: 'prerender-legacy',\n      phase: 'render',\n      implicitTags: ctx.requestStore.implicitTags,\n      revalidate: INFINITE_CACHE,\n      expire: INFINITE_CACHE,\n      stale: INFINITE_CACHE,\n      tags: [...ctx.requestStore.implicitTags],\n    })\n    const errorRSCPayload = await workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      getErrorRSCPayload,\n      tree,\n      ctx,\n      errorType\n    )\n\n    const errorServerStream = workUnitAsyncStorage.run(\n      prerenderLegacyStore,\n      ComponentMod.renderToReadableStream,\n      errorRSCPayload,\n      clientReferenceManifest.clientModules,\n      {\n        onError: serverComponentsErrorHandler,\n      }\n    )\n\n    try {\n      const fizzStream = await renderToInitialFizzStream({\n        ReactDOMServer: require('react-dom/server.edge'),\n        element: (\n          <AppWithoutContext\n            reactServerStream={errorServerStream}\n            preinitScripts={errorPreinitScripts}\n            clientReferenceManifest={clientReferenceManifest}\n            nonce={ctx.nonce}\n          />\n        ),\n        streamOptions: {\n          nonce: ctx.nonce,\n          // Include hydration scripts in the HTML\n          bootstrapScripts: [errorBootstrapScript],\n          formState,\n        },\n      })\n\n      if (shouldGenerateStaticFlightData(workStore)) {\n        metadata.flightData = await streamToBuffer(\n          reactServerPrerenderResult.asStream()\n        )\n      }\n\n      const validateRootLayout = renderOpts.dev\n      return {\n        // Returning the error that was thrown so it can be used to handle\n        // the response in the caller.\n        digestErrorsMap: reactServerErrorsByDigest,\n        ssrErrors: allCapturedErrors,\n        stream: await continueFizzStream(fizzStream, {\n          inlinedDataStream: createInlinedDataReadableStream(\n            // This is intentionally using the readable datastream from the\n            // main render rather than the flight data from the error page\n            // render\n            reactServerPrerenderResult.consumeAsStream(),\n            ctx.nonce,\n            formState\n          ),\n          isStaticGeneration: true,\n          getServerInsertedHTML: makeGetServerInsertedHTML({\n            polyfills,\n            renderServerInsertedHTML,\n            serverCapturedErrors: [],\n            basePath: renderOpts.basePath,\n            tracingMetadata: tracingMetadata,\n          }),\n          serverInsertedHTMLToHead: true,\n          validateRootLayout,\n        }),\n        dynamicAccess: null,\n        collectedRevalidate:\n          prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,\n        collectedExpire:\n          prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,\n        collectedStale:\n          prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE,\n        collectedTags: prerenderStore !== null ? prerenderStore.tags : null,\n      }\n    } catch (finalErr: any) {\n      if (process.env.NODE_ENV === 'development' && isNotFoundError(finalErr)) {\n        const bailOnNotFound: typeof import('../../client/components/dev-root-not-found-boundary').bailOnNotFound =\n          require('../../client/components/dev-root-not-found-boundary').bailOnNotFound\n        bailOnNotFound()\n      }\n      throw finalErr\n    }\n  }\n}\n\nconst loadingChunks: Set<Promise<unknown>> = new Set()\nconst chunkListeners: Array<(x?: unknown) => void> = []\n\nfunction trackChunkLoading(load: Promise<unknown>) {\n  loadingChunks.add(load)\n  load.finally(() => {\n    if (loadingChunks.has(load)) {\n      loadingChunks.delete(load)\n      if (loadingChunks.size === 0) {\n        // We are not currently loading any chunks. We can notify all listeners\n        for (let i = 0; i < chunkListeners.length; i++) {\n          chunkListeners[i]()\n        }\n        chunkListeners.length = 0\n      }\n    }\n  })\n}\n\nexport async function warmFlightResponse(\n  flightStream: ReadableStream<Uint8Array>,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n) {\n  let createFromReadableStream\n  if (process.env.TURBOPACK) {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-turbopack/client.edge').createFromReadableStream\n  } else {\n    createFromReadableStream =\n      // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge').createFromReadableStream\n  }\n\n  try {\n    createFromReadableStream(flightStream, {\n      serverConsumerManifest: {\n        moduleLoading: clientReferenceManifest.moduleLoading,\n        moduleMap: clientReferenceManifest.ssrModuleMapping,\n        serverModuleMap: null,\n      },\n    })\n  } catch {\n    // We don't want to handle errors here but we don't want it to\n    // interrupt the outer flow. We simply ignore it here and expect\n    // it will bubble up during a render\n  }\n\n  // We'll wait at least one task and then if no chunks have started to load\n  // we'll we can infer that there are none to load from this flight response\n  trackChunkLoading(waitAtLeastOneReactRenderTask())\n  return new Promise((r) => {\n    chunkListeners.push(r)\n  })\n}\n"],"names":["React","RenderResult","chainStreams","renderToInitialFizzStream","createDocumentClosingStream","continueFizzStream","continueDynamicPrerender","continueStaticPrerender","continueDynamicHTMLResume","streamToBuffer","streamToString","stripInternalQueries","NEXT_HMR_REFRESH_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_URL","RSC_HEADER","createTrackedMetadataContext","createMetadataContext","createRequestStoreForRender","withWorkStore","isNotFoundError","getURLFromRedirectError","isRedirectError","getRedirectStatusCodeFromError","getImplicitTags","AppRenderSpan","NextNodeServerSpan","getTracer","FlightRenderResult","createFlightReactServerErrorHandler","createHTMLReactServerErrorHandler","createHTMLErrorHandler","isUserLandError","getShortDynamicParamType","dynamicParamTypes","getSegmentParam","getScriptNonceFromHeader","parseAndValidateFlightRouterState","createFlightRouterStateFromLoaderTree","handleAction","isBailoutToCSRError","warn","error","appendMutableCookies","createServerInsertedHTML","getRequiredScripts","addPathPrefix","makeGetServerInsertedHTML","walkTreeWithFlightRouterState","createComponentTree","getAssetQueryString","setReferenceManifestsSingleton","DynamicState","parsePostponedState","getDynamicDataPostponedState","getDynamicHTMLPostponedState","getPostponedFromState","isDynamicServerError","useFlightStream","createInlinedDataReadableStream","StaticGenBailoutError","isStaticGenBailoutError","getStackWithoutErrorMessage","accessedDynamicData","createPostponedAbortSignal","formatDynamicAPIAccesses","isPrerenderInterruptedError","createDynamicTrackingState","createDynamicValidationState","getFirstDynamicReason","trackAllowedDynamicAccess","throwIfDisallowedDynamic","consumeDynamicAccess","getClientComponentLoaderMetrics","wrapClientComponentLoader","createServerModuleMap","isNodeNextRequest","parseParameter","parseRelativeUrl","AppRouter","getServerActionRequestMetadata","createInitialRouterState","createMutableActionQueue","getRevalidateReason","PAGE_SEGMENT_KEY","DynamicServerError","ReactServerResult","createReactServerPrerenderResult","createReactServerPrerenderResultFromRender","prerenderAndAbortInSequentialTasks","printDebugThrownValueForProspectiveRender","scheduleInSequentialTasks","waitAtLeastOneReactRenderTask","workUnitAsyncStorage","CacheSignal","getTracedMetadata","InvariantError","INFINITE_CACHE","flightDataPathHeadKey","parseRequestHeaders","headers","options","isDevWarmupRequest","isDevWarmup","isPrefetchRequest","toLowerCase","undefined","isHmrRefresh","isRSCRequest","shouldProvideFlightRouterState","isRoutePPREnabled","flightRouterState","csp","nonce","createNotFoundLoaderTree","loaderTree","components","children","page","makeGetDynamicParamFromSegment","params","pagePath","fallbackRouteParams","getDynamicParamFromSegment","segment","segmentParam","key","param","value","has","get","Array","isArray","map","i","encodeURIComponent","isCatchall","type","isOptionalCatchall","dynamicParamType","treeSegment","split","slice","flatMap","pathSegment","join","NonIndex","ctx","is404Page","isInvalidStatusCode","res","statusCode","meta","name","content","generateDynamicRSCPayload","requestStore","phase","flightData","componentMod","tree","createServerSearchParamsForMetadata","createServerParamsForMetadata","createMetadataComponents","MetadataBoundary","ViewportBoundary","appUsingSizeAdjustment","url","query","requestId","workStore","skipFlight","preloadCallbacks","searchParams","MetadataTree","getMetadataReady","metadataContext","pathname","renderOpts","createSegmentPath","child","loaderTreeToFilter","parentParams","isFirst","rscPayloadHead","Fragment","injectedCSS","Set","injectedJS","injectedFontPreloadTags","rootLayoutIncluded","path","actionResult","a","f","b","buildId","S","isStaticGeneration","createErrorContext","renderSource","routerKind","routePath","routeType","isAction","revalidateReason","generateDynamicFlightRenderResult","req","onFlightDataRenderError","err","onInstrumentationRequestError","onError","dev","RSCPayload","process","env","NODE_ENV","experimental","dynamicIO","resolveValidation","validationOutlet","createValidationOutlet","_validation","spawnDynamicValidationInDev","clientReferenceManifest","route","flightReadableStream","renderToReadableStream","clientModules","temporaryReferences","fetchMetrics","warmupDevRender","rscPayload","reader","getReader","read","done","prepareInitialCanonicalUrl","search","getRSCPayload","is404","missingSlots","GlobalError","initialTree","errorType","seedData","firstItem","varyHeader","getHeader","couldBeIntercepted","includes","initialHead","P","Preloads","p","assetPrefix","c","m","G","s","postponed","forEach","preloadFn","getErrorRSCPayload","initialSeedData","html","id","head","body","App","reactServerStream","preinitScripts","ServerInsertedHTMLProvider","response","use","initialState","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","location","prerendered","actionQueue","HeadManagerContext","require","Provider","appDir","globalErrorComponent","AppWithoutContext","renderToHTMLOrFlightImpl","parsedRequestHeaders","requestEndedState","postponedState","isNotFoundPath","requestTimestamp","Date","now","serverActionsManifest","ComponentMod","nextFontManifest","serverActions","enableTainting","__next_app__","instrumented","globalThis","__next_require__","__next_chunk_load__","args","loadingChunk","loadChunk","trackChunkLoading","URL","setAppIsrStatus","NEXT_RUNTIME","originalRequest","on","prerenderStore","getStore","isPPR","dynamicTracking","dynamicAccesses","length","usedDynamic","forceDynamic","ended","metrics","reset","startSpan","clientComponentLoading","startTime","clientComponentLoadStart","attributes","clientComponentLoadCount","end","clientComponentLoadTimes","metadata","appUsingSizeAdjust","serverModuleMap","pageName","patchFetch","taintObjectReference","crypto","randomUUID","nanoid","isActionRequest","isServerAction","isPrefetch","setRootSpanAttribute","prerenderToStreamWithTracing","wrap","getBodyResult","spanName","prerenderToStream","dynamicAccess","isDebugDynamicAccesses","access","digestErrorsMap","size","buildFailingError","values","next","ssrErrors","find","pendingRevalidates","pendingRevalidateWrites","revalidatedTags","waitUntil","Promise","all","incrementalCache","revalidateTag","Object","collectedTags","fetchTags","staleHeader","String","collectedStale","setHeader","forceStatic","collectedRevalidate","revalidate","staticBailoutInfo","description","dynamicUsageDescription","stack","dynamicUsageStack","placeholder","Buffer","from","segmentFlightData","Map","stream","renderToStreamWithTracing","renderToStream","formState","actionRequestResult","generateFlight","notFoundLoaderTree","result","assignMetadata","renderToHTMLOrFlight","serverComponentsHmrCache","Error","implicitTags","routeModule","definition","onUpdateCookies","previewProps","run","workAsyncStorage","renderServerInsertedHTML","tracingMetadata","getTracePropagationData","clientTraceMetadata","polyfills","buildManifest","polyfillFiles","filter","polyfill","endsWith","src","integrity","subresourceIntegrityManifest","crossOrigin","noModule","bootstrapScript","reactServerErrorsByDigest","silenceLogger","onHTMLRenderRSCError","serverComponentsErrorHandler","nextExport","onHTMLRenderSSRError","allCapturedErrors","htmlRendererErrorHandler","reactServerResult","bind","prerenderPhase","environmentName","DATA","inlinedReactServerDataStream","tee","resume","htmlStream","getServerInsertedHTML","serverCapturedErrors","basePath","inlinedDataStream","consume","onHeaders","maxHeadersLength","reactMaxHeadersLength","bootstrapScripts","isDebugStaticShell","generateStaticHTML","supportsDynamicResponse","validateRootLayout","serverInsertedHTMLToHead","message","shouldBailoutToCSR","reason","redirectUrl","Headers","mutableCookies","errorPreinitScripts","errorBootstrapScript","errorRSCPayload","errorServerStream","fizzStream","ReactDOMServer","element","streamOptions","finalErr","bailOnNotFound","outlet","resolve","isNotFound","firstAttemptServerController","AbortController","serverDynamicTracking","firstAttemptServerPrerenderStore","renderSignal","signal","cacheSignal","controller","expire","stale","tags","validating","firstAttemptRSCPayload","asHaltedStream","abort","syncDynamicErrorWithStack","cancel","secondAttemptServerController","secondAttemptServerPrerenderStore","secondAttemptRSCPayload","warmupStream","renderStream","warmFlightResponse","prerender","clientDynamicTracking","dynamicValidation","SSROnError","errorInfo","aborted","componentStack","firstAttemptClientController","firstAttemptClientPrerenderStore","firstAttemptReactServerStream","secondAttemptReactServerStream","hadException","catch","__NEXT_VERBOSE_LOGGING","secondAttemptClientController","secondAttemptClientPrerenderStore","LogDynamicValidation","ReadableStream","start","errorStream","progressStream","enqueue","then","shouldGenerateStaticFlightData","reactServerPrerenderResult","PRERENDER_COMPLETE","abortReason","prospectiveRenderFlightController","prospectiveRenderFlightSignal","prospectiveRenderPrerenderStore","reactServerIsDynamic","prospectiveRenderOnError","digest","NEXT_DEBUG_BUILD","onPostpone","cacheReady","finalRenderFlightController","finalRenderFlightSignal","finalRenderPrerenderStore","finalRenderOnError","finalAttemptRSCPayload","asStream","SSRController","ssrPrerenderStore","SSRIsDynamic","prelude","asUnclosingStream","finalSSRController","finalSSRPrerenderStore","collectedExpire","foreverStream","resumeStream","JSON","parse","stringify","consumeAsStream","cache","prospectiveStream","teedStream","rscForSSRStream","thirdRenderFlightController","thirdRenderPrerenderStore","thirdRenderRSCPayload","pendingHTMLStream","dynamicReason","reactServerPrerenderStore","prerenderLegacyStore","loadingChunks","chunkListeners","load","add","finally","delete","flightStream","createFromReadableStream","TURBOPACK","serverConsumerManifest","moduleLoading","moduleMap","ssrModuleMapping","r","push"],"mappings":"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"}