{"version":3,"sources":["../../../src/server/async-storage/cache-scope.external.ts"],"sourcesContent":["import { cacheScopeAsyncLocalStorage } from './cache-scope-instance' with { 'turbopack-transition': 'next-shared' }\n\nexport interface CacheScopeStore {\n  cache: Map<string, any>\n}\n\nexport { cacheScopeAsyncLocalStorage }\n\n/**\n * For dynamic IO handling we want to have a scoped memory\n * cache which can live either the lifetime of a build worker,\n * the lifetime of a specific request, or from a prefetch request\n * to the request for non-prefetch version of a page (with\n * drop-off after so long to prevent memory inflating)\n */\nexport function runWithCacheScope(\n  store: Partial<CacheScopeStore>,\n  fn: (...args: any[]) => Promise<any>\n) {\n  return cacheScopeAsyncLocalStorage.run(\n    {\n      cache: store.cache || new Map(),\n    },\n    fn\n  )\n}\n"],"names":["cacheScopeAsyncLocalStorage","runWithCacheScope","store","fn","run","cache","Map"],"mappings":"AAAA,SAASA,2BAA2B,QAAQ,8BAA8B;IAAE,wBAAwB;AAAc,EAAC;AAMnH,SAASA,2BAA2B,GAAE;AAEtC;;;;;;CAMC,GACD,OAAO,SAASC,kBACdC,KAA+B,EAC/BC,EAAoC;IAEpC,OAAOH,4BAA4BI,GAAG,CACpC;QACEC,OAAOH,MAAMG,KAAK,IAAI,IAAIC;IAC5B,GACAH;AAEJ"}