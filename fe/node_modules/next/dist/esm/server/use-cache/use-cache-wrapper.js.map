{"version":3,"sources":["../../../src/server/use-cache/use-cache-wrapper.ts"],"sourcesContent":["import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n  renderToReadableStream,\n  decodeReply,\n  createTemporaryReferenceSet as createServerTemporaryReferenceSet,\n} from 'react-server-dom-webpack/server.edge'\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n  createFromReadableStream,\n  encodeReply,\n  createTemporaryReferenceSet as createClientTemporaryReferenceSet,\n} from 'react-server-dom-webpack/client.edge'\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport type {\n  UseCacheStore,\n  WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport { runInCleanSnapshot } from '../app-render/clean-async-snapshot.external'\n\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\n\nimport { cacheScopeAsyncLocalStorage } from '../async-storage/cache-scope.external'\n\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\n\nimport {\n  getClientReferenceManifestSingleton,\n  getServerModuleMap,\n} from '../app-render/encryption-utils'\nimport type { CacheScopeStore } from '../async-storage/cache-scope.external'\nimport DefaultCacheHandler from '../lib/cache-handlers/default'\nimport type { CacheHandler, CacheEntry } from '../lib/cache-handlers/types'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\n// If the expire time is less than .\nconst DYNAMIC_EXPIRE = 300\n\nconst cacheHandlersSymbol = Symbol.for('@next/cache-handlers')\nconst _globalThis: typeof globalThis & {\n  [cacheHandlersSymbol]?: {\n    RemoteCache?: CacheHandler\n    DefaultCache?: CacheHandler\n  }\n  __nextCacheHandlers?: Record<string, CacheHandler>\n} = globalThis\n\nconst cacheHandlerMap: Map<string, CacheHandler> = new Map([\n  [\n    'default',\n    _globalThis[cacheHandlersSymbol]?.DefaultCache || DefaultCacheHandler,\n  ],\n  [\n    'remote',\n    // in dev remote maps to default handler\n    // and is meant to be overridden in prod\n    _globalThis[cacheHandlersSymbol]?.RemoteCache || DefaultCacheHandler,\n  ],\n])\n\nfunction generateCacheEntry(\n  workStore: WorkStore,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  cacheScope: undefined | CacheScopeStore,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: any\n): Promise<[ReadableStream, Promise<CacheEntry>]> {\n  // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n  // generation cannot read anything from the context we're currently executing which\n  // might include request specific things like cookies() inside a React.cache().\n  // Note: It is important that we await at least once before this because it lets us\n  // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n  return runInCleanSnapshot(\n    generateCacheEntryWithRestoredWorkStore,\n    workStore,\n    outerWorkUnitStore,\n    cacheScope,\n    clientReferenceManifest,\n    encodedArguments,\n    fn\n  )\n}\n\nfunction generateCacheEntryWithRestoredWorkStore(\n  workStore: WorkStore,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  cacheScope: undefined | CacheScopeStore,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: any\n) {\n  // Since we cleared the AsyncLocalStorage we need to restore the workStore.\n  // Note: We explicitly don't restore the RequestStore nor the PrerenderStore.\n  // We don't want any request specific information leaking an we don't want to create a\n  // bloated fake request mock for every cache call. So any feature that currently lives\n  // in RequestStore but should be available to Caches need to move to WorkStore.\n  // PrerenderStore is not needed inside the cache scope because the outer most one will\n  // be the one to report its result to the outer Prerender.\n  if (cacheScope) {\n    return cacheScopeAsyncLocalStorage.run(cacheScope, () =>\n      workAsyncStorage.run(\n        workStore,\n        generateCacheEntryWithCacheContext,\n        workStore,\n        outerWorkUnitStore,\n        clientReferenceManifest,\n        encodedArguments,\n        fn\n      )\n    )\n  }\n  return workAsyncStorage.run(\n    workStore,\n    generateCacheEntryWithCacheContext,\n    workStore,\n    outerWorkUnitStore,\n    clientReferenceManifest,\n    encodedArguments,\n    fn\n  )\n}\n\nfunction generateCacheEntryWithCacheContext(\n  workStore: WorkStore,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: any\n) {\n  if (!workStore.cacheLifeProfiles) {\n    throw new Error(\n      'cacheLifeProfiles should always be provided. This is a bug in Next.js.'\n    )\n  }\n  const defaultCacheLife = workStore.cacheLifeProfiles['default']\n  if (\n    !defaultCacheLife ||\n    defaultCacheLife.revalidate == null ||\n    defaultCacheLife.expire == null ||\n    defaultCacheLife.stale == null\n  ) {\n    throw new Error(\n      'A default cacheLife profile must always be provided. This is a bug in Next.js.'\n    )\n  }\n\n  // Initialize the Store for this Cache entry.\n  const cacheStore: UseCacheStore = {\n    type: 'cache',\n    phase: 'render',\n    implicitTags:\n      outerWorkUnitStore === undefined ||\n      outerWorkUnitStore.type === 'unstable-cache'\n        ? []\n        : outerWorkUnitStore.implicitTags,\n    revalidate: defaultCacheLife.revalidate,\n    expire: defaultCacheLife.expire,\n    stale: defaultCacheLife.stale,\n    explicitRevalidate: undefined,\n    explicitExpire: undefined,\n    explicitStale: undefined,\n    tags: null,\n  }\n  return workUnitAsyncStorage.run(\n    cacheStore,\n    generateCacheEntryImpl,\n    workStore,\n    outerWorkUnitStore,\n    cacheStore,\n    clientReferenceManifest,\n    encodedArguments,\n    fn\n  )\n}\n\nfunction propagateCacheLifeAndTags(\n  workUnitStore: WorkUnitStore | undefined,\n  entry: CacheEntry\n): void {\n  if (\n    workUnitStore &&\n    (workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-ppr' ||\n      workUnitStore.type === 'prerender-legacy')\n  ) {\n    // Propagate tags and revalidate upwards\n    const outerTags = workUnitStore.tags ?? (workUnitStore.tags = [])\n    const entryTags = entry.tags\n    for (let i = 0; i < entryTags.length; i++) {\n      const tag = entryTags[i]\n      if (!outerTags.includes(tag)) {\n        outerTags.push(tag)\n      }\n    }\n    if (workUnitStore.stale > entry.stale) {\n      workUnitStore.stale = entry.stale\n    }\n    if (workUnitStore.revalidate > entry.revalidate) {\n      workUnitStore.revalidate = entry.revalidate\n    }\n    if (workUnitStore.expire > entry.expire) {\n      workUnitStore.expire = entry.expire\n    }\n  }\n}\n\nasync function collectResult(\n  savedStream: ReadableStream,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  innerCacheStore: UseCacheStore,\n  startTime: number,\n  errors: Array<unknown>, // This is a live array that gets pushed into.,\n  timer: any\n): Promise<CacheEntry> {\n  // We create a buffered stream that collects all chunks until the end to\n  // ensure that RSC has finished rendering and therefore we have collected\n  // all tags. In the future the RSC API might allow for the equivalent of\n  // the allReady Promise that exists on SSR streams.\n  //\n  // If something errored or rejected anywhere in the render, we close\n  // the stream as errored. This lets a CacheHandler choose to save the\n  // partial result up until that point for future hits for a while to avoid\n  // unnecessary retries or not to retry. We use the end of the stream for\n  // this to avoid another complicated side-channel. A receiver has to consider\n  // that the stream might also error for other reasons anyway such as losing\n  // connection.\n\n  const buffer: any[] = []\n  const reader = savedStream.getReader()\n  for (let entry; !(entry = await reader.read()).done; ) {\n    buffer.push(entry.value)\n  }\n\n  let idx = 0\n  const bufferStream = new ReadableStream({\n    pull(controller) {\n      if (idx < buffer.length) {\n        controller.enqueue(buffer[idx++])\n      } else if (errors.length > 0) {\n        // TODO: Should we use AggregateError here?\n        controller.error(errors[0])\n      } else {\n        controller.close()\n      }\n    },\n  })\n\n  const collectedTags = innerCacheStore.tags\n  // If cacheLife() was used to set an explicit revalidate time we use that.\n  // Otherwise, we use the lowest of all inner fetch()/unstable_cache() or nested \"use cache\".\n  // If they're lower than our default.\n  const collectedRevalidate =\n    innerCacheStore.explicitRevalidate !== undefined\n      ? innerCacheStore.explicitRevalidate\n      : innerCacheStore.revalidate\n  const collectedExpire =\n    innerCacheStore.explicitExpire !== undefined\n      ? innerCacheStore.explicitExpire\n      : innerCacheStore.expire\n  const collectedStale =\n    innerCacheStore.explicitStale !== undefined\n      ? innerCacheStore.explicitStale\n      : innerCacheStore.stale\n\n  const entry = {\n    value: bufferStream,\n    timestamp: startTime,\n    revalidate: collectedRevalidate,\n    expire: collectedExpire,\n    stale: collectedStale,\n    tags: collectedTags === null ? [] : collectedTags,\n  }\n  // Propagate tags/revalidate to the parent context.\n  propagateCacheLifeAndTags(outerWorkUnitStore, entry)\n\n  const cacheSignal =\n    outerWorkUnitStore && outerWorkUnitStore.type === 'prerender'\n      ? outerWorkUnitStore.cacheSignal\n      : null\n  if (cacheSignal) {\n    cacheSignal.endRead()\n  }\n\n  if (timer !== undefined) {\n    clearTimeout(timer)\n  }\n\n  return entry\n}\n\nasync function generateCacheEntryImpl(\n  workStore: WorkStore,\n  outerWorkUnitStore: WorkUnitStore | undefined,\n  innerCacheStore: UseCacheStore,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: any\n): Promise<[ReadableStream, Promise<CacheEntry>]> {\n  const temporaryReferences = createServerTemporaryReferenceSet()\n\n  const [, , args] = await decodeReply<any[]>(\n    encodedArguments,\n    getServerModuleMap(),\n    {\n      temporaryReferences,\n    }\n  )\n\n  // Track the timestamp when we started copmuting the result.\n  const startTime = performance.timeOrigin + performance.now()\n  // Invoke the inner function to load a new result.\n  const result = fn.apply(null, args)\n\n  let errors: Array<unknown> = []\n\n  let timer = undefined\n  const controller = new AbortController()\n  if (workStore.isStaticGeneration) {\n    // If we're prerendering, we give you 50 seconds to fill a cache entry. Otherwise\n    // we assume you stalled on hanging input and deopt. This needs to be lower than\n    // just the general timeout of 60 seconds.\n    timer = setTimeout(() => {\n      controller.abort(\n        new Error(\n          'Filling a cache during prerender timed out like because request specific arguments such as ' +\n            'params, searchParams, cookies() or dynamic data was used inside the \"use cache\".'\n        )\n      )\n    }, 50000)\n  }\n\n  const stream = renderToReadableStream(\n    result,\n    clientReferenceManifest.clientModules,\n    {\n      environmentName: 'Cache',\n      signal: controller.signal,\n      temporaryReferences,\n      onError(error: unknown) {\n        // Report the error.\n        console.error(error)\n        errors.push(error)\n      },\n    }\n  )\n\n  const [returnStream, savedStream] = stream.tee()\n\n  const promiseOfCacheEntry = collectResult(\n    savedStream,\n    outerWorkUnitStore,\n    innerCacheStore,\n    startTime,\n    errors,\n    timer\n  )\n\n  // Return the stream as we're creating it. This means that if it ends up\n  // erroring we cannot return a stale-while-error version but it allows\n  // streaming back the result earlier.\n  return [returnStream, promiseOfCacheEntry]\n}\n\nasync function clonePendingCacheEntry(\n  pendingCacheEntry: Promise<CacheEntry>\n): Promise<[CacheEntry, CacheEntry]> {\n  const entry = await pendingCacheEntry\n  const [streamA, streamB] = entry.value.tee()\n  entry.value = streamA\n  const clonedEntry: CacheEntry = {\n    value: streamB,\n    timestamp: entry.timestamp,\n    revalidate: entry.revalidate,\n    expire: entry.expire,\n    stale: entry.stale,\n    tags: entry.tags,\n  }\n  return [entry, clonedEntry]\n}\n\nasync function getNthCacheEntry(\n  split: Promise<[CacheEntry, CacheEntry]>,\n  i: number\n): Promise<CacheEntry> {\n  return (await split)[i]\n}\n\nasync function encodeFormData(formData: FormData): Promise<string> {\n  let result = ''\n  for (let [key, value] of formData) {\n    // We don't need this key to be serializable but from a security perspective it should not be\n    // possible to generate a string that looks the same from a different structure. To ensure this\n    // we need a delimeter between fields but just using a delimeter is not enough since a string\n    // might contain that delimeter. We use the length of each field as the delimeter to avoid\n    // escaping the values.\n    result += key.length.toString(16) + ':' + key\n    let stringValue\n    if (typeof value === 'string') {\n      stringValue = value\n    } else {\n      // The FormData might contain binary data that is not valid UTF-8 so this cache\n      // key may generate a UCS-2 string. Passing this to another service needs to be\n      // aware that the key might not be compatible.\n      const arrayBuffer = await value.arrayBuffer()\n      if (arrayBuffer.byteLength % 2 === 0) {\n        stringValue = String.fromCodePoint(...new Uint16Array(arrayBuffer))\n      } else {\n        stringValue =\n          String.fromCodePoint(\n            ...new Uint16Array(arrayBuffer, 0, (arrayBuffer.byteLength - 1) / 2)\n          ) +\n          String.fromCodePoint(\n            new Uint8Array(arrayBuffer, arrayBuffer.byteLength - 1, 1)[0]\n          )\n      }\n    }\n    result += stringValue.length.toString(16) + ':' + stringValue\n  }\n  return result\n}\n\nexport function cache(kind: string, id: string, fn: any) {\n  if (!process.env.__NEXT_DYNAMIC_IO) {\n    throw new Error(\n      '\"use cache\" is only available with the experimental.dynamicIO config.'\n    )\n  }\n  for (const [key, value] of Object.entries(\n    _globalThis.__nextCacheHandlers || {}\n  )) {\n    cacheHandlerMap.set(key, value as CacheHandler)\n  }\n  const cacheHandler = cacheHandlerMap.get(kind)\n\n  if (cacheHandler === undefined) {\n    throw new Error('Unknown cache handler: ' + kind)\n  }\n  const name = fn.name\n  const cachedFn = {\n    [name]: async function (...args: any[]) {\n      const workStore = workAsyncStorage.getStore()\n      if (workStore === undefined) {\n        throw new Error(\n          '\"use cache\" cannot be used outside of App Router. Expected a WorkStore.'\n        )\n      }\n\n      const workUnitStore = workUnitAsyncStorage.getStore()\n\n      // Get the clientReferenceManifest while we're still in the outer Context.\n      // In case getClientReferenceManifestSingleton is implemented using AsyncLocalStorage.\n      const clientReferenceManifest = getClientReferenceManifestSingleton()\n\n      // Because the Action ID is not yet unique per implementation of that Action we can't\n      // safely reuse the results across builds yet. In the meantime we add the buildId to the\n      // arguments as a seed to ensure they're not reused. Remove this once Action IDs hash\n      // the implementation.\n      const buildId = workStore.buildId\n\n      let abortHangingInputSignal: null | AbortSignal = null\n      if (workUnitStore && workUnitStore.type === 'prerender') {\n        // In a prerender, we may end up with hanging Promises as inputs due them stalling\n        // on connection() or because they're loading dynamic data. In that case we need to\n        // abort the encoding of the arguments since they'll never complete.\n        const controller = new AbortController()\n        abortHangingInputSignal = controller.signal\n        if (workUnitStore.cacheSignal) {\n          // If we have a cacheSignal it means we're in a prospective render. If the input\n          // we're waiting on is coming from another cache, we do want to wait for it so that\n          // we can resolve this cache entry too.\n          workUnitStore.cacheSignal.inputReady().then(() => {\n            controller.abort()\n          })\n        } else {\n          // Otherwise we're in the final render and we should already have all our caches\n          // filled. We might still be waiting on some microtasks so we wait one tick before\n          // giving up. When we give up, we still want to render the content of this cache\n          // as deeply as we can so that we can suspend as deeply as possible in the tree\n          // or not at all if we don't end up waiting for the input.\n          process.nextTick(() => controller.abort())\n        }\n      }\n\n      const temporaryReferences = createClientTemporaryReferenceSet()\n      const encodedArguments: FormData | string = await encodeReply(\n        [buildId, id, args],\n        // Right now this is enough to cause the input to generate hanging Promises\n        // but that's really due to what is probably a React bug in decodeReply.\n        // If that's fixed we may need a different strategy. We can also just skip\n        // the serialization/cache in this scenario and pass-through raw objects.\n        abortHangingInputSignal\n          ? {\n              temporaryReferences,\n              signal: abortHangingInputSignal,\n            }\n          : {\n              temporaryReferences,\n            }\n      )\n\n      const serializedCacheKey =\n        typeof encodedArguments === 'string'\n          ? // Fast path for the simple case for simple inputs. We let the CacheHandler\n            // Convert it to an ArrayBuffer if it wants to.\n            encodedArguments\n          : await encodeFormData(encodedArguments)\n\n      let stream: undefined | ReadableStream = undefined\n\n      const cacheScope: undefined | CacheScopeStore =\n        cacheScopeAsyncLocalStorage.getStore()\n      if (cacheScope) {\n        const cachedEntry: undefined | Promise<CacheEntry> =\n          cacheScope.cache.get(serializedCacheKey)\n        if (cachedEntry !== undefined) {\n          const existingEntry = await cachedEntry\n          propagateCacheLifeAndTags(workUnitStore, existingEntry)\n          if (\n            workUnitStore !== undefined &&\n            workUnitStore.type === 'prerender' &&\n            existingEntry !== undefined &&\n            (existingEntry.revalidate === 0 ||\n              existingEntry.expire < DYNAMIC_EXPIRE)\n          ) {\n            // In a Dynamic I/O prerender, if the cache entry has revalidate: 0 or if the\n            // expire time is under 5 minutes, then we consider this cache entry dynamic\n            // as it's not worth generating static pages for such data. It's better to leave\n            // a PPR hole that can be filled in dynamically with a potentially cached entry.\n            return makeHangingPromise(\n              workUnitStore.renderSignal,\n              'dynamic \"use cache\"'\n            )\n          }\n          const [streamA, streamB] = existingEntry.value.tee()\n          existingEntry.value = streamB\n          stream = streamA\n        }\n      }\n\n      if (stream === undefined) {\n        const cacheSignal =\n          workUnitStore && workUnitStore.type === 'prerender'\n            ? workUnitStore.cacheSignal\n            : null\n        if (cacheSignal) {\n          // Either the cache handler or the generation can be using I/O at this point.\n          // We need to track when they start and when they complete.\n          cacheSignal.beginRead()\n        }\n\n        const implicitTags =\n          workUnitStore === undefined || workUnitStore.type === 'unstable-cache'\n            ? []\n            : workUnitStore.implicitTags\n        const entry: undefined | CacheEntry = await cacheHandler.get(\n          serializedCacheKey,\n          implicitTags\n        )\n        const currentTime = performance.timeOrigin + performance.now()\n        if (\n          workUnitStore !== undefined &&\n          workUnitStore.type === 'prerender' &&\n          entry !== undefined &&\n          (entry.revalidate === 0 || entry.expire < DYNAMIC_EXPIRE)\n        ) {\n          // In a Dynamic I/O prerender, if the cache entry has revalidate: 0 or if the\n          // expire time is under 5 minutes, then we consider this cache entry dynamic\n          // as it's not worth generating static pages for such data. It's better to leave\n          // a PPR hole that can be filled in dynamically with a potentially cached entry.\n          if (cacheSignal) {\n            cacheSignal.endRead()\n          }\n          return makeHangingPromise(\n            workUnitStore.renderSignal,\n            'dynamic \"use cache\"'\n          )\n        } else if (\n          entry === undefined ||\n          currentTime > entry.timestamp + entry.expire * 1000 ||\n          (workStore.isStaticGeneration &&\n            currentTime > entry.timestamp + entry.revalidate * 1000)\n        ) {\n          // Miss. Generate a new result.\n\n          // If the cache entry is stale and we're prerendering, we don't want to use the\n          // stale entry since it would unnecessarily need to shorten the lifetime of the\n          // prerender. We're not time constrained here so we can re-generated it now.\n\n          // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n          // generation cannot read anything from the context we're currently executing which\n          // might include request specific things like cookies() inside a React.cache().\n          // Note: It is important that we await at least once before this because it lets us\n          // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n\n          const [newStream, pendingCacheEntry] = await generateCacheEntry(\n            workStore,\n            workUnitStore,\n            cacheScope,\n            clientReferenceManifest,\n            encodedArguments,\n            fn\n          )\n\n          let savedCacheEntry\n          if (cacheScope) {\n            // Create a clone that goes into the cache scope memory cache.\n            const split = clonePendingCacheEntry(pendingCacheEntry)\n            savedCacheEntry = getNthCacheEntry(split, 0)\n            cacheScope.cache.set(serializedCacheKey, getNthCacheEntry(split, 1))\n          } else {\n            savedCacheEntry = pendingCacheEntry\n          }\n\n          const promise = cacheHandler.set(serializedCacheKey, savedCacheEntry)\n\n          if (!workStore.pendingRevalidateWrites) {\n            workStore.pendingRevalidateWrites = []\n          }\n          workStore.pendingRevalidateWrites.push(promise)\n\n          stream = newStream\n        } else {\n          propagateCacheLifeAndTags(workUnitStore, entry)\n          if (cacheSignal) {\n            // If we're not regenerating we need to signal that we've finished\n            // putting the entry into the cache scope at this point. Otherwise we do\n            // that inside generateCacheEntry.\n            cacheSignal.endRead()\n          }\n\n          if (currentTime > entry.timestamp + entry.revalidate * 1000) {\n            // If this is stale, and we're not in a prerender (i.e. this is dynamic render),\n            // then we should warm up the cache with a fresh revalidated entry.\n            const [ignoredStream, pendingCacheEntry] = await generateCacheEntry(\n              workStore,\n              undefined, // This is not running within the context of this unit.\n              cacheScope,\n              clientReferenceManifest,\n              encodedArguments,\n              fn\n            )\n            const promise = cacheHandler.set(\n              serializedCacheKey,\n              pendingCacheEntry\n            )\n\n            if (!workStore.pendingRevalidateWrites) {\n              workStore.pendingRevalidateWrites = []\n            }\n            workStore.pendingRevalidateWrites.push(promise)\n\n            await ignoredStream.cancel()\n          }\n\n          stream = entry.value\n        }\n      }\n\n      // Logs are replayed even if it's a hit - to ensure we see them on the client eventually.\n      // If we didn't then the client wouldn't see the logs if it was seeded from a prewarm that\n      // never made it to the client. However, this also means that you see logs even when the\n      // cached function isn't actually re-executed. We should instead ensure prewarms always\n      // make it to the client. Another issue is that this will cause double logging in the\n      // server terminal. Once while generating the cache entry and once when replaying it on\n      // the server, which is required to pick it up for replaying again on the client.\n      const replayConsoleLogs = true\n\n      const serverConsumerManifest = {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n        // which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime\n          ? clientReferenceManifest.edgeRscModuleMapping\n          : clientReferenceManifest.rscModuleMapping,\n        serverModuleMap: null,\n      }\n\n      return createFromReadableStream(stream, {\n        serverConsumerManifest,\n        temporaryReferences,\n        replayConsoleLogs,\n        environmentName: 'Cache',\n      })\n    },\n  }[name]\n  return cachedFn\n}\n"],"names":["_globalThis","renderToReadableStream","decodeReply","createTemporaryReferenceSet","createServerTemporaryReferenceSet","createFromReadableStream","encodeReply","createClientTemporaryReferenceSet","workAsyncStorage","workUnitAsyncStorage","runInCleanSnapshot","makeHangingPromise","cacheScopeAsyncLocalStorage","getClientReferenceManifestSingleton","getServerModuleMap","DefaultCacheHandler","isEdgeRuntime","process","env","NEXT_RUNTIME","DYNAMIC_EXPIRE","cacheHandlersSymbol","Symbol","for","globalThis","cacheHandlerMap","Map","DefaultCache","RemoteCache","generateCacheEntry","workStore","outerWorkUnitStore","cacheScope","clientReferenceManifest","encodedArguments","fn","generateCacheEntryWithRestoredWorkStore","run","generateCacheEntryWithCacheContext","cacheLifeProfiles","Error","defaultCacheLife","revalidate","expire","stale","cacheStore","type","phase","implicitTags","undefined","explicitRevalidate","explicitExpire","explicitStale","tags","generateCacheEntryImpl","propagateCacheLifeAndTags","workUnitStore","entry","outerTags","entryTags","i","length","tag","includes","push","collectResult","savedStream","innerCacheStore","startTime","errors","timer","buffer","reader","getReader","read","done","value","idx","bufferStream","ReadableStream","pull","controller","enqueue","error","close","collectedTags","collectedRevalidate","collectedExpire","collectedStale","timestamp","cacheSignal","endRead","clearTimeout","temporaryReferences","args","performance","timeOrigin","now","result","apply","AbortController","isStaticGeneration","setTimeout","abort","stream","clientModules","environmentName","signal","onError","console","returnStream","tee","promiseOfCacheEntry","clonePendingCacheEntry","pendingCacheEntry","streamA","streamB","clonedEntry","getNthCacheEntry","split","encodeFormData","formData","key","toString","stringValue","arrayBuffer","byteLength","String","fromCodePoint","Uint16Array","Uint8Array","cache","kind","id","__NEXT_DYNAMIC_IO","Object","entries","__nextCacheHandlers","set","cacheHandler","get","name","cachedFn","getStore","buildId","abortHangingInputSignal","inputReady","then","nextTick","serializedCacheKey","cachedEntry","existingEntry","renderSignal","beginRead","currentTime","newStream","savedCacheEntry","promise","pendingRevalidateWrites","ignoredStream","cancel","replayConsoleLogs","serverConsumerManifest","moduleLoading","moduleMap","edgeRscModuleMapping","rscModuleMapping","serverModuleMap"],"mappings":"IAsDIA,iCAIA,wCAAwC;AACxC,wCAAwC;AACxCA;AA3DJ,oDAAoD,GACpD,SACEC,sBAAsB,EACtBC,WAAW,EACXC,+BAA+BC,iCAAiC,QAC3D,uCAAsC;AAC7C,oDAAoD,GACpD,SACEC,wBAAwB,EACxBC,WAAW,EACXH,+BAA+BI,iCAAiC,QAC3D,uCAAsC;AAG7C,SAASC,gBAAgB,QAAQ,4CAA2C;AAK5E,SAASC,oBAAoB,QAAQ,iDAAgD;AACrF,SAASC,kBAAkB,QAAQ,8CAA6C;AAEhF,SAASC,kBAAkB,QAAQ,6BAA4B;AAE/D,SAASC,2BAA2B,QAAQ,wCAAuC;AAInF,SACEC,mCAAmC,EACnCC,kBAAkB,QACb,iCAAgC;AAEvC,OAAOC,yBAAyB,gCAA+B;AAG/D,MAAMC,gBAAgBC,QAAQC,GAAG,CAACC,YAAY,KAAK;AAEnD,oCAAoC;AACpC,MAAMC,iBAAiB;AAEvB,MAAMC,sBAAsBC,OAAOC,GAAG,CAAC;AACvC,MAAMvB,cAMFwB;AAEJ,MAAMC,kBAA6C,IAAIC,IAAI;IACzD;QACE;QACA1B,EAAAA,kCAAAA,WAAW,CAACqB,oBAAoB,qBAAhCrB,gCAAkC2B,YAAY,KAAIZ;KACnD;IACD;QACE;QAGAf,EAAAA,mCAAAA,WAAW,CAACqB,oBAAoB,qBAAhCrB,iCAAkC4B,WAAW,KAAIb;KAClD;CACF;AAED,SAASc,mBACPC,SAAoB,EACpBC,kBAA6C,EAC7CC,UAAuC,EACvCC,uBAA8D,EAC9DC,gBAAmC,EACnCC,EAAO;IAEP,kFAAkF;IAClF,mFAAmF;IACnF,+EAA+E;IAC/E,mFAAmF;IACnF,6EAA6E;IAC7E,OAAOzB,mBACL0B,yCACAN,WACAC,oBACAC,YACAC,yBACAC,kBACAC;AAEJ;AAEA,SAASC,wCACPN,SAAoB,EACpBC,kBAA6C,EAC7CC,UAAuC,EACvCC,uBAA8D,EAC9DC,gBAAmC,EACnCC,EAAO;IAEP,2EAA2E;IAC3E,6EAA6E;IAC7E,sFAAsF;IACtF,sFAAsF;IACtF,+EAA+E;IAC/E,sFAAsF;IACtF,0DAA0D;IAC1D,IAAIH,YAAY;QACd,OAAOpB,4BAA4ByB,GAAG,CAACL,YAAY,IACjDxB,iBAAiB6B,GAAG,CAClBP,WACAQ,oCACAR,WACAC,oBACAE,yBACAC,kBACAC;IAGN;IACA,OAAO3B,iBAAiB6B,GAAG,CACzBP,WACAQ,oCACAR,WACAC,oBACAE,yBACAC,kBACAC;AAEJ;AAEA,SAASG,mCACPR,SAAoB,EACpBC,kBAA6C,EAC7CE,uBAA8D,EAC9DC,gBAAmC,EACnCC,EAAO;IAEP,IAAI,CAACL,UAAUS,iBAAiB,EAAE;QAChC,MAAM,IAAIC,MACR;IAEJ;IACA,MAAMC,mBAAmBX,UAAUS,iBAAiB,CAAC,UAAU;IAC/D,IACE,CAACE,oBACDA,iBAAiBC,UAAU,IAAI,QAC/BD,iBAAiBE,MAAM,IAAI,QAC3BF,iBAAiBG,KAAK,IAAI,MAC1B;QACA,MAAM,IAAIJ,MACR;IAEJ;IAEA,6CAA6C;IAC7C,MAAMK,aAA4B;QAChCC,MAAM;QACNC,OAAO;QACPC,cACEjB,uBAAuBkB,aACvBlB,mBAAmBe,IAAI,KAAK,mBACxB,EAAE,GACFf,mBAAmBiB,YAAY;QACrCN,YAAYD,iBAAiBC,UAAU;QACvCC,QAAQF,iBAAiBE,MAAM;QAC/BC,OAAOH,iBAAiBG,KAAK;QAC7BM,oBAAoBD;QACpBE,gBAAgBF;QAChBG,eAAeH;QACfI,MAAM;IACR;IACA,OAAO5C,qBAAqB4B,GAAG,CAC7BQ,YACAS,wBACAxB,WACAC,oBACAc,YACAZ,yBACAC,kBACAC;AAEJ;AAEA,SAASoB,0BACPC,aAAwC,EACxCC,KAAiB;IAEjB,IACED,iBACCA,CAAAA,cAAcV,IAAI,KAAK,WACtBU,cAAcV,IAAI,KAAK,eACvBU,cAAcV,IAAI,KAAK,mBACvBU,cAAcV,IAAI,KAAK,kBAAiB,GAC1C;QACA,wCAAwC;QACxC,MAAMY,YAAYF,cAAcH,IAAI,IAAKG,CAAAA,cAAcH,IAAI,GAAG,EAAE,AAAD;QAC/D,MAAMM,YAAYF,MAAMJ,IAAI;QAC5B,IAAK,IAAIO,IAAI,GAAGA,IAAID,UAAUE,MAAM,EAAED,IAAK;YACzC,MAAME,MAAMH,SAAS,CAACC,EAAE;YACxB,IAAI,CAACF,UAAUK,QAAQ,CAACD,MAAM;gBAC5BJ,UAAUM,IAAI,CAACF;YACjB;QACF;QACA,IAAIN,cAAcZ,KAAK,GAAGa,MAAMb,KAAK,EAAE;YACrCY,cAAcZ,KAAK,GAAGa,MAAMb,KAAK;QACnC;QACA,IAAIY,cAAcd,UAAU,GAAGe,MAAMf,UAAU,EAAE;YAC/Cc,cAAcd,UAAU,GAAGe,MAAMf,UAAU;QAC7C;QACA,IAAIc,cAAcb,MAAM,GAAGc,MAAMd,MAAM,EAAE;YACvCa,cAAcb,MAAM,GAAGc,MAAMd,MAAM;QACrC;IACF;AACF;AAEA,eAAesB,cACbC,WAA2B,EAC3BnC,kBAA6C,EAC7CoC,eAA8B,EAC9BC,SAAiB,EACjBC,MAAsB,EACtBC,KAAU;IAEV,wEAAwE;IACxE,yEAAyE;IACzE,wEAAwE;IACxE,mDAAmD;IACnD,EAAE;IACF,oEAAoE;IACpE,qEAAqE;IACrE,0EAA0E;IAC1E,wEAAwE;IACxE,6EAA6E;IAC7E,2EAA2E;IAC3E,cAAc;IAEd,MAAMC,SAAgB,EAAE;IACxB,MAAMC,SAASN,YAAYO,SAAS;IACpC,IAAK,IAAIhB,OAAO,CAAC,AAACA,CAAAA,QAAQ,MAAMe,OAAOE,IAAI,EAAC,EAAGC,IAAI,EAAI;QACrDJ,OAAOP,IAAI,CAACP,MAAMmB,KAAK;IACzB;IAEA,IAAIC,MAAM;IACV,MAAMC,eAAe,IAAIC,eAAe;QACtCC,MAAKC,UAAU;YACb,IAAIJ,MAAMN,OAAOV,MAAM,EAAE;gBACvBoB,WAAWC,OAAO,CAACX,MAAM,CAACM,MAAM;YAClC,OAAO,IAAIR,OAAOR,MAAM,GAAG,GAAG;gBAC5B,2CAA2C;gBAC3CoB,WAAWE,KAAK,CAACd,MAAM,CAAC,EAAE;YAC5B,OAAO;gBACLY,WAAWG,KAAK;YAClB;QACF;IACF;IAEA,MAAMC,gBAAgBlB,gBAAgBd,IAAI;IAC1C,0EAA0E;IAC1E,4FAA4F;IAC5F,qCAAqC;IACrC,MAAMiC,sBACJnB,gBAAgBjB,kBAAkB,KAAKD,YACnCkB,gBAAgBjB,kBAAkB,GAClCiB,gBAAgBzB,UAAU;IAChC,MAAM6C,kBACJpB,gBAAgBhB,cAAc,KAAKF,YAC/BkB,gBAAgBhB,cAAc,GAC9BgB,gBAAgBxB,MAAM;IAC5B,MAAM6C,iBACJrB,gBAAgBf,aAAa,KAAKH,YAC9BkB,gBAAgBf,aAAa,GAC7Be,gBAAgBvB,KAAK;IAE3B,MAAMa,QAAQ;QACZmB,OAAOE;QACPW,WAAWrB;QACX1B,YAAY4C;QACZ3C,QAAQ4C;QACR3C,OAAO4C;QACPnC,MAAMgC,kBAAkB,OAAO,EAAE,GAAGA;IACtC;IACA,mDAAmD;IACnD9B,0BAA0BxB,oBAAoB0B;IAE9C,MAAMiC,cACJ3D,sBAAsBA,mBAAmBe,IAAI,KAAK,cAC9Cf,mBAAmB2D,WAAW,GAC9B;IACN,IAAIA,aAAa;QACfA,YAAYC,OAAO;IACrB;IAEA,IAAIrB,UAAUrB,WAAW;QACvB2C,aAAatB;IACf;IAEA,OAAOb;AACT;AAEA,eAAeH,uBACbxB,SAAoB,EACpBC,kBAA6C,EAC7CoC,eAA8B,EAC9BlC,uBAA8D,EAC9DC,gBAAmC,EACnCC,EAAO;IAEP,MAAM0D,sBAAsBzF;IAE5B,MAAM,KAAK0F,KAAK,GAAG,MAAM5F,YACvBgC,kBACApB,sBACA;QACE+E;IACF;IAGF,4DAA4D;IAC5D,MAAMzB,YAAY2B,YAAYC,UAAU,GAAGD,YAAYE,GAAG;IAC1D,kDAAkD;IAClD,MAAMC,SAAS/D,GAAGgE,KAAK,CAAC,MAAML;IAE9B,IAAIzB,SAAyB,EAAE;IAE/B,IAAIC,QAAQrB;IACZ,MAAMgC,aAAa,IAAImB;IACvB,IAAItE,UAAUuE,kBAAkB,EAAE;QAChC,iFAAiF;QACjF,gFAAgF;QAChF,0CAA0C;QAC1C/B,QAAQgC,WAAW;YACjBrB,WAAWsB,KAAK,CACd,IAAI/D,MACF,gGACE;QAGR,GAAG;IACL;IAEA,MAAMgE,SAASvG,uBACbiG,QACAjE,wBAAwBwE,aAAa,EACrC;QACEC,iBAAiB;QACjBC,QAAQ1B,WAAW0B,MAAM;QACzBd;QACAe,SAAQzB,KAAc;YACpB,oBAAoB;YACpB0B,QAAQ1B,KAAK,CAACA;YACdd,OAAOL,IAAI,CAACmB;QACd;IACF;IAGF,MAAM,CAAC2B,cAAc5C,YAAY,GAAGsC,OAAOO,GAAG;IAE9C,MAAMC,sBAAsB/C,cAC1BC,aACAnC,oBACAoC,iBACAC,WACAC,QACAC;IAGF,wEAAwE;IACxE,sEAAsE;IACtE,qCAAqC;IACrC,OAAO;QAACwC;QAAcE;KAAoB;AAC5C;AAEA,eAAeC,uBACbC,iBAAsC;IAEtC,MAAMzD,QAAQ,MAAMyD;IACpB,MAAM,CAACC,SAASC,QAAQ,GAAG3D,MAAMmB,KAAK,CAACmC,GAAG;IAC1CtD,MAAMmB,KAAK,GAAGuC;IACd,MAAME,cAA0B;QAC9BzC,OAAOwC;QACP3B,WAAWhC,MAAMgC,SAAS;QAC1B/C,YAAYe,MAAMf,UAAU;QAC5BC,QAAQc,MAAMd,MAAM;QACpBC,OAAOa,MAAMb,KAAK;QAClBS,MAAMI,MAAMJ,IAAI;IAClB;IACA,OAAO;QAACI;QAAO4D;KAAY;AAC7B;AAEA,eAAeC,iBACbC,KAAwC,EACxC3D,CAAS;IAET,OAAO,AAAC,CAAA,MAAM2D,KAAI,CAAE,CAAC3D,EAAE;AACzB;AAEA,eAAe4D,eAAeC,QAAkB;IAC9C,IAAIvB,SAAS;IACb,KAAK,IAAI,CAACwB,KAAK9C,MAAM,IAAI6C,SAAU;QACjC,6FAA6F;QAC7F,+FAA+F;QAC/F,6FAA6F;QAC7F,0FAA0F;QAC1F,uBAAuB;QACvBvB,UAAUwB,IAAI7D,MAAM,CAAC8D,QAAQ,CAAC,MAAM,MAAMD;QAC1C,IAAIE;QACJ,IAAI,OAAOhD,UAAU,UAAU;YAC7BgD,cAAchD;QAChB,OAAO;YACL,+EAA+E;YAC/E,+EAA+E;YAC/E,8CAA8C;YAC9C,MAAMiD,cAAc,MAAMjD,MAAMiD,WAAW;YAC3C,IAAIA,YAAYC,UAAU,GAAG,MAAM,GAAG;gBACpCF,cAAcG,OAAOC,aAAa,IAAI,IAAIC,YAAYJ;YACxD,OAAO;gBACLD,cACEG,OAAOC,aAAa,IACf,IAAIC,YAAYJ,aAAa,GAAG,AAACA,CAAAA,YAAYC,UAAU,GAAG,CAAA,IAAK,MAEpEC,OAAOC,aAAa,CAClB,IAAIE,WAAWL,aAAaA,YAAYC,UAAU,GAAG,GAAG,EAAE,CAAC,EAAE;YAEnE;QACF;QACA5B,UAAU0B,YAAY/D,MAAM,CAAC8D,QAAQ,CAAC,MAAM,MAAMC;IACpD;IACA,OAAO1B;AACT;AAEA,OAAO,SAASiC,MAAMC,IAAY,EAAEC,EAAU,EAAElG,EAAO;IACrD,IAAI,CAAClB,QAAQC,GAAG,CAACoH,iBAAiB,EAAE;QAClC,MAAM,IAAI9F,MACR;IAEJ;IACA,KAAK,MAAM,CAACkF,KAAK9C,MAAM,IAAI2D,OAAOC,OAAO,CACvCxI,YAAYyI,mBAAmB,IAAI,CAAC,GACnC;QACDhH,gBAAgBiH,GAAG,CAAChB,KAAK9C;IAC3B;IACA,MAAM+D,eAAelH,gBAAgBmH,GAAG,CAACR;IAEzC,IAAIO,iBAAiB1F,WAAW;QAC9B,MAAM,IAAIT,MAAM,4BAA4B4F;IAC9C;IACA,MAAMS,OAAO1G,GAAG0G,IAAI;IACpB,MAAMC,WAAW;QACf,CAACD,KAAK,EAAE,eAAgB,GAAG/C,IAAW;YACpC,MAAMhE,YAAYtB,iBAAiBuI,QAAQ;YAC3C,IAAIjH,cAAcmB,WAAW;gBAC3B,MAAM,IAAIT,MACR;YAEJ;YAEA,MAAMgB,gBAAgB/C,qBAAqBsI,QAAQ;YAEnD,0EAA0E;YAC1E,sFAAsF;YACtF,MAAM9G,0BAA0BpB;YAEhC,qFAAqF;YACrF,wFAAwF;YACxF,qFAAqF;YACrF,sBAAsB;YACtB,MAAMmI,UAAUlH,UAAUkH,OAAO;YAEjC,IAAIC,0BAA8C;YAClD,IAAIzF,iBAAiBA,cAAcV,IAAI,KAAK,aAAa;gBACvD,kFAAkF;gBAClF,mFAAmF;gBACnF,oEAAoE;gBACpE,MAAMmC,aAAa,IAAImB;gBACvB6C,0BAA0BhE,WAAW0B,MAAM;gBAC3C,IAAInD,cAAckC,WAAW,EAAE;oBAC7B,gFAAgF;oBAChF,mFAAmF;oBACnF,uCAAuC;oBACvClC,cAAckC,WAAW,CAACwD,UAAU,GAAGC,IAAI,CAAC;wBAC1ClE,WAAWsB,KAAK;oBAClB;gBACF,OAAO;oBACL,gFAAgF;oBAChF,kFAAkF;oBAClF,gFAAgF;oBAChF,+EAA+E;oBAC/E,0DAA0D;oBAC1DtF,QAAQmI,QAAQ,CAAC,IAAMnE,WAAWsB,KAAK;gBACzC;YACF;YAEA,MAAMV,sBAAsBtF;YAC5B,MAAM2B,mBAAsC,MAAM5B,YAChD;gBAAC0I;gBAASX;gBAAIvC;aAAK,EACnB,2EAA2E;YAC3E,wEAAwE;YACxE,0EAA0E;YAC1E,yEAAyE;YACzEmD,0BACI;gBACEpD;gBACAc,QAAQsC;YACV,IACA;gBACEpD;YACF;YAGN,MAAMwD,qBACJ,OAAOnH,qBAAqB,WAExB,+CAA+C;YAC/CA,mBACA,MAAMsF,eAAetF;YAE3B,IAAIsE,SAAqCvD;YAEzC,MAAMjB,aACJpB,4BAA4BmI,QAAQ;YACtC,IAAI/G,YAAY;gBACd,MAAMsH,cACJtH,WAAWmG,KAAK,CAACS,GAAG,CAACS;gBACvB,IAAIC,gBAAgBrG,WAAW;oBAC7B,MAAMsG,gBAAgB,MAAMD;oBAC5B/F,0BAA0BC,eAAe+F;oBACzC,IACE/F,kBAAkBP,aAClBO,cAAcV,IAAI,KAAK,eACvByG,kBAAkBtG,aACjBsG,CAAAA,cAAc7G,UAAU,KAAK,KAC5B6G,cAAc5G,MAAM,GAAGvB,cAAa,GACtC;wBACA,6EAA6E;wBAC7E,4EAA4E;wBAC5E,gFAAgF;wBAChF,gFAAgF;wBAChF,OAAOT,mBACL6C,cAAcgG,YAAY,EAC1B;oBAEJ;oBACA,MAAM,CAACrC,SAASC,QAAQ,GAAGmC,cAAc3E,KAAK,CAACmC,GAAG;oBAClDwC,cAAc3E,KAAK,GAAGwC;oBACtBZ,SAASW;gBACX;YACF;YAEA,IAAIX,WAAWvD,WAAW;gBACxB,MAAMyC,cACJlC,iBAAiBA,cAAcV,IAAI,KAAK,cACpCU,cAAckC,WAAW,GACzB;gBACN,IAAIA,aAAa;oBACf,6EAA6E;oBAC7E,2DAA2D;oBAC3DA,YAAY+D,SAAS;gBACvB;gBAEA,MAAMzG,eACJQ,kBAAkBP,aAAaO,cAAcV,IAAI,KAAK,mBAClD,EAAE,GACFU,cAAcR,YAAY;gBAChC,MAAMS,QAAgC,MAAMkF,aAAaC,GAAG,CAC1DS,oBACArG;gBAEF,MAAM0G,cAAc3D,YAAYC,UAAU,GAAGD,YAAYE,GAAG;gBAC5D,IACEzC,kBAAkBP,aAClBO,cAAcV,IAAI,KAAK,eACvBW,UAAUR,aACTQ,CAAAA,MAAMf,UAAU,KAAK,KAAKe,MAAMd,MAAM,GAAGvB,cAAa,GACvD;oBACA,6EAA6E;oBAC7E,4EAA4E;oBAC5E,gFAAgF;oBAChF,gFAAgF;oBAChF,IAAIsE,aAAa;wBACfA,YAAYC,OAAO;oBACrB;oBACA,OAAOhF,mBACL6C,cAAcgG,YAAY,EAC1B;gBAEJ,OAAO,IACL/F,UAAUR,aACVyG,cAAcjG,MAAMgC,SAAS,GAAGhC,MAAMd,MAAM,GAAG,QAC9Cb,UAAUuE,kBAAkB,IAC3BqD,cAAcjG,MAAMgC,SAAS,GAAGhC,MAAMf,UAAU,GAAG,MACrD;oBACA,+BAA+B;oBAE/B,+EAA+E;oBAC/E,+EAA+E;oBAC/E,4EAA4E;oBAE5E,kFAAkF;oBAClF,mFAAmF;oBACnF,+EAA+E;oBAC/E,mFAAmF;oBACnF,6EAA6E;oBAE7E,MAAM,CAACiH,WAAWzC,kBAAkB,GAAG,MAAMrF,mBAC3CC,WACA0B,eACAxB,YACAC,yBACAC,kBACAC;oBAGF,IAAIyH;oBACJ,IAAI5H,YAAY;wBACd,8DAA8D;wBAC9D,MAAMuF,QAAQN,uBAAuBC;wBACrC0C,kBAAkBtC,iBAAiBC,OAAO;wBAC1CvF,WAAWmG,KAAK,CAACO,GAAG,CAACW,oBAAoB/B,iBAAiBC,OAAO;oBACnE,OAAO;wBACLqC,kBAAkB1C;oBACpB;oBAEA,MAAM2C,UAAUlB,aAAaD,GAAG,CAACW,oBAAoBO;oBAErD,IAAI,CAAC9H,UAAUgI,uBAAuB,EAAE;wBACtChI,UAAUgI,uBAAuB,GAAG,EAAE;oBACxC;oBACAhI,UAAUgI,uBAAuB,CAAC9F,IAAI,CAAC6F;oBAEvCrD,SAASmD;gBACX,OAAO;oBACLpG,0BAA0BC,eAAeC;oBACzC,IAAIiC,aAAa;wBACf,kEAAkE;wBAClE,wEAAwE;wBACxE,kCAAkC;wBAClCA,YAAYC,OAAO;oBACrB;oBAEA,IAAI+D,cAAcjG,MAAMgC,SAAS,GAAGhC,MAAMf,UAAU,GAAG,MAAM;wBAC3D,gFAAgF;wBAChF,mEAAmE;wBACnE,MAAM,CAACqH,eAAe7C,kBAAkB,GAAG,MAAMrF,mBAC/CC,WACAmB,WACAjB,YACAC,yBACAC,kBACAC;wBAEF,MAAM0H,UAAUlB,aAAaD,GAAG,CAC9BW,oBACAnC;wBAGF,IAAI,CAACpF,UAAUgI,uBAAuB,EAAE;4BACtChI,UAAUgI,uBAAuB,GAAG,EAAE;wBACxC;wBACAhI,UAAUgI,uBAAuB,CAAC9F,IAAI,CAAC6F;wBAEvC,MAAME,cAAcC,MAAM;oBAC5B;oBAEAxD,SAAS/C,MAAMmB,KAAK;gBACtB;YACF;YAEA,yFAAyF;YACzF,0FAA0F;YAC1F,wFAAwF;YACxF,uFAAuF;YACvF,qFAAqF;YACrF,uFAAuF;YACvF,iFAAiF;YACjF,MAAMqF,oBAAoB;YAE1B,MAAMC,yBAAyB;gBAC7B,2FAA2F;gBAC3F,yFAAyF;gBACzF,+CAA+C;gBAC/CC,eAAe;gBACfC,WAAWpJ,gBACPiB,wBAAwBoI,oBAAoB,GAC5CpI,wBAAwBqI,gBAAgB;gBAC5CC,iBAAiB;YACnB;YAEA,OAAOlK,yBAAyBmG,QAAQ;gBACtC0D;gBACArE;gBACAoE;gBACAvD,iBAAiB;YACnB;QACF;IACF,CAAC,CAACmC,KAAK;IACP,OAAOC;AACT"}