{"version":3,"sources":["../../../src/server/async-storage/with-work-store.ts"],"sourcesContent":["import type { WithStore } from './with-store'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { RenderOpts } from '../app-render/types'\nimport type { FetchMetric } from '../base-http'\nimport type { RequestLifecycleOpts } from '../base-server'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { CacheLife } from '../use-cache/cache-life'\n\nimport { AfterContext } from '../after/after-context'\n\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nexport type WorkStoreContext = {\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  page: string\n\n  /**\n   * The route parameters that are currently unknown.\n   */\n  fallbackRouteParams: FallbackRouteParams | null\n\n  requestEndedState?: { ended?: boolean }\n  isPrefetchRequest?: boolean\n  renderOpts: {\n    cacheLifeProfiles?: { [profile: string]: CacheLife }\n    incrementalCache?: IncrementalCache\n    isOnDemandRevalidate?: boolean\n    fetchCache?: AppSegmentConfig['fetchCache']\n    isServerAction?: boolean\n    pendingWaitUntil?: Promise<any>\n    experimental: Pick<\n      RenderOpts['experimental'],\n      'isRoutePPREnabled' | 'after' | 'dynamicIO'\n    >\n\n    /**\n     * Fetch metrics attached in patch-fetch.ts\n     **/\n    fetchMetrics?: FetchMetric[]\n\n    /**\n     * A hack around accessing the store value outside the context of the\n     * request.\n     *\n     * @internal\n     * @deprecated should only be used as a temporary workaround\n     */\n    // TODO: remove this when we resolve accessing the store outside the execution context\n    store?: WorkStore\n  } & Pick<\n    // Pull some properties from RenderOpts so that the docs are also\n    // mirrored.\n    RenderOpts,\n    | 'assetPrefix'\n    | 'supportsDynamicResponse'\n    | 'isRevalidate'\n    | 'nextExport'\n    | 'isDraftMode'\n    | 'isDebugDynamicAccesses'\n    | 'buildId'\n  > &\n    Partial<RequestLifecycleOpts> &\n    Partial<Pick<RenderOpts, 'reactLoadableManifest'>>\n}\n\nexport const withWorkStore: WithStore<WorkStore, WorkStoreContext> = <Result>(\n  storage: AsyncLocalStorage<WorkStore>,\n  {\n    page,\n    fallbackRouteParams,\n    renderOpts,\n    requestEndedState,\n    isPrefetchRequest,\n  }: WorkStoreContext,\n  callback: (store: WorkStore) => Result\n): Result => {\n  /**\n   * Rules of Static & Dynamic HTML:\n   *\n   *    1.) We must generate static HTML unless the caller explicitly opts\n   *        in to dynamic HTML support.\n   *\n   *    2.) If dynamic HTML support is requested, we must honor that request\n   *        or throw an error. It is the sole responsibility of the caller to\n   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.\n   *\n   *    3.) If the request is in draft mode, we must generate dynamic HTML.\n   *\n   *    4.) If the request is a server action, we must generate dynamic HTML.\n   *\n   * These rules help ensure that other existing features like request caching,\n   * coalescing, and ISR continue working as intended.\n   */\n  const isStaticGeneration =\n    !renderOpts.supportsDynamicResponse &&\n    !renderOpts.isDraftMode &&\n    !renderOpts.isServerAction\n\n  const store: WorkStore = {\n    isStaticGeneration,\n    page,\n    fallbackRouteParams,\n    route: normalizeAppPath(page),\n    incrementalCache:\n      // we fallback to a global incremental cache for edge-runtime locally\n      // so that it can access the fs cache without mocks\n      renderOpts.incrementalCache || (globalThis as any).__incrementalCache,\n    cacheLifeProfiles: renderOpts.cacheLifeProfiles,\n    isRevalidate: renderOpts.isRevalidate,\n    isPrerendering: renderOpts.nextExport,\n    fetchCache: renderOpts.fetchCache,\n    isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,\n\n    isDraftMode: renderOpts.isDraftMode,\n\n    requestEndedState,\n    isPrefetchRequest,\n    buildId: renderOpts.buildId,\n    reactLoadableManifest: renderOpts?.reactLoadableManifest || {},\n    assetPrefix: renderOpts?.assetPrefix || '',\n\n    afterContext: createAfterContext(renderOpts),\n  }\n\n  // TODO: remove this when we resolve accessing the store outside the execution context\n  renderOpts.store = store\n\n  return storage.run(store, callback, store)\n}\n\nfunction createAfterContext(\n  renderOpts: Partial<RequestLifecycleOpts> & {\n    experimental: Pick<RenderOpts['experimental'], 'after'>\n  }\n): AfterContext | undefined {\n  const isAfterEnabled = renderOpts?.experimental?.after ?? false\n  if (!isAfterEnabled) {\n    return undefined\n  }\n  const { waitUntil, onClose, onAfterTaskError } = renderOpts\n  return new AfterContext({ waitUntil, onClose, onTaskError: onAfterTaskError })\n}\n"],"names":["withWorkStore","storage","page","fallbackRouteParams","renderOpts","requestEndedState","isPrefetchRequest","callback","isStaticGeneration","supportsDynamicResponse","isDraftMode","isServerAction","store","route","normalizeAppPath","incrementalCache","globalThis","__incrementalCache","cacheLifeProfiles","isRevalidate","isPrerendering","nextExport","fetchCache","isOnDemandRevalidate","buildId","reactLoadableManifest","assetPrefix","afterContext","createAfterContext","run","isAfterEnabled","experimental","after","undefined","waitUntil","onClose","onAfterTaskError","AfterContext","onTaskError"],"mappings":";;;;+BAsEaA;;;eAAAA;;;8BA3DgB;0BAEI;AAyD1B,MAAMA,gBAAwD,CACnEC,SACA,EACEC,IAAI,EACJC,mBAAmB,EACnBC,UAAU,EACVC,iBAAiB,EACjBC,iBAAiB,EACA,EACnBC;IAEA;;;;;;;;;;;;;;;;GAgBC,GACD,MAAMC,qBACJ,CAACJ,WAAWK,uBAAuB,IACnC,CAACL,WAAWM,WAAW,IACvB,CAACN,WAAWO,cAAc;IAE5B,MAAMC,QAAmB;QACvBJ;QACAN;QACAC;QACAU,OAAOC,IAAAA,0BAAgB,EAACZ;QACxBa,kBACE,qEAAqE;QACrE,mDAAmD;QACnDX,WAAWW,gBAAgB,IAAI,AAACC,WAAmBC,kBAAkB;QACvEC,mBAAmBd,WAAWc,iBAAiB;QAC/CC,cAAcf,WAAWe,YAAY;QACrCC,gBAAgBhB,WAAWiB,UAAU;QACrCC,YAAYlB,WAAWkB,UAAU;QACjCC,sBAAsBnB,WAAWmB,oBAAoB;QAErDb,aAAaN,WAAWM,WAAW;QAEnCL;QACAC;QACAkB,SAASpB,WAAWoB,OAAO;QAC3BC,uBAAuBrB,CAAAA,8BAAAA,WAAYqB,qBAAqB,KAAI,CAAC;QAC7DC,aAAatB,CAAAA,8BAAAA,WAAYsB,WAAW,KAAI;QAExCC,cAAcC,mBAAmBxB;IACnC;IAEA,sFAAsF;IACtFA,WAAWQ,KAAK,GAAGA;IAEnB,OAAOX,QAAQ4B,GAAG,CAACjB,OAAOL,UAAUK;AACtC;AAEA,SAASgB,mBACPxB,UAEC;QAEsBA;IAAvB,MAAM0B,iBAAiB1B,CAAAA,+BAAAA,2BAAAA,WAAY2B,YAAY,qBAAxB3B,yBAA0B4B,KAAK,KAAI;IAC1D,IAAI,CAACF,gBAAgB;QACnB,OAAOG;IACT;IACA,MAAM,EAAEC,SAAS,EAAEC,OAAO,EAAEC,gBAAgB,EAAE,GAAGhC;IACjD,OAAO,IAAIiC,0BAAY,CAAC;QAAEH;QAAWC;QAASG,aAAaF;IAAiB;AAC9E"}